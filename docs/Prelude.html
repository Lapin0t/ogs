<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>Coq Prelude</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-windowed"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="coq-prelude">
<h1 class="title">Coq Prelude</h1>

<p>This file contains a bunch of setup, global options and imports.</p>
<p>Our notations have evolved quite organically. It would need refactoring, for now we
just disable warnings related to it.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Set Warnings</span> <span class="s2">&quot;-notation-overridden&quot;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Set Warnings</span> <span class="s2">&quot;-parsing&quot;</span>.</span></span></pre><p>Enable negative records with definitional eta-equivalence. A requirement for well-behaved
coinductive types.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Set Primitive Projections</span>.</span></span></pre><p>We use a lot of implicit variable declaration around typeclasses.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Generalizable All Variables</span>.</span></span></pre><p>Import the <a class="reference external" href="https://github.com/mattam82/Coq-Equations">Equations</a> library by Matthieu Sozeau, for Agda-like dependent pattern-matching.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> <span class="kn">Equations</span> <span class="nf">Require</span> <span class="nv">Export</span> <span class="nv">Equations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kt">Set</span> <span class="kn">Equations</span> <span class="nf">Transparent</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kt">Set</span> <span class="kn">Equations</span> <span class="nf">With</span> <span class="nv">UIP</span>.</span></span></pre><p>We import dependent induction tactics and inline rewriting notations from the Coq
standard library.</p>
<p>Also we hook up Equations with axiom K (equivalent to unicity of identity proofs, UIP),
for even more powerful matching.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Coq.Program.Equality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> EqNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prelude-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="prelude-v-chk0"><span class="kn">Lemma</span> <span class="nf">YesUIP</span> : <span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, UIP X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, UIP X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prelude-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="prelude-v-chk1"><span class="nb">intro</span>; <span class="nb">apply</span> EqdepFacts.eq_dep_eq__UIP, EqdepFacts.eq_rect_eq__eq_dep_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">EqdepFacts.Eq_rect_eq X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Eqdep.Eq_rect_eq.eq_rect_eq _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Existing Instance</span> <span class="nf">YesUIP</span>.</span></span></pre><p>We import basic definition for the use of the universe of strict proposition <code class="highlight coq"><span class="kt">SProp</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Coq.Logic.StrictProp.</span></span></pre><p>A bunch of notations and definitions for basic datatypes.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;f ‚àò g&quot;</span> := (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f (g x))
 (<span class="kn">at level</span> <span class="mi">40</span>, <span class="kn">left associativity</span>) : function_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;a ,&#39; b&quot;</span> := (existT _ a b) (<span class="kn">at level</span> <span class="mi">30</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">Definition uncurry {A B} {C : A -&gt; B -&gt; Type} (f : forall a b, C a b) (i : A * B)</span>
<span class="c">  := f (fst i) (snd i).</span>

<span class="c">Definition curry {A B} {C : A -&gt; B -&gt; Type} (f : forall i, C (fst i) (snd i)) a b</span>
<span class="c">  := f (a , b).</span>

<span class="c">#[global] Notation curry&#39; := (fun f a b =&gt; f (a ,&#39; b)).</span>
<span class="c">#[global] Notation uncurry&#39; := (fun f x =&gt; f (projT1 x) (projT2 x)).</span>
<span class="c"> *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;A √ó B&quot;</span> := (prod A%type B%type) (<span class="kn">at level</span> <span class="mi">20</span>).</span></span></pre><p>Finite types.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">T0</span> : <span class="kt">Type</span> := .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Derive</span> <span class="nf">NoConfusion</span> <span class="kr">for</span> T0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">T1</span> : <span class="kt">Type</span> := T1_0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Derive</span> <span class="nf">NoConfusion</span> <span class="kr">for</span> T1.</span></span></pre><p>Absurdity elimination.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ex_falso</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">bot</span> : T0) : A := <span class="kr">match</span> bot <span class="kr">with</span> <span class="kr">end</span>.</span></span></pre><p>Decidable predicates.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;¬¨ P&quot;</span> := (P -&gt; T0) (<span class="kn">at level</span> <span class="mi">5</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">decidable</span> (<span class="nv">X</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
| Yes : X -&gt; decidable X
| No : ¬¨X -&gt; decidable X
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Derive</span> <span class="nf">NoConfusion</span> NoConfusionHom <span class="kr">for</span> decidable.</span></span></pre><p>Subset types based on strict propositions.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">sigS</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : X -&gt; <span class="kt">SProp</span>) := { sub_elt : X ; sub_prf : P sub_elt }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> sub_elt {X P}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> sub_prf {X P}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prelude-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="prelude-v-chk2"><span class="kn">Lemma</span> <span class="nf">sigS_eq</span> {<span class="nv">X</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : X -&gt; <span class="kt">SProp</span>} (<span class="nv">a</span> <span class="nv">b</span> : sigS P)
  (<span class="nv">H</span> : a.(sub_elt) = b.(sub_elt)) : a = b .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">SProp</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>sigS P</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>sub_elt a = sub_elt b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prelude-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="prelude-v-chk3"><span class="nb">destruct</span> a <span class="kr">as</span> [ e p ]; <span class="nb">cbn</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">SProp</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P e</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>sigS P</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>e = sub_elt b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{| sub_elt := e; sub_prf := p |} = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prelude-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="prelude-v-chk4"><span class="nb">revert</span> p; <span class="nb">rewrite</span> H; <span class="nb">intro</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">SProp</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>sigS P</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>e = sub_elt b</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P (sub_elt b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{| sub_elt := sub_elt b; sub_prf := p |} = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">change</span> p <span class="kr">with</span> b.(sub_prf); <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Misc.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">substS</span> {<span class="nv">X</span> : <span class="kt">SProp</span>} (<span class="nv">P</span> : X -&gt; <span class="kt">Type</span>) (<span class="nv">a</span> <span class="nv">b</span> : X) : P a -&gt; P b := <span class="kr">fun</span> <span class="nv">p</span> =&gt; p .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prelude-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="prelude-v-chk5"><span class="kn">Lemma</span> <span class="nf">eq_refl_map2_distr</span> [A B C : <span class="kt">Type</span>] (x : A) (y : B) (f : A -&gt; B -&gt; C)
  : f_equal2 f (@eq_refl _ x) (@eq_refl _ y) = eq_refl .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f_equal2 f eq_refl eq_refl = eq_refl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> YesUIP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">injective</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) := <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y -&gt; x = y .</span></span></pre>
</div>
</div></body>
</html>
