<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>Congruence (Prop. 4)</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-windowed"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="congruence-prop-4">
<h1 class="title">Congruence (Prop. 4)</h1>

<p>We prove in this module that weak bisimilarity is a congruence for composition. The proof
makes a slight technical side step: we prove the composition to be equivalent to an
alternate definition, dully named <tt class="docutils literal">compo_alt</tt>.</p>
<p>Indeed, congruence is a very easy result, demanding basically no assumption. What is
actually hard, is to manage weak bisimilarity proofs, which in contrast to strong
bisimilarity can be hard to tame: instead of synchronizing, at every step they can eat
any number of <tt class="docutils literal">Tau</tt> node on either side, forcing us to do complex inductions in the
middle of our bisimilarity proofs.</p>
<p>Because of this, since our main definition <tt class="docutils literal">compo</tt> is the specific case of composition
of two instances of the machine strategy in the OGS game, we know much more than what we
actually care about. Hence we define the much more general <tt class="docutils literal">compo_alt</tt> composing
<em>any two abstract strategy</em> for the OGS game and prove that one congruent w.r.t. weak
bisimilarity. We then connect these two alternative definitions with a strong bisimilarity,
much more structured, hence easy to prove.</p>
<p>We consider a language abstractly captured as a machine satisfying an
appropriate axiomatization.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kn">Context</span> {<span class="nv">T</span> <span class="nv">C</span>} {<span class="nv">CC</span> : <span class="kp">context</span> T C} {<span class="nv">CL</span> : context_laws T C}.
  <span class="kn">Context</span> {<span class="nv">val</span>} {<span class="nv">VM</span> : subst_monoid val} {<span class="nv">VML</span> : subst_monoid_laws val}.
  <span class="kn">Context</span> {<span class="nv">conf</span>} {<span class="nv">CM</span> : subst_module val conf} {<span class="nv">CML</span> : subst_module_laws val conf}.
  <span class="kn">Context</span> {<span class="nv">obs</span> : obs_struct T C} {<span class="nv">M</span> : machine val conf obs}.
  <span class="kn">Context</span> {<span class="nv">ML</span> : machine_laws val conf obs} {<span class="nv">VV</span> : var_assumptions val}.</span></pre><p>We start off by defining this new, <em>opaque</em> composition.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="congruence-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="congruence-v-chk0"><span class="kn">Record</span> <span class="nf">compo_alt_t</span> (<span class="nv">Œî</span> : C) : <span class="kt">Type</span> := AltT {
    alt_ctx : ogs_ctx ;
    alt_act : ogs_act (obs:=obs) Œî alt_ctx ;
    alt_pas : ogs_pas (obs:=obs) Œî alt_ctx
  } .</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The reference C was not found <span class="kr">in</span> the current
environment.</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Arguments</span> AltT {Œî Œ¶} u v : <span class="nb">rename</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Arguments</span> alt_ctx {Œî}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Arguments</span> alt_act {Œî}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Arguments</span> alt_pas {Œî}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="kn">Definition</span> <span class="nf">compo_alt_body</span> {<span class="nv">Œî</span>}
    : compo_alt_t Œî -&gt; delay (compo_alt_t Œî + obs‚àô Œî)
    := <span class="kr">cofix</span> _compo_body x :=
        go <span class="kr">match</span> x.(alt_act).(_observe) <span class="kr">with</span>
            | RetF r =&gt; RetD (inr r)
            | TauF t =&gt; TauD (_compo_body (AltT t x.(alt_pas)))
            | VisF e k =&gt; RetD (inl (AltT (x.(alt_pas) e) k))
            <span class="kr">end</span> .

  <span class="kn">Definition</span> <span class="nf">compo_alt</span> {<span class="nv">Œî</span> <span class="nv">a</span>} (<span class="nv">u</span> : ogs_act Œî a) (<span class="nv">v</span> : ogs_pas Œî a) : delay (obs‚àô Œî)
    := iter_delay compo_alt_body (AltT u v).</span></pre><p>Now we define our bisimulation candidates, for weak and strong bisimilarity.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kn">Variant</span> <span class="nf">alt_t_weq</span> <span class="nv">Œî</span> : relation (compo_alt_t Œî) :=
  | AltWEq {Œ¶ u1 u2 v1 v2}
    : u1 ‚âà u2
      -&gt; h_pasvR ogs_hg (it_wbisim (eq·µ¢ _)) _ v1 v2
      -&gt; alt_t_weq Œî (AltT (Œ¶:=Œ¶) u1 v1) (AltT (Œ¶:=Œ¶) u2 v2).

  <span class="kn">Variant</span> <span class="nf">alt_t_seq</span> <span class="nv">Œî</span> : relation (compo_alt_t Œî) :=
  | AltSEq {Œ¶ u1 u2 v1 v2}
    : u1 ‚âä u2
      -&gt; h_pasvR ogs_hg (it_eq (eq·µ¢ _)) _ v1 v2
      -&gt; alt_t_seq Œî (AltT (Œ¶:=Œ¶) u1 v1) (AltT (Œ¶:=Œ¶) u2 v2).</span></pre><p>And prove the tedious but direct weak congruence.</p>
<pre class="alectryon-io highlight" id="congruence"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">compo_alt_proper</span> {<span class="nv">Œî</span> <span class="nv">a</span>}
    : Proper (it_wbisim (eq·µ¢ _) a
                ==&gt; h_pasvR ogs_hg (it_wbisim (eq·µ¢ _)) a
                ==&gt; it_wbisim (eq·µ¢ _) T1_0)
        (@compo_alt Œî a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x y H1 u v H2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unshelve</span> <span class="nb">eapply</span> (iter_weq (RX := <span class="kr">fun</span> <span class="nv">_</span> =&gt; alt_t_weq Œî)); [ | <span class="bp">now</span> <span class="nb">econstructor</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">clear</span> a x y H1 u v H2; <span class="nb">intros</span> [] ?? [ ????? Hu Hv ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">revert</span> u1 u2 Hu; <span class="nb">unfold</span> it_wbisim; coinduction R CIH; <span class="nb">intros</span> u1 u2 Hu.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> it_wbisim_step <span class="kr">in</span> Hu; <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="nb">unfold</span> observe <span class="kr">in</span> Hu.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> Hu <span class="kr">as</span> [ ? ? r1 r2 rr ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">dependent destruction</span> rr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">dependent destruction</span> r_rel; <span class="nb">unshelve</span> <span class="nb">econstructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">*</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (RetF (inr r3)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">*</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (RetF (inr r3)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">*</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">remember</span> (_observe u1) <span class="nb">eqn</span>:H; <span class="nb">clear</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">remember</span> (RetF (E:=ogs_e) r3) <span class="nb">eqn</span>:H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> r1; [ <span class="bp">now</span> <span class="nb">rewrite</span> H | <span class="nb">eauto</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">*</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">remember</span> (_observe u2) <span class="nb">eqn</span>:H; <span class="nb">clear</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">remember</span> (RetF (E:=ogs_e) r3) <span class="nb">eqn</span>:H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> r2; [ <span class="bp">now</span> <span class="nb">rewrite</span> H | <span class="nb">eauto</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">*</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="kp">repeat</span> <span class="nb">econstructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unshelve</span> <span class="nb">econstructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">*</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (TauD (compo_alt_body (AltT t1 v1))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">*</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (TauD (compo_alt_body (AltT t2 v2))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">*</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">remember</span> (_observe u1) <span class="nb">eqn</span>:H; <span class="nb">clear</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">remember</span> (TauF t1) <span class="nb">eqn</span>:H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> r1; [ <span class="bp">now</span> <span class="nb">rewrite</span> H | <span class="nb">auto</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">*</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">remember</span> (_observe u2) <span class="nb">eqn</span>:H; <span class="nb">clear</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">remember</span> (TauF t2) <span class="nb">eqn</span>:H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> r2; [ <span class="bp">now</span> <span class="nb">rewrite</span> H | <span class="nb">auto</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">*</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unshelve</span> <span class="nb">econstructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">*</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (RetF (inl (AltT (v1 q) k1))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">*</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (RetF (inl (AltT (v2 q) k2))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">*</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">remember</span> (_observe u1) <span class="nb">eqn</span>:H; <span class="nb">clear</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">remember</span> (VisF q k1) <span class="nb">eqn</span>:H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> r1; [ <span class="bp">now</span> <span class="nb">rewrite</span> H | <span class="nb">auto</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">*</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">remember</span> (_observe u2) <span class="nb">eqn</span>:H; <span class="nb">clear</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">remember</span> (VisF q k2) <span class="nb">eqn</span>:H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> r2; [ <span class="bp">now</span> <span class="nb">rewrite</span> H | <span class="nb">auto</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">*</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unshelve</span> (<span class="kp">do</span> <span class="mi">3</span> <span class="nb">econstructor</span>); <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>We can inject pairs of machine-strategy states into pairs of opaque states, this will help
us define our next bisimulation candidate.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">reduce_t_inj</span> {<span class="nv">Œî</span>} (<span class="nv">x</span> : reduce_t Œî) : compo_alt_t Œî
     := AltT (m_strat _ x.(red_act)) (m_stratp _ x.(red_pas)) .</span></span></pre><p>Now we relate the normal composition and the opaque composition of opacified states.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kn">Lemma</span> <span class="nf">compo_compo_alt</span> {<span class="nv">Œî</span>} {<span class="nv">x</span> : reduce_t Œî}
        : iter_delay compo_alt_body (reduce_t_inj x) ‚âä iter_delay compo_body x .
  <span class="kn">Proof</span>.
    <span class="nb">apply</span> (iter_cong_strong (RX := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; alt_t_seq _ a (reduce_t_inj b))); <span class="nb">cycle</span> <span class="mi">1</span>.

    <span class="nb">cbn</span>; <span class="nb">destruct</span> (reduce_t_inj x) <span class="kr">as</span> [ Œ¶ u v ]; <span class="nb">econstructor</span>; [ | <span class="nb">intro</span> ]; <span class="nb">eauto</span>.
    <span class="nb">clear</span> x.

    <span class="nb">intros</span> [] ?? H; <span class="nb">dependent destruction</span> H.
    <span class="nb">destruct</span> b <span class="kr">as</span> [ Œ¶ [ c u ] v ]; <span class="nb">cbn</span> <span class="kr">in</span> *.
    <span class="nb">rewrite</span> unfold_mstrat <span class="kr">in</span> H; <span class="nb">apply</span> it_eq_step <span class="kr">in</span> H; <span class="nb">cbn</span> <span class="kr">in</span> H; <span class="nb">unfold</span> observe <span class="kr">in</span> H.
    <span class="nb">apply</span> it_eq_unstep; <span class="nb">cbn</span>.
    <span class="nb">remember</span> (_observe u1) <span class="kr">as</span> ou1; <span class="nb">clear</span> u1 Heqou1.
    <span class="nb">remember</span> (_observe (<span class="kp">eval</span> c)) <span class="kr">as</span> ou2; <span class="nb">clear</span> c Heqou2.

    <span class="nb">destruct</span> ou2.
    - <span class="nb">destruct</span> (m_strat_wrap u r).
      + <span class="nb">cbn</span> <span class="kr">in</span> H; dependent elimination H; <span class="nb">cbn</span>.
        <span class="kp">do</span> <span class="mi">2</span> <span class="nb">econstructor</span>; <span class="bp">exact</span> r_rel.
      + <span class="nb">destruct</span> h; <span class="nb">cbn</span> <span class="kr">in</span> H; dependent elimination H.
        <span class="kp">do</span> <span class="mi">3</span> <span class="nb">econstructor</span>.
        * <span class="nb">apply</span> H0.
        * <span class="bp">exact</span> k_rel.
    - <span class="nb">destruct</span> ou1; dependent elimination H.
      <span class="nb">econstructor</span>.
      <span class="nb">remember</span> (fmap_delay (m_strat_wrap u) t) <span class="kr">as</span> t2; <span class="nb">clear</span> u t Heqt2.
      <span class="nb">revert</span> t1 t2 t_rel; <span class="nb">unfold</span> it_eq <span class="nb">at</span> <span class="mi">2</span>; coinduction R CIH; <span class="nb">intros</span> t1 t2 t_rel.
      <span class="nb">apply</span> it_eq_step <span class="kr">in</span> t_rel; <span class="nb">cbn</span> <span class="kr">in</span> t_rel; <span class="nb">unfold</span> observe <span class="kr">in</span> t_rel; <span class="nb">cbn</span>.
      <span class="nb">remember</span> (_observe t1) <span class="kr">as</span> ot1; <span class="nb">clear</span> t1 Heqot1.
      <span class="nb">remember</span> (_observe t2) <span class="kr">as</span> ot2; <span class="nb">clear</span> t2 Heqot2.
      <span class="nb">destruct</span> ot2.
      + <span class="nb">destruct</span> r.
        * <span class="nb">cbn</span> <span class="kr">in</span> t_rel; dependent elimination t_rel; <span class="nb">cbn</span>.
          <span class="kp">do</span> <span class="mi">2</span> <span class="nb">econstructor</span>; <span class="bp">exact</span> r_rel.
        * <span class="nb">destruct</span> h; dependent elimination t_rel; <span class="nb">cbn</span>.
          <span class="kp">do</span> <span class="mi">3</span> <span class="nb">econstructor</span>.
          <span class="bp">now</span> <span class="nb">apply</span> H0.
          <span class="bp">exact</span> k_rel.
      + dependent elimination t_rel; <span class="nb">econstructor</span>.
        <span class="bp">now</span> <span class="nb">apply</span> CIH.
      + <span class="nb">destruct</span> q.
    - <span class="nb">destruct</span> q.
  <span class="kn">Qed</span>.

  #[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">compo_proper</span> {<span class="nv">Œî</span> <span class="nv">a</span>}
    : Proper (m_strat_act_eqv a
                ==&gt; m_strat_pas_eqv a
                ==&gt; it_wbisim (eq·µ¢ _) T1_0)
        (compo (Œî:=Œî) (a:=a)).
  <span class="kn">Proof</span>.
    <span class="nb">intros</span> ?? Ha ?? Hp.
    <span class="nb">unfold</span> compo; <span class="nb">rewrite</span> &lt;- <span class="mi">2</span> compo_compo_alt.
    <span class="nb">apply</span> compo_alt_proper.
    <span class="bp">exact</span> Ha.
    <span class="bp">exact</span> Hp.
  <span class="kn">Qed</span>.
<span class="kn">End</span> <span class="nf">with_param</span>.</span></pre>
</div>
</div></body>
</html>
