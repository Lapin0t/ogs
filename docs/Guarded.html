<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>Guarded Iteration</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-windowed"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="guarded-iteration">
<h1 class="title">Guarded Iteration</h1>

<p>The <tt class="docutils literal">iter</tt> combinator, adapted directly from the <a class="reference external" href="https://github.com/DeepSpec/InteractionTrees">Interaction Tree library</a>,
happily builds a computation <tt class="docutils literal">iter f</tt> for any set of equations <tt class="docutils literal">f</tt>.
The resulting computation satisfies in particular an unfolding equation:
<tt class="docutils literal">iter f i ‚âà f i &gt;&gt;= case_ (iter f) (ret)</tt>
In general, this solution is however not unique, depriving us from a
powerful tool to prove the equivalence of two computations.</p>
<p>Through this file, we recover uniqueness by introducing an alternate
combinator <tt class="docutils literal">iter_guarded</tt> restricted to so-called <em>guarded</em> sets of equations:
they cannot be reduced to immediately returning a new index to iterate over.
Both combinators agree over guarded equations (w.r.t. to weak bisimilarity), but
the new one satisfies uniqueness.</p>
<p>Then, we refine the result to allow more sets of equations: not all must
be guarded, but they must always finitely lead to a guarded one.</p>
<div class="section" id="guarded-iteration-1">
<h1>Guarded iteration</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">guarded</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">I</span>} {<span class="nv">E</span> : event I I}.</span></span></pre><p>A set of equations is an (indexed) family of computations, i.e. body fed to the
combinator (Def. 30).</p>
<pre class="alectryon-io highlight" id="equation"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eqn</span> <span class="nv">R</span> <span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span> := X ‚áí·µ¢ itree E (Y +·µ¢ R) .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">apply_eqn</span> {<span class="nv">R</span> <span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">q</span> : <span class="nb">eqn</span> R X Y) : itree E (X +·µ¢ R) ‚áí·µ¢ itree E (Y +·µ¢ R) :=
    <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">t</span> =&gt; t &gt;&gt;= <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">r</span> =&gt; <span class="kr">match</span> r <span class="kr">with</span>
                            | inl x =&gt; q _ x
                            | inr y =&gt; Ret&#39; (inr y)
                            <span class="kr">end</span> .</span></span></pre><p>A computation is <em>guarded</em> if it is not reduced to <tt class="docutils literal">Ret (inl i)</tt>, i.e.
if as part of the loop, this specific iteration will be observable w.r.t.
strong bisimilarity. It therefore may:</p>
<ul class="simple">
<li>end the iteration</li>
<li>produce a silent step</li>
<li>produce an external event</li>
</ul>
<p>A set of equation is then said to be guarded if all its equations are guarded
(Def. 33).</p>
<pre class="alectryon-io highlight" id="guarded"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">guarded&#39;</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">i</span>} : itree&#39; E (X +·µ¢ Y) i -&gt; <span class="kt">Prop</span> :=
    | GRet y : guarded&#39; (RetF (inr y))
    | GTau t : guarded&#39; (TauF t)
    | GVis e k : guarded&#39; (VisF e k)
  .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">guarded</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">i</span>} (<span class="nv">t</span> : itree E (X +·µ¢ Y) i)
    := guarded&#39; t.(_observe).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eqn_guarded</span> {<span class="nv">R</span> <span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">e</span> : <span class="nb">eqn</span> R X Y) : <span class="kt">Prop</span>
    := <span class="kr">forall</span> <span class="nv">i</span> (<span class="nv">x</span> : X i), guarded (e i x) .</span></span></pre><p>The <tt class="docutils literal">iter</tt> combinator gets away with putting no restriction on the equations
by aggressively guarding with <tt class="docutils literal">Tau</tt> all recursive calls.
In contrast, by assuming the equations are guarded, we do not need to introduce
any spurious guard: they are only legitimate in the case of returning immediately
a new index, which we can here rule out via <tt class="docutils literal">elim_guarded</tt>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">elim_guarded</span> {<span class="nv">R</span> <span class="nv">X</span> <span class="nv">i</span> <span class="nv">x</span>} : @guarded&#39; R X i (RetF (inl x)) -&gt; T0 := | ! .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">iter_guarded_aux</span> {<span class="nv">R</span> <span class="nv">X</span>}
    (<span class="nv">e</span> : <span class="nb">eqn</span> R X X) (<span class="nv">EG</span> : eqn_guarded e)
    : itree E (X +·µ¢ R) ‚áí·µ¢ itree E R
    := <span class="kr">cofix</span> CIH i t :=
      t &gt;&gt;= <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">r</span> =&gt;
          go <span class="kr">match</span> r <span class="kr">with</span>
            | inl x =&gt; <span class="kr">match</span> (e _ x).(_observe) <span class="kr">as</span> t <span class="kr">return</span> guarded&#39; t -&gt; _ <span class="kr">with</span>
                      | RetF (inl x) =&gt; <span class="kr">fun</span> <span class="nv">g</span> =&gt; ex_falso (elim_guarded g)
                      | RetF (inr r) =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; RetF r
                      | TauF t       =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; TauF (CIH _ t)
                      | VisF q k     =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; VisF q (<span class="kr">fun</span> <span class="nv">r</span> =&gt; CIH _ (k r))
                      <span class="kr">end</span> (EG _ x)
            | inr y =&gt; RetF y
            <span class="kr">end</span> .</span></span></pre><p>A better iteration for guarded equations.</p>
<pre class="alectryon-io highlight" id="iterguarded"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">iter_guarded</span> {<span class="nv">R</span> <span class="nv">X</span>}
    (<span class="nv">f</span> : <span class="nb">eqn</span> R X X) (<span class="nv">EG</span> : eqn_guarded f)
    : X ‚áí·µ¢ itree E R
    := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">x</span> =&gt;
      go (<span class="kr">match</span> (f _ x).(_observe) <span class="kr">as</span> t <span class="kr">return</span> guarded&#39; t -&gt; _ <span class="kr">with</span>
          | RetF (inl x) =&gt; <span class="kr">fun</span> <span class="nv">g</span> =&gt; ex_falso (elim_guarded g)
          | RetF (inr r) =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; RetF r
          | TauF t       =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; TauF (iter_guarded_aux f EG _ t)
          | VisF q k     =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; VisF q (<span class="kr">fun</span> <span class="nv">r</span> =&gt; iter_guarded_aux f EG _ (k r))
          <span class="kr">end</span> (EG _ x)) .</span></span></pre><p>The absence of a spurious guard is reflected in the unfolding equation:
w.r.t. strong bisimilarity, it directly satisfies what one would expect,
i.e. we run the current equation, and either terminate or jump to the next
one.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk0"><span class="kn">Lemma</span> <span class="nf">iter_guarded_aux_unfold</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">RY</span>} {<span class="nv">_</span> : Reflexive·µ¢ RY}
    (<span class="nv">f</span> : <span class="nb">eqn</span> Y X X) (<span class="nv">EG</span> : eqn_guarded f) {<span class="nv">i</span>} (<span class="nv">t</span> : itree E (X +·µ¢ Y) i)
    : it_eq RY
      (iter_guarded_aux f EG i t)
      (t &gt;&gt;= <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">r</span> =&gt; <span class="kr">match</span> r <span class="kr">with</span>
                     | inl x =&gt; iter_guarded f EG _ x
                     | inr y =&gt; Ret&#39; y
                     <span class="kr">end</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq RY (iter_guarded_aux f EG i t)
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq RY (iter_guarded_aux f EG i t)
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk2"><span class="nb">revert</span> i t; <span class="nb">unfold</span> it_eq; coinduction R CIH; <span class="nb">intros</span> i t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_bt E RY R i (iter_guarded_aux f EG i t)
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk3"><span class="nb">cbn</span>; <span class="nb">pose</span> (ot := _observe t); <span class="nb">fold</span> ot.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>ot</var><span><span class="hyp-body"><b>:= </b><span>_observe t</span></span><span class="hyp-type"><b>: </b><span>itree&#39; E (X +·µ¢ Y) i</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  <span class="kr">match</span> ot <span class="kr">with</span>
  | RetF (inl x) =&gt;
      <span class="kr">match</span>
        _observe (f i x) <span class="kr">as</span> t
        <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
      <span class="kr">with</span>
      | RetF r0 =&gt;
          <span class="kr">match</span>
            r0 <span class="kr">as</span> r1
            <span class="kr">return</span>
              (guarded&#39; (RetF r1) -&gt; itree&#39; E Y i)
          <span class="kr">with</span>
          | inl x0 =&gt; ex_falso ‚àò elim_guarded
          | inr r1 =&gt;
              <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r1)) =&gt;
              RetF r1
          <span class="kr">end</span>
      | TauF t =&gt;
          <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
          TauF (iter_guarded_aux f EG i t)
      | VisF q k =&gt;
          <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
          VisF q
            (<span class="kr">fun</span> <span class="nv">r0</span> : e_rsp q =&gt;
             iter_guarded_aux f EG (e_nxt r0) (k r0))
      <span class="kr">end</span> (EG i x)
  | RetF (inr y) =&gt; RetF y
  | TauF t =&gt;
      TauF
        ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
          {|
            _observe :=
              <span class="kr">match</span> r <span class="kr">with</span>
              | inl x =&gt;
                  <span class="kr">match</span>
                    _observe (f i x) <span class="kr">as</span> t0
                    <span class="kr">return</span>
                      (guarded&#39; t0 -&gt; itree&#39; E Y i)
                  <span class="kr">with</span>
                  | RetF r0 =&gt;
                      <span class="kr">match</span>
                        r0 <span class="kr">as</span> r1
                        <span class="kr">return</span>
                          (guarded&#39; (RetF r1) -&gt;
                           itree&#39; E Y i)
                      <span class="kr">with</span>
                      | inl x0 =&gt;
                          ex_falso ‚àò elim_guarded
                      | inr r1 =&gt;
                          <span class="kr">fun</span>
                            <span class="nv">_</span> : guarded&#39;
                                  (RetF (inr r1)) =&gt;
                          RetF r1
                      <span class="kr">end</span>
                  | TauF t0 =&gt;
                      <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t0) =&gt;
                      TauF
                        (iter_guarded_aux f EG i t0)
                  | VisF q k =&gt;
                      <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
                      VisF q
                        (<span class="kr">fun</span> <span class="nv">r0</span> : e_rsp q =&gt;
                         iter_guarded_aux f EG
                           (e_nxt r0) (k r0))
                  <span class="kr">end</span> (EG i x)
              | inr y =&gt; RetF y
              <span class="kr">end</span>
          |}) =&lt;&lt; t)
  | VisF e k =&gt;
      VisF e
        (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
         (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
          {|
            _observe :=
              <span class="kr">match</span> r0 <span class="kr">with</span>
              | inl x =&gt;
                  <span class="kr">match</span>
                    _observe (f i x) <span class="kr">as</span> t
                    <span class="kr">return</span>
                      (guarded&#39; t -&gt; itree&#39; E Y i)
                  <span class="kr">with</span>
                  | RetF r1 =&gt;
                      <span class="kr">match</span>
                        r1 <span class="kr">as</span> r2
                        <span class="kr">return</span>
                          (guarded&#39; (RetF r2) -&gt;
                           itree&#39; E Y i)
                      <span class="kr">with</span>
                      | inl x0 =&gt;
                          ex_falso ‚àò elim_guarded
                      | inr r2 =&gt;
                          <span class="kr">fun</span>
                            <span class="nv">_</span> : guarded&#39;
                                  (RetF (inr r2)) =&gt;
                          RetF r2
                      <span class="kr">end</span>
                  | TauF t =&gt;
                      <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
                      TauF (iter_guarded_aux f EG i t)
                  | VisF q k0 =&gt;
                      <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k0) =&gt;
                      VisF q
                        (<span class="kr">fun</span> <span class="nv">r1</span> : e_rsp q =&gt;
                         iter_guarded_aux f EG
                           (e_nxt r1) (k0 r1))
                  <span class="kr">end</span> (EG i x)
              | inr y =&gt; RetF y
              <span class="kr">end</span>
          |}) =&lt;&lt; k r)
  <span class="kr">end</span>
  <span class="kr">match</span> ot <span class="kr">with</span>
  | RetF r =&gt;
      _observe
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; iter_guarded f EG i x
        | inr y =&gt; Ret&#39; y
        <span class="kr">end</span>
  | TauF t =&gt;
      TauF
        ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r <span class="kr">with</span>
          | inl x =&gt; iter_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; t)
  | VisF e k =&gt;
      VisF e
        (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
         (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r0 <span class="kr">with</span>
          | inl x =&gt; iter_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; k r)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk4"><span class="nb">destruct</span> ot <span class="kr">as</span> [ [] | | ]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  (<span class="kr">match</span>
     _observe (f i x) <span class="kr">as</span> t
     <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
   <span class="kr">with</span>
   | RetF r0 =&gt;
       <span class="kr">match</span>
         r0 <span class="kr">as</span> r1
         <span class="kr">return</span> (guarded&#39; (RetF r1) -&gt; itree&#39; E Y i)
       <span class="kr">with</span>
       | inl x =&gt; ex_falso ‚àò elim_guarded
       | inr r =&gt;
           <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r)) =&gt; RetF r
       <span class="kr">end</span>
   | TauF t =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
       TauF (iter_guarded_aux f EG i t)
   | VisF q k =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
       VisF q
         (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
          iter_guarded_aux f EG (e_nxt r) (k r))
   <span class="kr">end</span> (EG i x))
  (<span class="kr">match</span>
     _observe (f i x) <span class="kr">as</span> t
     <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
   <span class="kr">with</span>
   | RetF r0 =&gt;
       <span class="kr">match</span>
         r0 <span class="kr">as</span> r1
         <span class="kr">return</span> (guarded&#39; (RetF r1) -&gt; itree&#39; E Y i)
       <span class="kr">with</span>
       | inl x =&gt; ex_falso ‚àò elim_guarded
       | inr r =&gt;
           <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r)) =&gt; RetF r
       <span class="kr">end</span>
   | TauF t =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
       TauF (iter_guarded_aux f EG i t)
   | VisF q k =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
       VisF q
         (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
          iter_guarded_aux f EG (e_nxt r) (k r))
   <span class="kr">end</span> (EG i x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y i</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk5"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i (RetF y) (RetF y)</div></blockquote><input class="alectryon-extra-goal-toggle" id="guarded-v-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t, t0</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk6"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  (TauF
     ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
       {|
         _observe :=
           <span class="kr">match</span> r <span class="kr">with</span>
           | inl x =&gt;
               <span class="kr">match</span>
                 _observe (f i x) <span class="kr">as</span> t
                 <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
               <span class="kr">with</span>
               | RetF r0 =&gt;
                   <span class="kr">match</span>
                     r0 <span class="kr">as</span> r1
                     <span class="kr">return</span>
                       (guarded&#39; (RetF r1) -&gt;
                        itree&#39; E Y i)
                   <span class="kr">with</span>
                   | inl x0 =&gt; ex_falso ‚àò elim_guarded
                   | inr r1 =&gt;
                       <span class="kr">fun</span>
                         <span class="nv">_</span> : guarded&#39; (RetF (inr r1))
                       =&gt; RetF r1
                   <span class="kr">end</span>
               | TauF t =&gt;
                   <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
                   TauF (iter_guarded_aux f EG i t)
               | VisF q k =&gt;
                   <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
                   VisF q
                     (<span class="kr">fun</span> <span class="nv">r0</span> : e_rsp q =&gt;
                      iter_guarded_aux f EG (e_nxt r0)
                        (k r0))
               <span class="kr">end</span> (EG i x)
           | inr y =&gt; RetF y
           <span class="kr">end</span>
       |}) =&lt;&lt; t0))
  (TauF
     ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r <span class="kr">with</span>
       | inl x =&gt; iter_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; t0))</div></blockquote><input class="alectryon-extra-goal-toggle" id="guarded-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk7"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  (VisF q
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
      (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
       {|
         _observe :=
           <span class="kr">match</span> r0 <span class="kr">with</span>
           | inl x =&gt;
               <span class="kr">match</span>
                 _observe (f i x) <span class="kr">as</span> t
                 <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
               <span class="kr">with</span>
               | RetF r1 =&gt;
                   <span class="kr">match</span>
                     r1 <span class="kr">as</span> r2
                     <span class="kr">return</span>
                       (guarded&#39; (RetF r2) -&gt;
                        itree&#39; E Y i)
                   <span class="kr">with</span>
                   | inl x0 =&gt; ex_falso ‚àò elim_guarded
                   | inr r2 =&gt;
                       <span class="kr">fun</span>
                         <span class="nv">_</span> : guarded&#39; (RetF (inr r2))
                       =&gt; RetF r2
                   <span class="kr">end</span>
               | TauF t =&gt;
                   <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
                   TauF (iter_guarded_aux f EG i t)
               | VisF q k =&gt;
                   <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
                   VisF q
                     (<span class="kr">fun</span> <span class="nv">r1</span> : e_rsp q =&gt;
                      iter_guarded_aux f EG (e_nxt r1)
                        (k r1))
               <span class="kr">end</span> (EG i x)
           | inr y =&gt; RetF y
           <span class="kr">end</span>
       |}) =&lt;&lt; k r))
  (VisF q
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
      (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r0 <span class="kr">with</span>
       | inl x =&gt; iter_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; k r))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk8"><span class="mi">1</span>: <span class="nb">destruct</span> (EG i x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i (RetF y) (RetF y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk9"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  (TauF (iter_guarded_aux f EG i t0))
  (TauF (iter_guarded_aux f EG i t0))</div></blockquote><input class="alectryon-extra-goal-toggle" id="guarded-v-chka" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br></div><label class="goal-separator" for="guarded-v-chka"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  (VisF e
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
      iter_guarded_aux f EG (e_nxt r) (k r)))
  (VisF e
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
      iter_guarded_aux f EG (e_nxt r) (k r)))</div></blockquote><input class="alectryon-extra-goal-toggle" id="guarded-v-chkb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y i</span></span></span><br></div><label class="goal-separator" for="guarded-v-chkb"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i (RetF y) (RetF y)</div></blockquote><input class="alectryon-extra-goal-toggle" id="guarded-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t, t0</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br></div><label class="goal-separator" for="guarded-v-chkc"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  (TauF
     ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
       {|
         _observe :=
           <span class="kr">match</span> r <span class="kr">with</span>
           | inl x =&gt;
               <span class="kr">match</span>
                 _observe (f i x) <span class="kr">as</span> t
                 <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
               <span class="kr">with</span>
               | RetF r0 =&gt;
                   <span class="kr">match</span>
                     r0 <span class="kr">as</span> r1
                     <span class="kr">return</span>
                       (guarded&#39; (RetF r1) -&gt;
                        itree&#39; E Y i)
                   <span class="kr">with</span>
                   | inl x0 =&gt; ex_falso ‚àò elim_guarded
                   | inr r1 =&gt;
                       <span class="kr">fun</span>
                         <span class="nv">_</span> : guarded&#39; (RetF (inr r1))
                       =&gt; RetF r1
                   <span class="kr">end</span>
               | TauF t =&gt;
                   <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
                   TauF (iter_guarded_aux f EG i t)
               | VisF q k =&gt;
                   <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
                   VisF q
                     (<span class="kr">fun</span> <span class="nv">r0</span> : e_rsp q =&gt;
                      iter_guarded_aux f EG (e_nxt r0)
                        (k r0))
               <span class="kr">end</span> (EG i x)
           | inr y =&gt; RetF y
           <span class="kr">end</span>
       |}) =&lt;&lt; t0))
  (TauF
     ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r <span class="kr">with</span>
       | inl x =&gt; iter_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; t0))</div></blockquote><input class="alectryon-extra-goal-toggle" id="guarded-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br></div><label class="goal-separator" for="guarded-v-chkd"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  (VisF q
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
      (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
       {|
         _observe :=
           <span class="kr">match</span> r0 <span class="kr">with</span>
           | inl x =&gt;
               <span class="kr">match</span>
                 _observe (f i x) <span class="kr">as</span> t
                 <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
               <span class="kr">with</span>
               | RetF r1 =&gt;
                   <span class="kr">match</span>
                     r1 <span class="kr">as</span> r2
                     <span class="kr">return</span>
                       (guarded&#39; (RetF r2) -&gt;
                        itree&#39; E Y i)
                   <span class="kr">with</span>
                   | inl x0 =&gt; ex_falso ‚àò elim_guarded
                   | inr r2 =&gt;
                       <span class="kr">fun</span>
                         <span class="nv">_</span> : guarded&#39; (RetF (inr r2))
                       =&gt; RetF r2
                   <span class="kr">end</span>
               | TauF t =&gt;
                   <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
                   TauF (iter_guarded_aux f EG i t)
               | VisF q k =&gt;
                   <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
                   VisF q
                     (<span class="kr">fun</span> <span class="nv">r1</span> : e_rsp q =&gt;
                      iter_guarded_aux f EG (e_nxt r1)
                        (k r1))
               <span class="kr">end</span> (EG i x)
           | inr y =&gt; RetF y
           <span class="kr">end</span>
       |}) =&lt;&lt; k r))
  (VisF q
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
      (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r0 <span class="kr">with</span>
       | inl x =&gt; iter_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; k r))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chke"><span class="kp">all</span>: <span class="nb">econstructor</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t, t0</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_t E RY R i
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt;
            <span class="kr">match</span>
              _observe (f i x) <span class="kr">as</span> t
              <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
            <span class="kr">with</span>
            | RetF r0 =&gt;
                <span class="kr">match</span>
                  r0 <span class="kr">as</span> r1
                  <span class="kr">return</span>
                    (guarded&#39; (RetF r1) -&gt;
                     itree&#39; E Y i)
                <span class="kr">with</span>
                | inl x0 =&gt; ex_falso ‚àò elim_guarded
                | inr r1 =&gt;
                    <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r1))
                    =&gt; RetF r1
                <span class="kr">end</span>
            | TauF t =&gt;
                <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
                TauF (iter_guarded_aux f EG i t)
            | VisF q k =&gt;
                <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
                VisF q
                  (<span class="kr">fun</span> <span class="nv">r0</span> : e_rsp q =&gt;
                   iter_guarded_aux f EG (e_nxt r0)
                     (k r0))
            <span class="kr">end</span> (EG i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}) =&lt;&lt; t0)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; t0)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br></div><label class="goal-separator" for="guarded-v-chkf"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q,
it_eq_t E RY R (e_nxt r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r0 <span class="kr">with</span>
        | inl x =&gt;
            <span class="kr">match</span>
              _observe (f i x) <span class="kr">as</span> t
              <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
            <span class="kr">with</span>
            | RetF r1 =&gt;
                <span class="kr">match</span>
                  r1 <span class="kr">as</span> r2
                  <span class="kr">return</span>
                    (guarded&#39; (RetF r2) -&gt;
                     itree&#39; E Y i)
                <span class="kr">with</span>
                | inl x0 =&gt; ex_falso ‚àò elim_guarded
                | inr r2 =&gt;
                    <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r2))
                    =&gt; RetF r2
                <span class="kr">end</span>
            | TauF t =&gt;
                <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
                TauF (iter_guarded_aux f EG i t)
            | VisF q k =&gt;
                <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
                VisF q
                  (<span class="kr">fun</span> <span class="nv">r1</span> : e_rsp q =&gt;
                   iter_guarded_aux f EG (e_nxt r1)
                     (k r1))
            <span class="kr">end</span> (EG i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}) =&lt;&lt; k r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r0 <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; k r)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk10"><span class="mi">2</span>: <span class="nb">intro</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t, t0</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_t E RY R i
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt;
            <span class="kr">match</span>
              _observe (f i x) <span class="kr">as</span> t
              <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
            <span class="kr">with</span>
            | RetF r0 =&gt;
                <span class="kr">match</span>
                  r0 <span class="kr">as</span> r1
                  <span class="kr">return</span>
                    (guarded&#39; (RetF r1) -&gt;
                     itree&#39; E Y i)
                <span class="kr">with</span>
                | inl x0 =&gt; ex_falso ‚àò elim_guarded
                | inr r1 =&gt;
                    <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r1))
                    =&gt; RetF r1
                <span class="kr">end</span>
            | TauF t =&gt;
                <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
                TauF (iter_guarded_aux f EG i t)
            | VisF q k =&gt;
                <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
                VisF q
                  (<span class="kr">fun</span> <span class="nv">r0</span> : e_rsp q =&gt;
                   iter_guarded_aux f EG (e_nxt r0)
                     (k r0))
            <span class="kr">end</span> (EG i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}) =&lt;&lt; t0)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; t0)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp q</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk11"><hr></label><div class="goal-conclusion">it_eq_t E RY R (e_nxt r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt;
            <span class="kr">match</span>
              _observe (f i x) <span class="kr">as</span> t
              <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
            <span class="kr">with</span>
            | RetF r0 =&gt;
                <span class="kr">match</span>
                  r0 <span class="kr">as</span> r1
                  <span class="kr">return</span>
                    (guarded&#39; (RetF r1) -&gt;
                     itree&#39; E Y i)
                <span class="kr">with</span>
                | inl x0 =&gt; ex_falso ‚àò elim_guarded
                | inr r1 =&gt;
                    <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r1))
                    =&gt; RetF r1
                <span class="kr">end</span>
            | TauF t =&gt;
                <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
                TauF (iter_guarded_aux f EG i t)
            | VisF q k =&gt;
                <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
                VisF q
                  (<span class="kr">fun</span> <span class="nv">r0</span> : e_rsp q =&gt;
                   iter_guarded_aux f EG (e_nxt r0)
                     (k r0))
            <span class="kr">end</span> (EG i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}) =&lt;&lt; k r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; k r)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk12"><span class="kp">all</span>: <span class="nb">apply</span> (tt_t (it_eq_map E RY)); <span class="nb">cbn</span>; <span class="nb">eapply</span> it_eq_up2bind_t; <span class="nb">econstructor</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t, t0</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x1</span> <span class="nv">x2</span> : (X +·µ¢ Y) i),
eq·µ¢ (X +·µ¢ Y) i x1 x2 -&gt;
it_eq_t E RY R i
  {|
    _observe :=
      <span class="kr">match</span> x1 <span class="kr">with</span>
      | inl x =&gt;
          <span class="kr">match</span>
            _observe (f i x) <span class="kr">as</span> t
            <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
          <span class="kr">with</span>
          | RetF r0 =&gt;
              <span class="kr">match</span>
                r0 <span class="kr">as</span> r1
                <span class="kr">return</span>
                  (guarded&#39; (RetF r1) -&gt; itree&#39; E Y i)
              <span class="kr">with</span>
              | inl x0 =&gt; ex_falso ‚àò elim_guarded
              | inr r =&gt;
                  <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r)) =&gt;
                  RetF r
              <span class="kr">end</span>
          | TauF t =&gt;
              <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
              TauF (iter_guarded_aux f EG i t)
          | VisF q k =&gt;
              <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
              VisF q
                (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
                 iter_guarded_aux f EG (e_nxt r) (k r))
          <span class="kr">end</span> (EG i x)
      | inr y =&gt; RetF y
      <span class="kr">end</span>
  |}
  <span class="kr">match</span> x2 <span class="kr">with</span>
  | inl x =&gt; iter_guarded f EG i x
  | inr y =&gt; Ret&#39; y
  <span class="kr">end</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">t0</span> : itree E (X +·µ¢ Y) i),
it_eq_t E RY R i (iter_guarded_aux f EG i t0)
(t0 &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_guarded f EG i0 x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp q</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk13"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x1</span> <span class="nv">x2</span> : (X +·µ¢ Y) i),
eq·µ¢ (X +·µ¢ Y) i x1 x2 -&gt;
it_eq_t E RY R i
  {|
    _observe :=
      <span class="kr">match</span> x1 <span class="kr">with</span>
      | inl x =&gt;
          <span class="kr">match</span>
            _observe (f i x) <span class="kr">as</span> t
            <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
          <span class="kr">with</span>
          | RetF r0 =&gt;
              <span class="kr">match</span>
                r0 <span class="kr">as</span> r1
                <span class="kr">return</span>
                  (guarded&#39; (RetF r1) -&gt; itree&#39; E Y i)
              <span class="kr">with</span>
              | inl x0 =&gt; ex_falso ‚àò elim_guarded
              | inr r =&gt;
                  <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r)) =&gt;
                  RetF r
              <span class="kr">end</span>
          | TauF t =&gt;
              <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
              TauF (iter_guarded_aux f EG i t)
          | VisF q k =&gt;
              <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
              VisF q
                (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
                 iter_guarded_aux f EG (e_nxt r) (k r))
          <span class="kr">end</span> (EG i x)
      | inr y =&gt; RetF y
      <span class="kr">end</span>
  |}
  <span class="kr">match</span> x2 <span class="kr">with</span>
  | inl x =&gt; iter_guarded f EG i x
  | inr y =&gt; Ret&#39; y
  <span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">intros</span> ? ? x2 -&gt;; <span class="nb">destruct</span> x2; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Guarded iteration is a fixed point of the equation w.r.t. strong bisimilarity.</p>
<pre class="alectryon-io highlight" id="iterguardedfix"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk14"><span class="kn">Lemma</span> <span class="nf">iter_guarded_unfold</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">RY</span>} {<span class="nv">_</span> : Reflexive·µ¢ RY}
    (<span class="nv">f</span> : <span class="nb">eqn</span> Y X X) (<span class="nv">EG</span> : eqn_guarded f) {<span class="nv">i</span> <span class="nv">x</span>}
    : it_eq RY
      (iter_guarded f EG i x)
      (f i x &gt;&gt;= <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">r</span> =&gt; <span class="kr">match</span> r <span class="kr">with</span>
                         | inl x =&gt; iter_guarded f EG _ x
                         | inr y =&gt; Ret&#39; y
                         <span class="kr">end</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq RY (iter_guarded f EG i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk15"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq RY (iter_guarded f EG i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk16"><span class="nb">apply</span> it_eq_unstep; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (<span class="kr">match</span>
     _observe (f i x) <span class="kr">as</span> t
     <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
   <span class="kr">with</span>
   | RetF r0 =&gt;
       <span class="kr">match</span>
         r0 <span class="kr">as</span> r1
         <span class="kr">return</span> (guarded&#39; (RetF r1) -&gt; itree&#39; E Y i)
       <span class="kr">with</span>
       | inl x =&gt; ex_falso ‚àò elim_guarded
       | inr r =&gt;
           <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r)) =&gt; RetF r
       <span class="kr">end</span>
   | TauF t =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
       TauF (iter_guarded_aux f EG i t)
   | VisF q k =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
       VisF q
         (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
          iter_guarded_aux f EG (e_nxt r) (k r))
   <span class="kr">end</span> (EG i x))
  <span class="kr">match</span> _observe (f i x) <span class="kr">with</span>
  | RetF r =&gt;
      _observe
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; iter_guarded f EG i x
        | inr y =&gt; Ret&#39; y
        <span class="kr">end</span>
  | TauF t =&gt;
      TauF
        ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r <span class="kr">with</span>
          | inl x =&gt; iter_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; t)
  | VisF e k =&gt;
      VisF e
        (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
         (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r0 <span class="kr">with</span>
          | inl x =&gt; iter_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; k r)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk17"><span class="nb">pose</span> (p := EG i x); <span class="nb">fold</span> p; <span class="nb">unfold</span> guarded <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>EG i x</span></span><span class="hyp-type"><b>: </b><span>guarded&#39; (_observe (f i x))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (<span class="kr">match</span>
     _observe (f i x) <span class="kr">as</span> t
     <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
   <span class="kr">with</span>
   | RetF r0 =&gt;
       <span class="kr">match</span>
         r0 <span class="kr">as</span> r1
         <span class="kr">return</span> (guarded&#39; (RetF r1) -&gt; itree&#39; E Y i)
       <span class="kr">with</span>
       | inl x =&gt; ex_falso ‚àò elim_guarded
       | inr r =&gt;
           <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r)) =&gt; RetF r
       <span class="kr">end</span>
   | TauF t =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
       TauF (iter_guarded_aux f EG i t)
   | VisF q k =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
       VisF q
         (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
          iter_guarded_aux f EG (e_nxt r) (k r))
   <span class="kr">end</span> p)
  <span class="kr">match</span> _observe (f i x) <span class="kr">with</span>
  | RetF r =&gt;
      _observe
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; iter_guarded f EG i x
        | inr y =&gt; Ret&#39; y
        <span class="kr">end</span>
  | TauF t =&gt;
      TauF
        ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r <span class="kr">with</span>
          | inl x =&gt; iter_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; t)
  | VisF e k =&gt;
      VisF e
        (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
         (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r0 <span class="kr">with</span>
          | inl x =&gt; iter_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; k r)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk18"><span class="nb">pose</span> (ot := _observe (f i x)); <span class="nb">fold</span> ot <span class="kr">in</span> p |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>ot</var><span><span class="hyp-body"><b>:= </b><span>_observe (f i x)</span></span><span class="hyp-type"><b>: </b><span>itree&#39; E (X +·µ¢ Y) i</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>EG i x</span></span><span class="hyp-type"><b>: </b><span>guarded&#39; ot</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (<span class="kr">match</span>
     ot <span class="kr">as</span> t <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
   <span class="kr">with</span>
   | RetF r0 =&gt;
       <span class="kr">match</span>
         r0 <span class="kr">as</span> r1
         <span class="kr">return</span> (guarded&#39; (RetF r1) -&gt; itree&#39; E Y i)
       <span class="kr">with</span>
       | inl x =&gt; ex_falso ‚àò elim_guarded
       | inr r =&gt;
           <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r)) =&gt; RetF r
       <span class="kr">end</span>
   | TauF t =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
       TauF (iter_guarded_aux f EG i t)
   | VisF q k =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
       VisF q
         (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
          iter_guarded_aux f EG (e_nxt r) (k r))
   <span class="kr">end</span> p)
  <span class="kr">match</span> ot <span class="kr">with</span>
  | RetF r =&gt;
      _observe
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; iter_guarded f EG i x
        | inr y =&gt; Ret&#39; y
        <span class="kr">end</span>
  | TauF t =&gt;
      TauF
        ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r <span class="kr">with</span>
          | inl x =&gt; iter_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; t)
  | VisF e k =&gt;
      VisF e
        (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
         (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r0 <span class="kr">with</span>
          | inl x =&gt; iter_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; k r)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="nb">econstructor</span>; [ <span class="bp">now</span> <span class="nb">apply</span> H | | <span class="nb">intro</span> r ]; <span class="nb">apply</span> iter_guarded_aux_unfold.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>The payoff: <tt class="docutils literal">iter_guarded</tt> does not only deliver a solution to the equations,
but it also is the unique such.</p>
<pre class="alectryon-io highlight" id="iterguardeduniq"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk19"><span class="kn">Lemma</span> <span class="nf">iter_guarded_uniq</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">RY</span>} {<span class="nv">_</span> : Equivalence·µ¢ RY}
    (<span class="nv">f</span> : <span class="nb">eqn</span> Y X X) (<span class="nv">g</span> : X ‚áí·µ¢ itree E Y)
    (<span class="nv">EG</span> : eqn_guarded f)
    (<span class="nv">EQ</span> : <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">x</span>, it_eq RY
                   (g i x)
                   (bind (f i x) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">r</span> =&gt; <span class="kr">match</span> r <span class="kr">with</span>
                                          | inl x =&gt; g _ x
                                          | inr y =&gt; Ret&#39; y <span class="kr">end</span>)))
    : <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">x</span>, it_eq RY (g i x) (iter_guarded f EG i x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x) (iter_guarded f EG i x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk1a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x) (iter_guarded f EG i x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk1b"><span class="nb">unfold</span> it_eq; coinduction R CIH; <span class="nb">intros</span> i x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_bt E RY R i (g i x) (iter_guarded f EG i x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk1c"><span class="nb">etransitivity</span>; [ | <span class="nb">symmetry</span>; <span class="nb">apply</span> it_eq_t_bt, (iter_guarded_unfold f EG) ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_bt E RY R i (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk1d"><span class="nb">rewrite</span> (EQ i x); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  <span class="kr">match</span> _observe (f i x) <span class="kr">with</span>
  | RetF r =&gt;
      _observe
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; g i x
        | inr y =&gt; Ret&#39; y
        <span class="kr">end</span>
  | TauF t =&gt;
      TauF
        ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r <span class="kr">with</span>
          | inl x =&gt; g i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; t)
  | VisF e k =&gt;
      VisF e
        (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
         (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r0 <span class="kr">with</span>
          | inl x =&gt; g i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; k r)
  <span class="kr">end</span>
  <span class="kr">match</span> _observe (f i x) <span class="kr">with</span>
  | RetF r =&gt;
      _observe
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; iter_guarded f EG i x
        | inr y =&gt; Ret&#39; y
        <span class="kr">end</span>
  | TauF t =&gt;
      TauF
        ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r <span class="kr">with</span>
          | inl x =&gt; iter_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; t)
  | VisF e k =&gt;
      VisF e
        (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
         (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r0 <span class="kr">with</span>
          | inl x =&gt; iter_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; k r)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk1e"><span class="nb">pose</span> (a := (f i x).(_observe)); <span class="nb">fold</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>a</var><span><span class="hyp-body"><b>:= </b><span>_observe (f i x)</span></span><span class="hyp-type"><b>: </b><span>itree&#39; E (X +·µ¢ Y) i</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  <span class="kr">match</span> a <span class="kr">with</span>
  | RetF r =&gt;
      _observe
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; g i x
        | inr y =&gt; Ret&#39; y
        <span class="kr">end</span>
  | TauF t =&gt;
      TauF
        ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r <span class="kr">with</span>
          | inl x =&gt; g i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; t)
  | VisF e k =&gt;
      VisF e
        (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
         (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r0 <span class="kr">with</span>
          | inl x =&gt; g i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; k r)
  <span class="kr">end</span>
  <span class="kr">match</span> a <span class="kr">with</span>
  | RetF r =&gt;
      _observe
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; iter_guarded f EG i x
        | inr y =&gt; Ret&#39; y
        <span class="kr">end</span>
  | TauF t =&gt;
      TauF
        ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r <span class="kr">with</span>
          | inl x =&gt; iter_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; t)
  | VisF e k =&gt;
      VisF e
        (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
         (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r0 <span class="kr">with</span>
          | inl x =&gt; iter_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; k r)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk1f"><span class="nb">pose</span> (Ha := EG i x); <span class="nb">unfold</span> guarded <span class="kr">in</span> Ha; <span class="nb">fold</span> a <span class="kr">in</span> Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>a</var><span><span class="hyp-body"><b>:= </b><span>_observe (f i x)</span></span><span class="hyp-type"><b>: </b><span>itree&#39; E (X +·µ¢ Y) i</span></span></span></span><br><span><var>Ha</var><span><span class="hyp-body"><b>:= </b><span>EG i x</span></span><span class="hyp-type"><b>: </b><span>guarded&#39; a</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  <span class="kr">match</span> a <span class="kr">with</span>
  | RetF r =&gt;
      _observe
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; g i x
        | inr y =&gt; Ret&#39; y
        <span class="kr">end</span>
  | TauF t =&gt;
      TauF
        ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r <span class="kr">with</span>
          | inl x =&gt; g i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; t)
  | VisF e k =&gt;
      VisF e
        (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
         (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r0 <span class="kr">with</span>
          | inl x =&gt; g i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; k r)
  <span class="kr">end</span>
  <span class="kr">match</span> a <span class="kr">with</span>
  | RetF r =&gt;
      _observe
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; iter_guarded f EG i x
        | inr y =&gt; Ret&#39; y
        <span class="kr">end</span>
  | TauF t =&gt;
      TauF
        ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r <span class="kr">with</span>
          | inl x =&gt; iter_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; t)
  | VisF e k =&gt;
      VisF e
        (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
         (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r0 <span class="kr">with</span>
          | inl x =&gt; iter_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; k r)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk20"><span class="nb">destruct</span> Ha; <span class="nb">cbn</span>; <span class="nb">econstructor</span>; <span class="nb">auto</span>; [ | <span class="nb">intro</span> r ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_t E RY R i
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; t)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; t)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk21" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp e</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk21"><hr></label><div class="goal-conclusion">it_eq_t E RY R (e_nxt r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; k r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; k r)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk22"><span class="kp">all</span>: <span class="nb">change</span> (<span class="nb">subst</span> <span class="nl">?f</span> _ <span class="nl">?t</span>) <span class="kr">with</span> (bind t f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_t E RY R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp e</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk23"><hr></label><div class="goal-conclusion">it_eq_t E RY R (e_nxt r)
  (k r &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (k r &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk24"><span class="kp">all</span>: <span class="nb">eapply</span> (tt_t (it_eq_map E RY)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(it_eq_t E RY ¬∞ it_eq_t E RY) R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk25" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp e</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk25"><hr></label><div class="goal-conclusion">(it_eq_t E RY ¬∞ it_eq_t E RY) R (e_nxt r)
  (k r &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (k r &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk26"><span class="kp">all</span>: <span class="nb">refine</span> (it_eq_up2bind_t _ _ _ _ _ _ _); <span class="nb">econstructor</span>; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x1</span> <span class="nv">x2</span> : (X +·µ¢ Y) i),
eq·µ¢ (X +·µ¢ Y) i x1 x2 -&gt;
it_eq_t E RY R i
  <span class="kr">match</span> x1 <span class="kr">with</span>
  | inl x =&gt; g i x
  | inr y =&gt; Ret&#39; y
  <span class="kr">end</span>
  <span class="kr">match</span> x2 <span class="kr">with</span>
  | inl x =&gt; iter_guarded f EG i x
  | inr y =&gt; Ret&#39; y
  <span class="kr">end</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk27" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp e</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk27"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x1</span> <span class="nv">x2</span> : (X +·µ¢ Y) i),
eq·µ¢ (X +·µ¢ Y) i x1 x2 -&gt;
it_eq_t E RY R i
  <span class="kr">match</span> x1 <span class="kr">with</span>
  | inl x =&gt; g i x
  | inr y =&gt; Ret&#39; y
  <span class="kr">end</span>
  <span class="kr">match</span> x2 <span class="kr">with</span>
  | inl x =&gt; iter_guarded f EG i x
  | inr y =&gt; Ret&#39; y
  <span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">intros</span> ? ? ? &lt;-; <span class="nb">destruct</span> x1; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Furthermore, w.r.t. weak bisimilarity, we compute the same solution as what <tt class="docutils literal">iter</tt> does.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk28"><span class="kn">Lemma</span> <span class="nf">guarded_cong&#39;</span> {<span class="nv">X</span> <span class="nv">Y</span>} {<span class="nv">i</span>}
    (<span class="nv">s</span> <span class="nv">t</span> : itree&#39; E (X +·µ¢ Y) i) (<span class="nv">EQ</span> : it_eq&#39; (eq·µ¢ _) s t)
    (<span class="nv">g</span> : guarded&#39; s) : guarded&#39; t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>s, t</var><span class="hyp-type"><b>: </b><span>itree&#39; E (X +·µ¢ Y) i</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span>it_eq&#39; (eq·µ¢ (X +·µ¢ Y)) s t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>guarded&#39; s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">guarded&#39; t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk29"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>s, t</var><span class="hyp-type"><b>: </b><span>itree&#39; E (X +·µ¢ Y) i</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span>it_eq&#39; (eq·µ¢ (X +·µ¢ Y)) s t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>guarded&#39; s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">guarded&#39; t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> EQ <span class="kr">as</span> [ [] | | ]; [ dependent elimination g | <span class="nb">rewrite</span> &lt;- r_rel | | ]; <span class="nb">econstructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">guarded_cong</span> {<span class="nv">X</span> <span class="nv">Y</span>} {<span class="nv">i</span>} (<span class="nv">s</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i)
    (<span class="nv">EQ</span> : s ‚âä t) (<span class="nv">g</span> : guarded s) : guarded t
    := guarded_cong&#39; s.(_observe) t.(_observe) (it_eq_step _ _ _ EQ) g .</span></span></pre><pre class="alectryon-io highlight" id="iterguardedweak"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk2a"><span class="kn">Lemma</span> <span class="nf">iter_guarded_iter</span> {<span class="nv">X</span> <span class="nv">Y</span>}
    (<span class="nv">f</span> : <span class="nb">eqn</span> Y X X) (<span class="nv">EG</span> : eqn_guarded f) {<span class="nv">i</span> <span class="nv">x</span>}
    : iter_guarded f EG i x ‚âà iter f i x .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">iter_guarded f EG i x ‚âà iter f i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk2b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">iter_guarded f EG i x ‚âà iter f i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk2c"><span class="nb">revert</span> i x; <span class="nb">unfold</span> it_wbisim; coinduction R CIH; <span class="nb">intros</span> i x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i (iter_guarded f EG i x)
  (iter f i x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk2d"><span class="nb">eapply</span> (@fbt_bt _ _ (it_wbisim_map E (eq·µ¢ Y)) _ it_wbisim_up2eq).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(eq_clo_map ¬∞ it_wbisim_bt E (eq·µ¢ Y)) R i
  (iter_guarded f EG i x) (iter f i x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk2e"><span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">iter_guarded f EG i x ‚âä <span class="nl">?a</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk2f"><hr></label><div class="goal-conclusion"><span class="nl">?b</span> ‚âä iter f i x</div></blockquote><input class="alectryon-extra-goal-toggle" id="guarded-v-chk30" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk30"><hr></label><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i <span class="nl">?a</span> <span class="nl">?b</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk31"><span class="nb">apply</span> iter_guarded_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?b</span> ‚âä iter f i x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk32"><hr></label><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>)) <span class="nl">?b</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk33"><span class="nb">symmetry</span>; <span class="nb">apply</span> iter_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk34"><span class="nb">remember</span> (EG _ x) <span class="kr">as</span> g; <span class="nb">clear</span> Heqg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>guarded (f i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk35"><span class="nb">remember</span> (f i x) <span class="kr">as</span> t; <span class="nb">clear</span> Heqt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>guarded t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk36"><span class="nb">unfold</span> guarded <span class="kr">in</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>guarded&#39; (_observe t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk37"><span class="nb">remember</span> (_observe t) <span class="kr">as</span> ot.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>ot</var><span class="hyp-type"><b>: </b><span>itree&#39; E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>ot = _observe t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>guarded&#39; ot</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk38"><span class="nb">destruct</span> g; <span class="nb">cbn</span> ; <span class="nb">rewrite</span> &lt;- Heqot; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inr y) = _observe t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E (eq·µ¢ Y) (it_wbisim_t E (eq·µ¢ Y) R) i
  (RetF y) (RetF y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk39" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t, t0</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>TauF t0 = _observe t</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk39"><hr></label><div class="goal-conclusion">it_wbisimF E (eq·µ¢ Y) (it_wbisim_t E (eq·µ¢ Y) R) i
  (TauF
     ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r <span class="kr">with</span>
       | inl x =&gt; iter_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; t0))
  (TauF
     ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
       {|
         _observe :=
           <span class="kr">match</span> r <span class="kr">with</span>
           | inl x =&gt; TauF (iter f i x)
           | inr y =&gt; RetF y
           <span class="kr">end</span>
       |}) =&lt;&lt; t0))</div></blockquote><input class="alectryon-extra-goal-toggle" id="guarded-v-chk3a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>VisF e k = _observe t</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk3a"><hr></label><div class="goal-conclusion">it_wbisimF E (eq·µ¢ Y) (it_wbisim_t E (eq·µ¢ Y) R) i
  (VisF e
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
      (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r0 <span class="kr">with</span>
       | inl x =&gt; iter_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; k r))
  (VisF e
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
      (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
       {|
         _observe :=
           <span class="kr">match</span> r0 <span class="kr">with</span>
           | inl x =&gt; TauF (iter f i x)
           | inr y =&gt; RetF y
           <span class="kr">end</span>
       |}) =&lt;&lt; k r))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk3b"><span class="nb">econstructor</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t, t0</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>TauF t0 = _observe t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E (eq·µ¢ Y) (it_wbisim_t E (eq·µ¢ Y) R) i
  (TauF
     ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r <span class="kr">with</span>
       | inl x =&gt; iter_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; t0))
  (TauF
     ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
       {|
         _observe :=
           <span class="kr">match</span> r <span class="kr">with</span>
           | inl x =&gt; TauF (iter f i x)
           | inr y =&gt; RetF y
           <span class="kr">end</span>
       |}) =&lt;&lt; t0))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>VisF e k = _observe t</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk3c"><hr></label><div class="goal-conclusion">it_wbisimF E (eq·µ¢ Y) (it_wbisim_t E (eq·µ¢ Y) R) i
  (VisF e
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
      (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r0 <span class="kr">with</span>
       | inl x =&gt; iter_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; k r))
  (VisF e
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
      (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
       {|
         _observe :=
           <span class="kr">match</span> r0 <span class="kr">with</span>
           | inl x =&gt; TauF (iter f i x)
           | inr y =&gt; RetF y
           <span class="kr">end</span>
       |}) =&lt;&lt; k r))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk3d"><span class="kp">all</span>: <span class="nb">econstructor</span>; <span class="nb">auto</span>; <span class="nb">econstructor</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t, t0</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>TauF t0 = _observe t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_t E (eq·µ¢ Y) R i
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; t0)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}) =&lt;&lt; t0)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk3e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>VisF e k = _observe t</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp e</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk3e"><hr></label><div class="goal-conclusion">it_wbisim_t E (eq·µ¢ Y) R 
  (e_nxt r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; k r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}) =&lt;&lt; k r)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk3f"><span class="kp">all</span>: <span class="nb">eapply</span> (tt_t (it_wbisim_map E (eq·µ¢ Y))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t, t0</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>TauF t0 = _observe t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(it_wbisim_t E (eq·µ¢ Y) ¬∞ it_wbisim_t E (eq·µ¢ Y)) R i
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; t0)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}) =&lt;&lt; t0)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk40" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>VisF e k = _observe t</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp e</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk40"><hr></label><div class="goal-conclusion">(it_wbisim_t E (eq·µ¢ Y) ¬∞ it_wbisim_t E (eq·µ¢ Y)) R
  (e_nxt r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; k r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}) =&lt;&lt; k r)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk41"><span class="kp">all</span>: <span class="nb">refine</span> (it_wbisim_up2bind_t _ _ _ _ _ _ _); <span class="nb">econstructor</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t, t0</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>TauF t0 = _observe t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x1</span> <span class="nv">x2</span> : (X +·µ¢ Y) i),
eq·µ¢ (X +·µ¢ Y) i x1 x2 -&gt;
it_wbisim_t E (eq·µ¢ Y) R i
  <span class="kr">match</span> x1 <span class="kr">with</span>
  | inl x =&gt; iter_guarded f EG i x
  | inr y =&gt; Ret&#39; y
  <span class="kr">end</span>
  {|
    _observe :=
      <span class="kr">match</span> x2 <span class="kr">with</span>
      | inl x =&gt; TauF (iter f i x)
      | inr y =&gt; RetF y
      <span class="kr">end</span>
  |}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk42" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>VisF e k = _observe t</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp e</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk42"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x1</span> <span class="nv">x2</span> : (X +·µ¢ Y) i),
eq·µ¢ (X +·µ¢ Y) i x1 x2 -&gt;
it_wbisim_t E (eq·µ¢ Y) R i
  <span class="kr">match</span> x1 <span class="kr">with</span>
  | inl x =&gt; iter_guarded f EG i x
  | inr y =&gt; Ret&#39; y
  <span class="kr">end</span>
  {|
    _observe :=
      <span class="kr">match</span> x2 <span class="kr">with</span>
      | inl x =&gt; TauF (iter f i x)
      | inr y =&gt; RetF y
      <span class="kr">end</span>
  |}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk43"><span class="kp">all</span>: <span class="nb">intros</span> ? ? x2 -&gt;; <span class="nb">destruct</span> x2; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t, t0</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>TauF t0 = _observe t</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X i0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_t E (eq·µ¢ Y) R i0 
  (iter_guarded f EG i0 x0) 
  (Tau&#39; (iter f i0 x0))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk44" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>VisF e k = _observe t</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp e</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X i0</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk44"><hr></label><div class="goal-conclusion">it_wbisim_t E (eq·µ¢ Y) R i0 
  (iter_guarded f EG i0 x0) 
  (Tau&#39; (iter f i0 x0))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk45"><span class="kp">all</span>: <span class="nb">eapply</span> (tt_t (it_wbisim_map E (eq·µ¢ Y))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t, t0</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>TauF t0 = _observe t</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X i0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(it_wbisim_t E (eq·µ¢ Y) ¬∞ it_wbisim_t E (eq·µ¢ Y)) R i0
  (iter_guarded f EG i0 x0) 
  (Tau&#39; (iter f i0 x0))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk46" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>VisF e k = _observe t</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp e</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X i0</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk46"><hr></label><div class="goal-conclusion">(it_wbisim_t E (eq·µ¢ Y) ¬∞ it_wbisim_t E (eq·µ¢ Y)) R i0
  (iter_guarded f EG i0 x0) 
  (Tau&#39; (iter f i0 x0))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">cbn</span>; <span class="nb">apply</span> it_wbisim_up2eat; <span class="nb">econstructor</span>;
      [ <span class="bp">exact</span> EatRefl | <span class="bp">exact</span> (EatStep EatRefl) | <span class="nb">apply</span> CIH ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Minor technical lemmas: guardedness is proof irrelevant.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk47"><span class="kn">Lemma</span> <span class="nf">guarded&#39;_irrelevant</span> {<span class="nv">R</span> <span class="nv">X</span> <span class="nv">i</span> <span class="nv">t</span>} (<span class="nv">p</span> <span class="nv">q</span> : @guarded&#39; R X i t) : p = q .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>R, X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree&#39; E (R +·µ¢ X) i</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>guarded&#39; t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> t; dependent elimination p; dependent elimination q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk48"><span class="kn">Lemma</span> <span class="nf">guarded_irrelevant</span> {<span class="nv">R</span> <span class="nv">X</span> <span class="nv">i</span> <span class="nv">t</span>} (<span class="nv">p</span> <span class="nv">q</span> : @guarded R X i t) : p = q .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>R, X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (R +·µ¢ X) i</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>guarded t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> guarded&#39;_irrelevant.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">guarded</span>.</span></span></pre></div>
<div class="section" id="eventually-guarded-iteration">
<h1>Eventually guarded iteration</h1>
<p>For our purpose, proving the soundness of the ogs, guardedness is a bit too
restrictive: while not all equations are guarded, they all inductively lead
to a guarded one. We capture this intuition via the notion of &quot;eventually
guarded&quot; set of equations, and establish similar result to ones in the
guarded case (these properties are collectively refered to as Prop. 5 in the
paper).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">eventually_guarded</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">I</span>} {<span class="nv">E</span> : event I I}.</span></span></pre><p>A set of equations is eventually guarded if they all admit an inductive path following
its non-guarded indirections that leads to a guarded equation (Def. 34).</p>
<pre class="alectryon-io highlight" id="evguarded"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Elimination Schemes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">ev_guarded&#39;</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">e</span> : <span class="nb">eqn</span> Y X X) {<span class="nv">i</span>} : itree&#39; E (X +·µ¢ Y) i -&gt; <span class="kt">Prop</span> :=
  | GHead t : guarded&#39; t -&gt; ev_guarded&#39; e t
  | GNext x : ev_guarded&#39; e (e i x).(_observe) -&gt; ev_guarded&#39; e (RetF (inl x))
  .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Arguments</span> GHead {X Y e i t}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Arguments</span> GNext {X Y e i x}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme</span> <span class="nf">ev_guarded&#39;_ind</span> := <span class="kn">Induction for</span> ev_guarded&#39; <span class="kn">Sort</span> <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Elimination Schemes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ev_guarded</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">e</span> : <span class="nb">eqn</span> Y X X) {<span class="nv">i</span>} (<span class="nv">t</span> : itree E (X +·µ¢ Y) i)
    := ev_guarded&#39; e t.(_observe).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eqn_ev_guarded</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">e</span> : <span class="nb">eqn</span> Y X X) : <span class="kt">Type</span>
    := <span class="kr">forall</span> <span class="nv">i</span> (<span class="nv">x</span> : X i), ev_guarded e (e i x) .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">elim_ev_guarded&#39;</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">e</span> <span class="nv">i</span> <span class="nv">x</span>} (<span class="nv">g</span> : @ev_guarded&#39; X Y e i (RetF (inl x)))
            : ev_guarded&#39; e (e i x).(_observe) :=
    elim_ev_guarded&#39; (GNext g) := g .</span></span></pre><p>Given eventually guarded equations <tt class="docutils literal">e</tt>, we can build a set of guarded equations
<tt class="docutils literal">eqn_evg_unroll_guarded e</tt>: we simply map all indices to their reachable guarded
equations. Iteration over eventually guarded equations is hence defined as guarded
iteration over their guarded counterpart.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">evg_unroll&#39;</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">e</span> : <span class="nb">eqn</span> Y X X) {<span class="nv">i</span>}
    (<span class="nv">t</span> : itree&#39; E (X +·µ¢ Y) i) (<span class="nv">g</span> : ev_guarded&#39; e t) { <span class="nv">struct</span> <span class="nv">g</span> } : itree&#39; E (X +·µ¢ Y) i
    := <span class="kr">match</span> t <span class="kr">as</span> t&#39; <span class="kr">return</span> ev_guarded&#39; e t&#39; -&gt; _ <span class="kr">with</span>
       | RetF (inl x) =&gt; <span class="kr">fun</span> <span class="nv">g</span> =&gt; evg_unroll&#39; e (e _ x).(_observe) (elim_ev_guarded&#39; g)
       | RetF (inr y) =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; RetF (inr y)
       | TauF t       =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; TauF t
       | VisF q k     =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; VisF q k
       <span class="kr">end</span> g .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">evg_unroll</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">e</span> : <span class="nb">eqn</span> Y X X) {<span class="nv">i</span>}
    (<span class="nv">t</span> : itree E (X +·µ¢ Y) i) (<span class="nv">g</span> : ev_guarded e t) : itree E (X +·µ¢ Y) i
    := go (evg_unroll&#39; e t.(_observe) g) .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eqn_evg_unroll</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">e</span> : <span class="nb">eqn</span> Y X X) (<span class="nv">H</span> : eqn_ev_guarded e) : <span class="nb">eqn</span> Y X X
    := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">x</span> =&gt; evg_unroll e _ (H _ x) .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk49"><span class="kn">Lemma</span> <span class="nf">evg_unroll_guarded&#39;</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">e</span> : <span class="nb">eqn</span> Y X X) {<span class="nv">i</span>}
    (<span class="nv">t</span> : itree&#39; E (X +·µ¢ Y) i) (<span class="nv">g</span> : ev_guarded&#39; e t) : guarded&#39; (evg_unroll&#39; e t g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree&#39; E (X +·µ¢ Y) i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; e t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">guarded&#39; (evg_unroll&#39; e t g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk4a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree&#39; E (X +·µ¢ Y) i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; e t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">guarded&#39; (evg_unroll&#39; e t g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk4b"><span class="nb">induction</span> g; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree&#39; E (X +·µ¢ Y) i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>guarded&#39; t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">guarded&#39; (evg_unroll&#39; e t (GHead g))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk4c"><span class="nb">destruct</span> t <span class="kr">as</span> [ [] | | ]; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>guarded&#39; (RetF (inl x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">guarded&#39; (evg_unroll&#39; e (RetF (inl x)) (GHead g))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">dependent elimination g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">evg_unroll_guarded</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">e</span> : <span class="nb">eqn</span> Y X X) {<span class="nv">i</span>}
    (<span class="nv">t</span> : itree E (X +·µ¢ Y) i) (<span class="nv">EG</span> : ev_guarded e t) : guarded (evg_unroll e t EG)
    := evg_unroll_guarded&#39; e t.(_observe) EG.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eqn_evg_unroll_guarded</span> {<span class="nv">X</span> <span class="nv">Y</span>}
    (<span class="nv">e</span> : <span class="nb">eqn</span> Y X X) (<span class="nv">EG</span> : eqn_ev_guarded e) : eqn_guarded (eqn_evg_unroll e EG)
    := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">x</span> =&gt; evg_unroll_guarded e _ (EG _ x) .</span></span></pre><pre class="alectryon-io highlight" id="iterevguarded"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">iter_ev_guarded</span> {<span class="nv">R</span> <span class="nv">X</span>}
    (<span class="nv">e</span> : <span class="nb">eqn</span> R X X) (<span class="nv">EG</span> : eqn_ev_guarded e) : X ‚áí·µ¢ itree E R
    := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">x</span> =&gt; iter_guarded _ (eqn_evg_unroll_guarded e EG) _ x .</span></span></pre><p>Once again, we establish the expected unfolding lemma, for eventually guarded iteration.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk4d"><span class="kn">Lemma</span> <span class="nf">evg_unroll&#39;_equation</span> {<span class="nv">X</span> <span class="nv">Y</span>}
    (<span class="nv">e</span> : <span class="nb">eqn</span> Y X X) {<span class="nv">i</span>} {<span class="nv">x</span> : X i} (<span class="nv">g</span> : ev_guarded&#39; e (RetF (inl x)))
    : evg_unroll&#39; e (RetF (inl x)) g = evg_unroll&#39; e (e _ x).(_observe) (elim_ev_guarded&#39; g) .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; e (RetF (inl x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evg_unroll&#39; e (RetF (inl x)) g =
evg_unroll&#39; e (_observe (e i x)) (elim_ev_guarded&#39; g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk4e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; e (RetF (inl x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evg_unroll&#39; e (RetF (inl x)) g =
evg_unroll&#39; e (_observe (e i x)) (elim_ev_guarded&#39; g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">dependent elimination g; [ dependent elimination g | <span class="bp">reflexivity</span> ] .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk4f"><span class="kn">Lemma</span> <span class="nf">ev_guarded&#39;_irrelevant</span> {<span class="nv">R</span> <span class="nv">X</span> <span class="nv">e</span> <span class="nv">i</span> <span class="nv">t</span>}
    (<span class="nv">p</span> <span class="nv">q</span> : @ev_guarded&#39; R X e i t) : p = q .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>R, X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> X R R</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree&#39; E (R +·µ¢ X) i</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; e t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk50"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>R, X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> X R R</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree&#39; E (R +·µ¢ X) i</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; e t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk51"><span class="nb">induction</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>R, X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> X R R</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree&#39; E (R +·µ¢ X) i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>guarded&#39; t</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; e t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GHead g = q</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk52" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>R, X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> X R R</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>R i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; e (_observe (e i x))</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; e (RetF (inl x))</span></span></span><br><span><var>IHp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">q</span> : ev_guarded&#39; e (_observe (e i x)), p = q</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk52"><hr></label><div class="goal-conclusion">GNext p = q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk53">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>R, X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> X R R</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree&#39; E (R +·µ¢ X) i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>guarded&#39; t</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; e t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GHead g = q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> t <span class="kr">as</span> [ [] | | ]; [ dependent elimination g | | | ];
        dependent elimination q; <span class="nb">f_equal</span>; <span class="nb">apply</span> guarded&#39;_irrelevant.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk54">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>R, X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> X R R</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>R i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; e (_observe (e i x))</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; e (RetF (inl x))</span></span></span><br><span><var>IHp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">q</span> : ev_guarded&#39; e (_observe (e i x)), p = q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GNext p = q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">dependent elimination q; [ dependent elimination g | ]; <span class="nb">f_equal</span>; <span class="nb">apply</span> IHp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk55"><span class="kn">Lemma</span> <span class="nf">iter_evg_unfold_lem</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">RY</span>} {<span class="nv">_</span> : Equivalence·µ¢ RY}
    (<span class="nv">f</span> : <span class="nb">eqn</span> Y X X) (<span class="nv">EG</span> : eqn_ev_guarded f) {<span class="nv">i</span> <span class="nv">x1</span> <span class="nv">x2</span>}
    (<span class="nv">p</span> : (f i x1).(_observe) = RetF (inl x2))
    : it_eq RY
        (iter_ev_guarded f EG i x1)
        (iter_ev_guarded f EG i x2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>_observe (f i x1) = RetF (inl x2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq RY (iter_ev_guarded f EG i x1)
  (iter_ev_guarded f EG i x2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk56"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>_observe (f i x1) = RetF (inl x2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq RY (iter_ev_guarded f EG i x1)
  (iter_ev_guarded f EG i x2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk57"><span class="nb">unfold</span> iter_ev_guarded <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>_observe (f i x1) = RetF (inl x2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq RY
  (iter_guarded (eqn_evg_unroll f EG)
     (eqn_evg_unroll_guarded f EG) i x1)
  (iter_ev_guarded f EG i x2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk58"><span class="nb">etransitivity</span>; [ <span class="nb">apply</span> iter_guarded_unfold | ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>_observe (f i x1) = RetF (inl x2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq RY
  (eqn_evg_unroll f EG i x1 &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt;
        iter_guarded (eqn_evg_unroll f EG)
          (eqn_evg_unroll_guarded f EG) i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>)) (iter_ev_guarded f EG i x2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk59"><span class="nb">change</span> (iter_guarded _ _ <span class="nl">?i</span> <span class="nl">?x</span>) <span class="kr">with</span> (iter_ev_guarded f EG i x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>_observe (f i x1) = RetF (inl x2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq RY
  (eqn_evg_unroll f EG i x1 &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>)) (iter_ev_guarded f EG i x2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk5a"><span class="nb">unfold</span> eqn_evg_unroll; <span class="nb">remember</span> (EG i x1) <span class="kr">as</span> q; <span class="nb">clear</span> Heqq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>_observe (f i x1) = RetF (inl x2)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ev_guarded f (f i x1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq RY
  (evg_unroll f (f i x1) q &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>)) (iter_ev_guarded f EG i x2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk5b"><span class="nb">apply</span> it_eq_unstep; <span class="nb">unfold</span> evg_unroll; <span class="nb">cbn</span> -[iter_ev_guarded].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>_observe (f i x1) = RetF (inl x2)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ev_guarded f (f i x1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  <span class="kr">match</span> evg_unroll&#39; f (_observe (f i x1)) q <span class="kr">with</span>
  | RetF r =&gt;
      _observe
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; iter_ev_guarded f EG i x
        | inr y =&gt; Ret&#39; y
        <span class="kr">end</span>
  | TauF t =&gt;
      TauF
        ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r <span class="kr">with</span>
          | inl x =&gt; iter_ev_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; t)
  | VisF e k =&gt;
      VisF e
        (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
         (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r0 <span class="kr">with</span>
          | inl x =&gt; iter_ev_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; k r)
  <span class="kr">end</span> (observe (iter_ev_guarded f EG i x2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk5c"><span class="nb">unfold</span> ev_guarded <span class="kr">in</span> q; <span class="nb">revert</span> q; <span class="nb">rewrite</span> p; <span class="nb">clear</span> p; <span class="nb">intro</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (RetF (inl x2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  <span class="kr">match</span> evg_unroll&#39; f (RetF (inl x2)) q <span class="kr">with</span>
  | RetF r =&gt;
      _observe
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; iter_ev_guarded f EG i x
        | inr y =&gt; Ret&#39; y
        <span class="kr">end</span>
  | TauF t =&gt;
      TauF
        ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r <span class="kr">with</span>
          | inl x =&gt; iter_ev_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; t)
  | VisF e k =&gt;
      VisF e
        (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
         (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r0 <span class="kr">with</span>
          | inl x =&gt; iter_ev_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; k r)
  <span class="kr">end</span> (observe (iter_ev_guarded f EG i x2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk5d"><span class="nb">rewrite</span> evg_unroll&#39;_equation, (ev_guarded&#39;_irrelevant (elim_ev_guarded&#39; q) (EG _ x2)); <span class="nb">clear</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  <span class="kr">match</span>
    evg_unroll&#39; f (_observe (f i x2)) (EG i x2)
  <span class="kr">with</span>
  | RetF r =&gt;
      _observe
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; iter_ev_guarded f EG i x
        | inr y =&gt; Ret&#39; y
        <span class="kr">end</span>
  | TauF t =&gt;
      TauF
        ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r <span class="kr">with</span>
          | inl x =&gt; iter_ev_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; t)
  | VisF e k =&gt;
      VisF e
        (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
         (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r0 <span class="kr">with</span>
          | inl x =&gt; iter_ev_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; k r)
  <span class="kr">end</span> (observe (iter_ev_guarded f EG i x2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk5e"><span class="nb">change</span> (it_eqF E RY (it_eq RY) i _ (observe <span class="nl">?a</span>))
      <span class="kr">with</span> (it_eq_map E RY (it_eq RY) i
              (evg_unroll f (f i x2) (EG i x2) &gt;&gt;= <span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
                   <span class="kr">match</span> r <span class="kr">with</span>
                   | inl x =&gt; iter_ev_guarded f EG i0 x
                   | inr y =&gt; Ret&#39; y
                   <span class="kr">end</span>)
              a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_map E RY (it_eq RY) i
  (evg_unroll f (f i x2) (EG i x2) &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i0 x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>)) (iter_ev_guarded f EG i x2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> it_eq_step; <span class="nb">symmetry</span>; <span class="bp">exact</span> (iter_guarded_unfold _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><pre class="alectryon-io highlight" id="iterevguardedfix"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk5f"><span class="kn">Lemma</span> <span class="nf">iter_evg_unfold</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">RY</span>} {<span class="nv">_</span> : Equivalence·µ¢ RY}
    (<span class="nv">f</span> : <span class="nb">eqn</span> Y X X) (<span class="nv">EG</span> : eqn_ev_guarded f) {<span class="nv">i</span> <span class="nv">x</span>}
    : it_eq RY
        (iter_ev_guarded f EG i x)
        (f i x &gt;&gt;= <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">r</span> =&gt; <span class="kr">match</span> r <span class="kr">with</span>
                           | inl x =&gt; iter_ev_guarded f EG _ x
                           | inr y =&gt; Ret&#39; y
                           <span class="kr">end</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq RY (iter_ev_guarded f EG i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk60"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq RY (iter_ev_guarded f EG i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk61"><span class="nb">apply</span> it_eq_unstep; <span class="nb">cbn</span> -[iter_ev_guarded].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (observe (iter_ev_guarded f EG i x))
  <span class="kr">match</span> _observe (f i x) <span class="kr">with</span>
  | RetF r =&gt;
      _observe
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; iter_ev_guarded f EG i x
        | inr y =&gt; Ret&#39; y
        <span class="kr">end</span>
  | TauF t =&gt;
      TauF
        ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r <span class="kr">with</span>
          | inl x =&gt; iter_ev_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; t)
  | VisF e k =&gt;
      VisF e
        (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
         (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r0 <span class="kr">with</span>
          | inl x =&gt; iter_ev_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; k r)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk62"><span class="nb">remember</span> (EG i x) <span class="kr">as</span> g; <span class="nb">clear</span> Heqg; <span class="nb">unfold</span> ev_guarded <span class="kr">in</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (observe (iter_ev_guarded f EG i x))
  <span class="kr">match</span> _observe (f i x) <span class="kr">with</span>
  | RetF r =&gt;
      _observe
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; iter_ev_guarded f EG i x
        | inr y =&gt; Ret&#39; y
        <span class="kr">end</span>
  | TauF t =&gt;
      TauF
        ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r <span class="kr">with</span>
          | inl x =&gt; iter_ev_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; t)
  | VisF e k =&gt;
      VisF e
        (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
         (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r0 <span class="kr">with</span>
          | inl x =&gt; iter_ev_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; k r)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk63"><span class="nb">remember</span> (_observe (f i x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span>itree&#39; E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>i0 = _observe (f i x)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f i0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (observe (iter_ev_guarded f EG i x))
  <span class="kr">match</span> i0 <span class="kr">with</span>
  | RetF r =&gt;
      _observe
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; iter_ev_guarded f EG i x
        | inr y =&gt; Ret&#39; y
        <span class="kr">end</span>
  | TauF t =&gt;
      TauF
        ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r <span class="kr">with</span>
          | inl x =&gt; iter_ev_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; t)
  | VisF e k =&gt;
      VisF e
        (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
         (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
          <span class="kr">match</span> r0 <span class="kr">with</span>
          | inl x =&gt; iter_ev_guarded f EG i x
          | inr y =&gt; Ret&#39; y
          <span class="kr">end</span>) =&lt;&lt; k r)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk64"><span class="nb">destruct</span> i0 <span class="kr">as</span> [ [] | | ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe (f i x)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (RetF (inl x0))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (observe (iter_ev_guarded f EG i x))
  (_observe (iter_ev_guarded f EG i x0))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk65" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y i</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>RetF (inr y) = _observe (f i x)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (RetF (inr y))</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk65"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (observe (iter_ev_guarded f EG i x))
  (_observe (Ret&#39; y))</div></blockquote><input class="alectryon-extra-goal-toggle" id="guarded-v-chk66" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>TauF t = _observe (f i x)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (TauF t)</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk66"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (observe (iter_ev_guarded f EG i x))
  (TauF
     ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r <span class="kr">with</span>
       | inl x =&gt; iter_ev_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="guarded-v-chk67" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>VisF q k = _observe (f i x)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (VisF q k)</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk67"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (observe (iter_ev_guarded f EG i x))
  (VisF q
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
      (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r0 <span class="kr">with</span>
       | inl x =&gt; iter_ev_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; k r))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk68"><span class="nb">apply</span> (it_eq_step _ (iter_ev_guarded f EG i x) (iter_ev_guarded f EG i x0)), iter_evg_unfold_lem; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y i</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>RetF (inr y) = _observe (f i x)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (RetF (inr y))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (observe (iter_ev_guarded f EG i x))
  (_observe (Ret&#39; y))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk69" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>TauF t = _observe (f i x)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (TauF t)</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk69"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (observe (iter_ev_guarded f EG i x))
  (TauF
     ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r <span class="kr">with</span>
       | inl x =&gt; iter_ev_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="guarded-v-chk6a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>VisF q k = _observe (f i x)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (VisF q k)</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk6a"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (observe (iter_ev_guarded f EG i x))
  (VisF q
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
      (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r0 <span class="kr">with</span>
       | inl x =&gt; iter_ev_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; k r))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk6b"><span class="kp">all</span>: <span class="nb">clear</span> g; <span class="nb">cbn</span>; <span class="nb">unfold</span> eqn_evg_unroll_guarded <span class="nb">at</span> <span class="mi">3</span>, evg_unroll_guarded.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y i</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>RetF (inr y) = _observe (f i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (<span class="kr">match</span>
     evg_unroll&#39; f (_observe (f i x)) (EG i x) <span class="kr">as</span> t
     <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
   <span class="kr">with</span>
   | RetF r0 =&gt;
       <span class="kr">match</span>
         r0 <span class="kr">as</span> r1
         <span class="kr">return</span> (guarded&#39; (RetF r1) -&gt; itree&#39; E Y i)
       <span class="kr">with</span>
       | inl x =&gt; ex_falso ‚àò elim_guarded
       | inr r =&gt;
           <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r)) =&gt; RetF r
       <span class="kr">end</span>
   | TauF t =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
       TauF
         (iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) i t)
   | VisF q k =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
       VisF q
         (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
          iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) 
            (e_nxt r) (k r))
   <span class="kr">end</span>
     (evg_unroll_guarded&#39; f 
        (_observe (f i x)) 
        (EG i x))) (RetF y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk6c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>TauF t = _observe (f i x)</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk6c"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (<span class="kr">match</span>
     evg_unroll&#39; f (_observe (f i x)) (EG i x) <span class="kr">as</span> t
     <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
   <span class="kr">with</span>
   | RetF r0 =&gt;
       <span class="kr">match</span>
         r0 <span class="kr">as</span> r1
         <span class="kr">return</span> (guarded&#39; (RetF r1) -&gt; itree&#39; E Y i)
       <span class="kr">with</span>
       | inl x =&gt; ex_falso ‚àò elim_guarded
       | inr r =&gt;
           <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r)) =&gt; RetF r
       <span class="kr">end</span>
   | TauF t =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
       TauF
         (iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) i t)
   | VisF q k =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
       VisF q
         (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
          iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) 
            (e_nxt r) (k r))
   <span class="kr">end</span>
     (evg_unroll_guarded&#39; f 
        (_observe (f i x)) 
        (EG i x)))
  (TauF
     ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r <span class="kr">with</span>
       | inl x =&gt; iter_ev_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="guarded-v-chk6d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>VisF q k = _observe (f i x)</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk6d"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (<span class="kr">match</span>
     evg_unroll&#39; f (_observe (f i x)) (EG i x) <span class="kr">as</span> t
     <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
   <span class="kr">with</span>
   | RetF r0 =&gt;
       <span class="kr">match</span>
         r0 <span class="kr">as</span> r1
         <span class="kr">return</span> (guarded&#39; (RetF r1) -&gt; itree&#39; E Y i)
       <span class="kr">with</span>
       | inl x =&gt; ex_falso ‚àò elim_guarded
       | inr r =&gt;
           <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r)) =&gt; RetF r
       <span class="kr">end</span>
   | TauF t =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
       TauF
         (iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) i t)
   | VisF q k =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
       VisF q
         (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
          iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) 
            (e_nxt r) (k r))
   <span class="kr">end</span>
     (evg_unroll_guarded&#39; f 
        (_observe (f i x)) 
        (EG i x)))
  (VisF q
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
      (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r0 <span class="kr">with</span>
       | inl x =&gt; iter_ev_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; k r))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk6e"><span class="kp">all</span>: <span class="nb">remember</span> (EG i x) <span class="kr">as</span> g&#39;; <span class="nb">clear</span> Heqg&#39;; <span class="nb">unfold</span> ev_guarded <span class="kr">in</span> g&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y i</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>RetF (inr y) = _observe (f i x)</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (<span class="kr">match</span>
     evg_unroll&#39; f (_observe (f i x)) g&#39; <span class="kr">as</span> t
     <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
   <span class="kr">with</span>
   | RetF r0 =&gt;
       <span class="kr">match</span>
         r0 <span class="kr">as</span> r1
         <span class="kr">return</span> (guarded&#39; (RetF r1) -&gt; itree&#39; E Y i)
       <span class="kr">with</span>
       | inl x =&gt; ex_falso ‚àò elim_guarded
       | inr r =&gt;
           <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r)) =&gt; RetF r
       <span class="kr">end</span>
   | TauF t =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
       TauF
         (iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) i t)
   | VisF q k =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
       VisF q
         (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
          iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) 
            (e_nxt r) (k r))
   <span class="kr">end</span> (evg_unroll_guarded&#39; f (_observe (f i x)) g&#39;))
  (RetF y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk6f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>TauF t = _observe (f i x)</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x))</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk6f"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (<span class="kr">match</span>
     evg_unroll&#39; f (_observe (f i x)) g&#39; <span class="kr">as</span> t
     <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
   <span class="kr">with</span>
   | RetF r0 =&gt;
       <span class="kr">match</span>
         r0 <span class="kr">as</span> r1
         <span class="kr">return</span> (guarded&#39; (RetF r1) -&gt; itree&#39; E Y i)
       <span class="kr">with</span>
       | inl x =&gt; ex_falso ‚àò elim_guarded
       | inr r =&gt;
           <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r)) =&gt; RetF r
       <span class="kr">end</span>
   | TauF t =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
       TauF
         (iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) i t)
   | VisF q k =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
       VisF q
         (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
          iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) 
            (e_nxt r) (k r))
   <span class="kr">end</span> (evg_unroll_guarded&#39; f (_observe (f i x)) g&#39;))
  (TauF
     ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r <span class="kr">with</span>
       | inl x =&gt; iter_ev_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="guarded-v-chk70" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>VisF q k = _observe (f i x)</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x))</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk70"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (<span class="kr">match</span>
     evg_unroll&#39; f (_observe (f i x)) g&#39; <span class="kr">as</span> t
     <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
   <span class="kr">with</span>
   | RetF r0 =&gt;
       <span class="kr">match</span>
         r0 <span class="kr">as</span> r1
         <span class="kr">return</span> (guarded&#39; (RetF r1) -&gt; itree&#39; E Y i)
       <span class="kr">with</span>
       | inl x =&gt; ex_falso ‚àò elim_guarded
       | inr r =&gt;
           <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r)) =&gt; RetF r
       <span class="kr">end</span>
   | TauF t =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
       TauF
         (iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) i t)
   | VisF q k =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
       VisF q
         (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
          iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) 
            (e_nxt r) (k r))
   <span class="kr">end</span> (evg_unroll_guarded&#39; f (_observe (f i x)) g&#39;))
  (VisF q
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
      (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r0 <span class="kr">with</span>
       | inl x =&gt; iter_ev_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; k r))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk71"><span class="kp">all</span>: <span class="nb">revert</span> g&#39;; <span class="nb">rewrite</span> &lt;- Heqi0; <span class="nb">intros</span> g&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y i</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>RetF (inr y) = _observe (f i x)</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (RetF (inr y))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (<span class="kr">match</span>
     evg_unroll&#39; f (RetF (inr y)) g&#39; <span class="kr">as</span> t
     <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
   <span class="kr">with</span>
   | RetF r0 =&gt;
       <span class="kr">match</span>
         r0 <span class="kr">as</span> r1
         <span class="kr">return</span> (guarded&#39; (RetF r1) -&gt; itree&#39; E Y i)
       <span class="kr">with</span>
       | inl x =&gt; ex_falso ‚àò elim_guarded
       | inr r =&gt;
           <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r)) =&gt; RetF r
       <span class="kr">end</span>
   | TauF t =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
       TauF
         (iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) i t)
   | VisF q k =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
       VisF q
         (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
          iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) 
            (e_nxt r) (k r))
   <span class="kr">end</span> (evg_unroll_guarded&#39; f (RetF (inr y)) g&#39;))
  (RetF y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk72" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>TauF t = _observe (f i x)</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (TauF t)</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk72"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (<span class="kr">match</span>
     evg_unroll&#39; f (TauF t) g&#39; <span class="kr">as</span> t
     <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
   <span class="kr">with</span>
   | RetF r0 =&gt;
       <span class="kr">match</span>
         r0 <span class="kr">as</span> r1
         <span class="kr">return</span> (guarded&#39; (RetF r1) -&gt; itree&#39; E Y i)
       <span class="kr">with</span>
       | inl x =&gt; ex_falso ‚àò elim_guarded
       | inr r =&gt;
           <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r)) =&gt; RetF r
       <span class="kr">end</span>
   | TauF t =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
       TauF
         (iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) i t)
   | VisF q k =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
       VisF q
         (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
          iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) 
            (e_nxt r) (k r))
   <span class="kr">end</span> (evg_unroll_guarded&#39; f (TauF t) g&#39;))
  (TauF
     ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r <span class="kr">with</span>
       | inl x =&gt; iter_ev_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="guarded-v-chk73" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>VisF q k = _observe (f i x)</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (VisF q k)</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk73"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq RY) i
  (<span class="kr">match</span>
     evg_unroll&#39; f (VisF q k) g&#39; <span class="kr">as</span> t
     <span class="kr">return</span> (guarded&#39; t -&gt; itree&#39; E Y i)
   <span class="kr">with</span>
   | RetF r0 =&gt;
       <span class="kr">match</span>
         r0 <span class="kr">as</span> r1
         <span class="kr">return</span> (guarded&#39; (RetF r1) -&gt; itree&#39; E Y i)
       <span class="kr">with</span>
       | inl x =&gt; ex_falso ‚àò elim_guarded
       | inr r =&gt;
           <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (RetF (inr r)) =&gt; RetF r
       <span class="kr">end</span>
   | TauF t =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (TauF t) =&gt;
       TauF
         (iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) i t)
   | VisF q k =&gt;
       <span class="kr">fun</span> <span class="nv">_</span> : guarded&#39; (VisF q k) =&gt;
       VisF q
         (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
          iter_guarded_aux 
            (eqn_evg_unroll f EG)
            (eqn_evg_unroll_guarded f EG) 
            (e_nxt r) (k r))
   <span class="kr">end</span> (evg_unroll_guarded&#39; f (VisF q k) g&#39;))
  (VisF q
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp q =&gt;
      (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r0 <span class="kr">with</span>
       | inl x =&gt; iter_ev_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; k r))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk74"><span class="kp">all</span>: dependent elimination g&#39;; <span class="nb">econstructor</span>; <span class="nb">auto</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>TauF t = _observe (f i x)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>guarded&#39; (TauF t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq RY
  (iter_guarded_aux (eqn_evg_unroll f EG)
     (eqn_evg_unroll_guarded f EG) i t)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; t)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk75" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>Heqi0</var><span class="hyp-type"><b>: </b><span>VisF q k = _observe (f i x)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>guarded&#39; (VisF q k)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp q</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk75"><hr></label><div class="goal-conclusion">it_eq RY
  (iter_guarded_aux (eqn_evg_unroll f EG)
     (eqn_evg_unroll_guarded f EG) 
     (e_nxt r) (k r))
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; k r)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">apply</span> iter_guarded_aux_unfold.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Uniqueness still holds.</p>
<pre class="alectryon-io highlight" id="iterevguardeduniq"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk76"><span class="kn">Lemma</span> <span class="nf">iter_evg_uniq</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">RY</span>} {<span class="nv">_</span> : Equivalence·µ¢ RY}
    (<span class="nv">f</span> : <span class="nb">eqn</span> Y X X) (<span class="nv">g</span> : X ‚áí·µ¢ itree E Y)
    (<span class="nv">EG</span> : eqn_ev_guarded f)
    (<span class="nv">EQ</span> : <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">x</span>,
        it_eq RY
          (g i x)
          (bind (f i x) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">r</span> =&gt; <span class="kr">match</span> r <span class="kr">with</span>
                                 | inl x =&gt; g _ x
                                 | inr y =&gt; Ret&#39; y <span class="kr">end</span>)))
    : <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">x</span>, it_eq RY (g i x) (iter_ev_guarded f EG i x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x) (iter_ev_guarded f EG i x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk77"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x) (iter_ev_guarded f EG i x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk78"><span class="nb">unfold</span> it_eq; coinduction R CIH; <span class="nb">intros</span> i x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_bt E RY R i (g i x) (iter_ev_guarded f EG i x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk79"><span class="nb">rewrite</span> iter_evg_unfold, (EQ i x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_bt E RY R i
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk7a"><span class="nb">remember</span> (EG i x) <span class="kr">as</span> Ha; <span class="nb">clear</span> HeqHa; <span class="nb">unfold</span> ev_guarded <span class="kr">in</span> Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_bt E RY R i
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk7b"><span class="nb">remember</span> (f i x) <span class="kr">as</span> t; <span class="nb">clear</span> Heqt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_bt E RY R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk7c"><span class="nb">remember</span> (_observe t) <span class="kr">as</span> ot.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i), it_eq_t E RY R i (g i x) (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>ot</var><span class="hyp-type"><b>: </b><span>itree&#39; E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>ot = _observe t</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f ot</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_bt E RY R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk7d"><span class="nb">revert</span> t Heqot; <span class="nb">induction</span> Ha; <span class="nb">intros</span> t&#39; Heqot.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq_t E RY R i (g i x)
  (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree&#39; E (X +·µ¢ Y) i</span></span></span><br><span><var>g0</var><span class="hyp-type"><b>: </b><span>guarded&#39; t</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>t = _observe t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_bt E RY R i
  (t&#39; &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t&#39; &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk7e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq_t E RY R i (g i x)
  (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_eq_bt E RY R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe t&#39;</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk7e"><hr></label><div class="goal-conclusion">it_eq_bt E RY R i
  (t&#39; &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t&#39; &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk7f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq_t E RY R i (g i x)
  (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree&#39; E (X +·µ¢ Y) i</span></span></span><br><span><var>g0</var><span class="hyp-type"><b>: </b><span>guarded&#39; t</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>t = _observe t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_bt E RY R i
  (t&#39; &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t&#39; &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk80">dependent elimination g0; <span class="nb">cbn</span>; <span class="nb">rewrite</span> &lt;- Heqot; <span class="nb">econstructor</span>; <span class="nb">auto</span>; [ | <span class="nb">intro</span> r ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq_t E RY R i (g i x)
  (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t0, t'</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>TauF t0 = _observe t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_t E RY R i
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; t0)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; t0)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk81" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq_t E RY R i (g i x)
  (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>VisF e k = _observe t&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp e</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk81"><hr></label><div class="goal-conclusion">it_eq_t E RY R (e_nxt r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; k r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; k r)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk82"><span class="kp">all</span>: <span class="nb">eapply</span> (tt_t (it_eq_map E RY)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq_t E RY R i (g i x)
  (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t0, t'</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>TauF t0 = _observe t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(it_eq_t E RY ¬∞ it_eq_t E RY) R i
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; t0)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; t0)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk83" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq_t E RY R i (g i x)
  (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>VisF e k = _observe t&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp e</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk83"><hr></label><div class="goal-conclusion">(it_eq_t E RY ¬∞ it_eq_t E RY) R 
  (e_nxt r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; k r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; k r)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk84"><span class="kp">all</span>: <span class="nb">refine</span> (it_eq_up2bind_t _ _ _ _ _ _ _); <span class="nb">econstructor</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq_t E RY R i (g i x)
  (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t0, t'</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>TauF t0 = _observe t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x1</span> <span class="nv">x2</span> : (X +·µ¢ Y) i),
eq·µ¢ (X +·µ¢ Y) i x1 x2 -&gt;
it_eq_t E RY R i
  <span class="kr">match</span> x1 <span class="kr">with</span>
  | inl x =&gt; g i x
  | inr y =&gt; Ret&#39; y
  <span class="kr">end</span>
  <span class="kr">match</span> x2 <span class="kr">with</span>
  | inl x =&gt; iter_ev_guarded f EG i x
  | inr y =&gt; Ret&#39; y
  <span class="kr">end</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk85" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq_t E RY R i (g i x)
  (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>VisF e k = _observe t&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp e</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk85"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x1</span> <span class="nv">x2</span> : (X +·µ¢ Y) i),
eq·µ¢ (X +·µ¢ Y) i x1 x2 -&gt;
it_eq_t E RY R i
  <span class="kr">match</span> x1 <span class="kr">with</span>
  | inl x =&gt; g i x
  | inr y =&gt; Ret&#39; y
  <span class="kr">end</span>
  <span class="kr">match</span> x2 <span class="kr">with</span>
  | inl x =&gt; iter_ev_guarded f EG i x
  | inr y =&gt; Ret&#39; y
  <span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">intros</span> ? ? x2 -&gt;; <span class="nb">destruct</span> x2; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk86">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq_t E RY R i (g i x)
  (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_eq_bt E RY R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_bt E RY R i
  (t&#39; &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t&#39; &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk87"><span class="nb">cbn</span>; <span class="nb">rewrite</span> &lt;- Heqot.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq_t E RY R i (g i x)
  (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_eq_bt E RY R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i 
  (_observe (g i x0))
  (_observe (iter_ev_guarded f EG i x0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk88"><span class="nb">change</span> (it_eqF E RY <span class="nl">?R</span> i (_observe <span class="nl">?a</span>) (_observe <span class="nl">?b</span>)) <span class="kr">with</span> (it_eq_map E RY R i a b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq_t E RY R i (g i x)
  (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_eq_bt E RY R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_map E RY (it_eq_t E RY R) i 
  (g i x0) (iter_ev_guarded f EG i x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk89"><span class="nb">rewrite</span> iter_evg_unfold, (EQ i x0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : I, relation (Y x)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RY</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X ‚áí·µ¢ itree E Y</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq RY (g i x)
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i0</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i0) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x0 =&gt; g i0 x0
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_eq_t E RY R i (g i x)
  (iter_ev_guarded f EG i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_eq_bt E RY R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_map E RY (it_eq_t E RY R) i
  (f i x0 &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; g i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (f i x0 &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHHa; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>And w.r.t. weak bisimilarity, we still perform the same computation.</p>
<pre class="alectryon-io highlight" id="iterevguardedweak"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk8a"><span class="kn">Lemma</span> <span class="nf">iter_evg_iter</span> {<span class="nv">X</span> <span class="nv">Y</span>}
    (<span class="nv">f</span> : <span class="nb">eqn</span> Y X X) (<span class="nv">EG</span> : eqn_ev_guarded f) {<span class="nv">i</span> <span class="nv">x</span>}
    : iter_ev_guarded f EG i x ‚âà iter f i x .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">iter_ev_guarded f EG i x ‚âà iter f i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk8b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">iter_ev_guarded f EG i x ‚âà iter f i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk8c"><span class="nb">revert</span> i x; <span class="nb">unfold</span> it_wbisim; coinduction R CIH; <span class="nb">intros</span> i x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x)
  (iter f i x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk8d"><span class="nb">eapply</span> (@fbt_bt _ _ (it_wbisim_map E (eq·µ¢ Y)) _ it_wbisim_up2eq).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(eq_clo_map ¬∞ it_wbisim_bt E (eq·µ¢ Y)) R i
  (iter_ev_guarded f EG i x) (iter f i x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk8e"><span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">iter_ev_guarded f EG i x ‚âä <span class="nl">?a</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk8f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk8f"><hr></label><div class="goal-conclusion"><span class="nl">?b</span> ‚âä iter f i x</div></blockquote><input class="alectryon-extra-goal-toggle" id="guarded-v-chk90" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk90"><hr></label><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i <span class="nl">?a</span> <span class="nl">?b</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk91"><span class="nb">apply</span> iter_evg_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?b</span> ‚âä iter f i x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk92" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk92"><hr></label><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>)) <span class="nl">?b</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk93"><span class="nb">symmetry</span>; <span class="nb">apply</span> iter_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk94"><span class="nb">remember</span> (EG _ x) <span class="kr">as</span> g; <span class="nb">clear</span> Heqg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded f (f i x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (f i x &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk95"><span class="nb">remember</span> (f i x) <span class="kr">as</span> t; <span class="nb">clear</span> Heqt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded f t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk96"><span class="nb">unfold</span> ev_guarded <span class="kr">in</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk97"><span class="nb">remember</span> (_observe t) <span class="kr">as</span> ot.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>ot</var><span class="hyp-type"><b>: </b><span>itree&#39; E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>ot = _observe t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f ot</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk98"><span class="nb">revert</span> t Heqot; <span class="nb">induction</span> g; <span class="nb">intros</span> u Heqot.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree&#39; E (X +·µ¢ Y) i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>guarded&#39; t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>t = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (u &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (u &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk99" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_ev_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_wbisim_bt E (eq·µ¢ Y) R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe u</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk99"><hr></label><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (u &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (u &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk9a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree&#39; E (X +·µ¢ Y) i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>guarded&#39; t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>t = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (u &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (u &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk9b"><span class="nb">destruct</span> g; <span class="nb">cbn</span> ; <span class="nb">rewrite</span> &lt;- Heqot; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inr y) = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E (eq·µ¢ Y) (it_wbisim_t E (eq·µ¢ Y) R) i
  (RetF y) (RetF y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk9c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_ev_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t, u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>TauF t = _observe u</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk9c"><hr></label><div class="goal-conclusion">it_wbisimF E (eq·µ¢ Y) (it_wbisim_t E (eq·µ¢ Y) R) i
  (TauF
     ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r <span class="kr">with</span>
       | inl x =&gt; iter_ev_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; t))
  (TauF
     ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
       {|
         _observe :=
           <span class="kr">match</span> r <span class="kr">with</span>
           | inl x =&gt; TauF (iter f i x)
           | inr y =&gt; RetF y
           <span class="kr">end</span>
       |}) =&lt;&lt; t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="guarded-v-chk9d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_ev_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>VisF e k = _observe u</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk9d"><hr></label><div class="goal-conclusion">it_wbisimF E (eq·µ¢ Y) (it_wbisim_t E (eq·µ¢ Y) R) i
  (VisF e
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
      (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r0 <span class="kr">with</span>
       | inl x =&gt; iter_ev_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; k r))
  (VisF e
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
      (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
       {|
         _observe :=
           <span class="kr">match</span> r0 <span class="kr">with</span>
           | inl x =&gt; TauF (iter f i x)
           | inr y =&gt; RetF y
           <span class="kr">end</span>
       |}) =&lt;&lt; k r))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chk9e"><span class="nb">econstructor</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t, u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>TauF t = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E (eq·µ¢ Y) (it_wbisim_t E (eq·µ¢ Y) R) i
  (TauF
     ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r <span class="kr">with</span>
       | inl x =&gt; iter_ev_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; t))
  (TauF
     ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
       {|
         _observe :=
           <span class="kr">match</span> r <span class="kr">with</span>
           | inl x =&gt; TauF (iter f i x)
           | inr y =&gt; RetF y
           <span class="kr">end</span>
       |}) =&lt;&lt; t))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chk9f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_ev_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>VisF e k = _observe u</span></span></span><br></div><label class="goal-separator" for="guarded-v-chk9f"><hr></label><div class="goal-conclusion">it_wbisimF E (eq·µ¢ Y) (it_wbisim_t E (eq·µ¢ Y) R) i
  (VisF e
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
      (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
       <span class="kr">match</span> r0 <span class="kr">with</span>
       | inl x =&gt; iter_ev_guarded f EG i x
       | inr y =&gt; Ret&#39; y
       <span class="kr">end</span>) =&lt;&lt; k r))
  (VisF e
     (<span class="kr">fun</span> <span class="nv">r</span> : e_rsp e =&gt;
      (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r0</span> : (X +·µ¢ Y) i) =&gt;
       {|
         _observe :=
           <span class="kr">match</span> r0 <span class="kr">with</span>
           | inl x =&gt; TauF (iter f i x)
           | inr y =&gt; RetF y
           <span class="kr">end</span>
       |}) =&lt;&lt; k r))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chka0"><span class="kp">all</span>: <span class="nb">econstructor</span>; <span class="nb">auto</span>; <span class="nb">econstructor</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t, u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>TauF t = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_t E (eq·µ¢ Y) R i
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; t)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}) =&lt;&lt; t)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chka1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_ev_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>VisF e k = _observe u</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp e</span></span></span><br></div><label class="goal-separator" for="guarded-v-chka1"><hr></label><div class="goal-conclusion">it_wbisim_t E (eq·µ¢ Y) R 
  (e_nxt r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; k r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}) =&lt;&lt; k r)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chka2"><span class="kp">all</span>: <span class="nb">eapply</span> (tt_t (it_wbisim_map E (eq·µ¢ Y))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t, u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>TauF t = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(it_wbisim_t E (eq·µ¢ Y) ¬∞ it_wbisim_t E (eq·µ¢ Y)) R i
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; t)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}) =&lt;&lt; t)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chka3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_ev_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>VisF e k = _observe u</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp e</span></span></span><br></div><label class="goal-separator" for="guarded-v-chka3"><hr></label><div class="goal-conclusion">(it_wbisim_t E (eq·µ¢ Y) ¬∞ it_wbisim_t E (eq·µ¢ Y)) R
  (e_nxt r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>) =&lt;&lt; k r)
  ((<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}) =&lt;&lt; k r)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chka4"><span class="kp">all</span>: <span class="nb">refine</span> (it_wbisim_up2bind_t _ _ _ _ _ _ _); <span class="nb">econstructor</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t, u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>TauF t = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x1</span> <span class="nv">x2</span> : (X +·µ¢ Y) i),
eq·µ¢ (X +·µ¢ Y) i x1 x2 -&gt;
it_wbisim_t E (eq·µ¢ Y) R i
  <span class="kr">match</span> x1 <span class="kr">with</span>
  | inl x =&gt; iter_ev_guarded f EG i x
  | inr y =&gt; Ret&#39; y
  <span class="kr">end</span>
  {|
    _observe :=
      <span class="kr">match</span> x2 <span class="kr">with</span>
      | inl x =&gt; TauF (iter f i x)
      | inr y =&gt; RetF y
      <span class="kr">end</span>
  |}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chka5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_ev_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>VisF e k = _observe u</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp e</span></span></span><br></div><label class="goal-separator" for="guarded-v-chka5"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x1</span> <span class="nv">x2</span> : (X +·µ¢ Y) i),
eq·µ¢ (X +·µ¢ Y) i x1 x2 -&gt;
it_wbisim_t E (eq·µ¢ Y) R i
  <span class="kr">match</span> x1 <span class="kr">with</span>
  | inl x =&gt; iter_ev_guarded f EG i x
  | inr y =&gt; Ret&#39; y
  <span class="kr">end</span>
  {|
    _observe :=
      <span class="kr">match</span> x2 <span class="kr">with</span>
      | inl x =&gt; TauF (iter f i x)
      | inr y =&gt; RetF y
      <span class="kr">end</span>
  |}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chka6"><span class="kp">all</span>: <span class="nb">intros</span> ? ? x2 -&gt;; <span class="nb">destruct</span> x2; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t, u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>TauF t = _observe u</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X i0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_t E (eq·µ¢ Y) R i0
  (iter_ev_guarded f EG i0 x0) (Tau&#39; (iter f i0 x0))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chka7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_ev_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>VisF e k = _observe u</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp e</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X i0</span></span></span><br></div><label class="goal-separator" for="guarded-v-chka7"><hr></label><div class="goal-conclusion">it_wbisim_t E (eq·µ¢ Y) R i0
  (iter_ev_guarded f EG i0 x0) 
  (Tau&#39; (iter f i0 x0))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chka8"><span class="kp">all</span>: <span class="nb">eapply</span> (tt_t (it_wbisim_map E (eq·µ¢ Y))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>t, u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>TauF t = _observe u</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X i0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(it_wbisim_t E (eq·µ¢ Y) ¬∞ it_wbisim_t E (eq·µ¢ Y)) R i0
  (iter_ev_guarded f EG i0 x0) (Tau&#39; (iter f i0 x0))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chka9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_ev_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp e, itree E (X +·µ¢ Y) (e_nxt r)</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>VisF e k = _observe u</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>e_rsp e</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X i0</span></span></span><br></div><label class="goal-separator" for="guarded-v-chka9"><hr></label><div class="goal-conclusion">(it_wbisim_t E (eq·µ¢ Y) ¬∞ it_wbisim_t E (eq·µ¢ Y)) R i0
  (iter_ev_guarded f EG i0 x0) 
  (Tau&#39; (iter f i0 x0))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">cbn</span>; <span class="nb">apply</span> it_wbisim_up2eat; <span class="nb">econstructor</span>; [ <span class="bp">exact</span> EatRefl | <span class="bp">exact</span> (EatStep EatRefl) | <span class="nb">apply</span> CIH ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chkaa">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_wbisim_bt E (eq·µ¢ Y) R i
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_ev_guarded f EG i x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
{|
_observe :=
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; TauF (iter f i x)
| inr y =&gt; RetF y
<span class="kr">end</span>
|}))</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (u &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (u &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chkab"><span class="nb">cbn</span>; <span class="nb">rewrite</span> &lt;- Heqot.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_wbisim_bt E (eq·µ¢ Y) R i
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_ev_guarded f EG i x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
{|
_observe :=
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; TauF (iter f i x)
| inr y =&gt; RetF y
<span class="kr">end</span>
|}))</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E (eq·µ¢ Y) (it_wbisim_t E (eq·µ¢ Y) R) i
  (_observe (iter_ev_guarded f EG i x0))
  (TauF (iter f i x0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chkac"><span class="nb">change</span> (it_wbisimF E (eq·µ¢ Y) _ _ (_observe <span class="nl">?a</span>) (TauF <span class="nl">?b</span>)) <span class="kr">with</span>
        (it_wbisim_bt E (eq·µ¢ Y) R _ a (Tau&#39; b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_wbisim_bt E (eq·µ¢ Y) R i
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_ev_guarded f EG i x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
{|
_observe :=
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; TauF (iter f i x)
| inr y =&gt; RetF y
<span class="kr">end</span>
|}))</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x0)
  (Tau&#39; (iter f i x0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chkad"><span class="nb">eapply</span> (@fbt_bt _ _ (it_wbisim_map E _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_wbisim_bt E (eq·µ¢ Y) R i
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_ev_guarded f EG i x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
{|
_observe :=
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; TauF (iter f i x)
| inr y =&gt; RetF y
<span class="kr">end</span>
|}))</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?f</span> &lt;= it_wbisim_t E (eq·µ¢ Y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chkae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_ev_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_wbisim_bt E (eq·µ¢ Y) R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe u</span></span></span><br></div><label class="goal-separator" for="guarded-v-chkae"><hr></label><div class="goal-conclusion">(<span class="nl">?f</span> ¬∞ it_wbisim_bt E (eq·µ¢ Y)) R i
  (iter_ev_guarded f EG i x0) 
  (Tau&#39; (iter f i x0))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chkaf"><span class="nb">refine</span> (it_wbisim_up2eat).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_wbisim_bt E (eq·µ¢ Y) R i
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_ev_guarded f EG i x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
{|
_observe :=
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; TauF (iter f i x)
| inr y =&gt; RetF y
<span class="kr">end</span>
|}))</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(eat_clo_map ¬∞ it_wbisim_bt E (eq·µ¢ Y)) R i
  (iter_ev_guarded f EG i x0) (Tau&#39; (iter f i x0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chkb0"><span class="nb">econstructor</span>; [ <span class="bp">exact</span> EatRefl | <span class="bp">exact</span> (EatStep EatRefl) | ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_wbisim_bt E (eq·µ¢ Y) R i
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_ev_guarded f EG i x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
{|
_observe :=
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; TauF (iter f i x)
| inr y =&gt; RetF y
<span class="kr">end</span>
|}))</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x0)
  (iter f i x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chkb1"><span class="nb">eapply</span> (@fbt_bt _ _ (it_wbisim_map E _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_wbisim_bt E (eq·µ¢ Y) R i
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_ev_guarded f EG i x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
{|
_observe :=
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; TauF (iter f i x)
| inr y =&gt; RetF y
<span class="kr">end</span>
|}))</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?f</span> &lt;= it_wbisim_t E (eq·µ¢ Y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chkb2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_ev_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_wbisim_bt E (eq·µ¢ Y) R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe u</span></span></span><br></div><label class="goal-separator" for="guarded-v-chkb2"><hr></label><div class="goal-conclusion">(<span class="nl">?f</span> ¬∞ it_wbisim_bt E (eq·µ¢ Y)) R i
  (iter_ev_guarded f EG i x0) 
  (iter f i x0)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chkb3"><span class="nb">apply</span> (it_wbisim_up2eq).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_wbisim_bt E (eq·µ¢ Y) R i
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_ev_guarded f EG i x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
{|
_observe :=
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; TauF (iter f i x)
| inr y =&gt; RetF y
<span class="kr">end</span>
|}))</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(eq_clo_map ¬∞ it_wbisim_bt E (eq·µ¢ Y)) R i
  (iter_ev_guarded f EG i x0) (iter f i x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chkb4"><span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_wbisim_bt E (eq·µ¢ Y) R i
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_ev_guarded f EG i x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
{|
_observe :=
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; TauF (iter f i x)
| inr y =&gt; RetF y
<span class="kr">end</span>
|}))</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">iter_ev_guarded f EG i x0 ‚âä <span class="nl">?a</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chkb5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_ev_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_wbisim_bt E (eq·µ¢ Y) R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe u</span></span></span><br></div><label class="goal-separator" for="guarded-v-chkb5"><hr></label><div class="goal-conclusion"><span class="nl">?b</span> ‚âä iter f i x0</div></blockquote><input class="alectryon-extra-goal-toggle" id="guarded-v-chkb6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_ev_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_wbisim_bt E (eq·µ¢ Y) R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe u</span></span></span><br></div><label class="goal-separator" for="guarded-v-chkb6"><hr></label><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i <span class="nl">?a</span> <span class="nl">?b</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chkb7"><span class="nb">apply</span> iter_evg_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_wbisim_bt E (eq·µ¢ Y) R i
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_ev_guarded f EG i x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
{|
_observe :=
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; TauF (iter f i x)
| inr y =&gt; RetF y
<span class="kr">end</span>
|}))</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?b</span> ‚âä iter f i x0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="guarded-v-chkb8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i
  (iter_ev_guarded f EG i x) 
  (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_wbisim_bt E (eq·µ¢ Y) R i
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (t &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe u</span></span></span><br></div><label class="goal-separator" for="guarded-v-chkb8"><hr></label><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (f i x0 &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>)) <span class="nl">?b</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="guarded-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="guarded-v-chkb9"><span class="nb">symmetry</span>; <span class="nb">apply</span> iter_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="nb">eqn</span> Y X X</span></span></span><br><span><var>EG</var><span class="hyp-type"><b>: </b><span>eqn_ev_guarded f</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : I) (<span class="nv">x</span> : X i),
it_wbisim_t E (eq·µ¢ Y) R i (iter_ev_guarded f EG i x) (iter f i x)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, x0</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ev_guarded&#39; f (_observe (f i x0))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">t</span> : itree E (X +·µ¢ Y) i,
_observe (f i x0) = _observe t -&gt;
it_wbisim_bt E (eq·µ¢ Y) R i
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; iter_ev_guarded f EG i x
| inr y =&gt; Ret&#39; y
<span class="kr">end</span>))
(t &gt;&gt;=
(<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
{|
_observe :=
<span class="kr">match</span> r <span class="kr">with</span>
| inl x =&gt; TauF (iter f i x)
| inr y =&gt; RetF y
<span class="kr">end</span>
|}))</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>itree E (X +·µ¢ Y) i</span></span></span><br><span><var>Heqot</var><span class="hyp-type"><b>: </b><span>RetF (inl x0) = _observe u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E (eq·µ¢ Y) R i
  (f i x0 &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl x =&gt; iter_ev_guarded f EG i x
    | inr y =&gt; Ret&#39; y
    <span class="kr">end</span>))
  (f i x0 &gt;&gt;=
   (<span class="kr">fun</span> (<span class="nv">i</span> : I) (<span class="nv">r</span> : (X +·µ¢ Y) i) =&gt;
    {|
      _observe :=
        <span class="kr">match</span> r <span class="kr">with</span>
        | inl x =&gt; TauF (iter f i x)
        | inr y =&gt; RetF y
        <span class="kr">end</span>
    |}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> IHg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">eventually_guarded</span>.</span></span></pre></div>
</div>
</div></body>
</html>
