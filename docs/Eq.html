<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>Interaction Trees: (weak) bisimilarity</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-windowed"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="interaction-trees-weak-bisimilarity">
<h1 class="title">Interaction Trees: (weak) bisimilarity</h1>

<p>As is usual with coinductive types in Coq, <code class="highlight coq"><span class="n">eq</span></code> is not the <em>right</em> notion of equivalence.
We define through this file strong and weak bisimilarity of itrees, and their
generalization lifting value relations.</p>
<p>These coinductive relations are implemented using Damien Pous's <a class="reference external" href="https://github.com/damien-pous/coinduction">coinduction</a> library.
Indeed, our previous coinductive definitions like <tt class="docutils literal">itree</tt> where implemented using Coq's
native coinductive types, but their manipulation is a bit brittle due to the syntactic
guardedness criterion. For the case of bisimilarity---which is also a coinductive types---
we have better tools. Indeed bisimilarity is a <tt class="docutils literal">Prop</tt>-valued relation, and since Coq's
<tt class="docutils literal">Prop</tt> universe feature impredicativity, the set of <tt class="docutils literal">Prop</tt>-valued relation enjoy the
structure of a complete lattice. This enables us to derive greatest fixpoints ourselves,
using an off-the-shelf fixpoint construction on complete lattices.</p>
<p>The version of <a class="reference external" href="https://github.com/damien-pous/coinduction">coinduction</a> we use constructs greatest fixpoints using the &quot;companion&quot;
construction, enjoying good properties w.r.t. up-to techniques: we will be able to
discharge bisimilarity proof by providing less than a full-blown bisimulation relation.
Since the time of writing, the library has been upgraded to an even more practical
construction based on tower-induction, but we have not yet ported our code to this
upgraded API.</p>
<div class="section" id="strong-bisimilarity">
<h1>Strong bisimilarity</h1>
<p>Strong bisimilarity is very useful as it is the natural notion of extensional
equality for coinductive types. Here we introduce <tt class="docutils literal">it_eq RR</tt>, a slight generalization
where the relation on the leaves of the tree does not need to be equality on the type
of the leaves, but only a proof of the relation <tt class="docutils literal">RR</tt>, which might be heterogeneous. This
might be described as the relational lifting of itree arising from strong bisimilarity.</p>
<p>We will write <tt class="docutils literal">‚âÖ</tt> for strong bisimilarity, aka <tt class="docutils literal">it_eq (eq·µ¢ _)</tt>.</p>
<p>First, we define a monotone endofunction <tt class="docutils literal">it_eq_map</tt> over indexed relations between
trees. Strong bisimilarity is then defined the greatest fixpoint of <tt class="docutils literal">it_eq_map RR</tt>,
for a fixed value relation <tt class="docutils literal">RR</tt>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">it_eqF</span> {<span class="nv">I</span>} <span class="nv">E</span>
  {<span class="nv">X1</span> <span class="nv">X2</span>} (<span class="nv">RX</span> : rel·µ¢ X1 X2) {<span class="nv">Y1</span> <span class="nv">Y2</span>} (<span class="nv">RR</span> : rel·µ¢ Y1 Y2)
  (<span class="nv">i</span> : I) : itreeF E X1 Y1 i -&gt; itreeF E X2 Y2 i -&gt; <span class="kt">Prop</span> :=
| EqRet {r1 r2} (r_rel : RX i r1 r2)                : it_eqF _ _ _ _ (RetF r1)   (RetF r2)
| EqTau {t1 t2} (t_rel : RR i t1 t2)                : it_eqF _ _ _ _ (TauF t1)   (TauF t2)
| EqVis {q k1 k2} (k_rel : <span class="kr">forall</span> <span class="nv">r</span>, RR _ (k1 r) (k2 r)) : it_eqF _ _ _ _ (VisF q k1) (VisF q k2)
.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">it_eqF_mon</span> {<span class="nv">I</span> <span class="nv">E</span> <span class="nv">X1</span> <span class="nv">X2</span> <span class="nv">RX</span> <span class="nv">Y1</span> <span class="nv">Y2</span>}
  : Proper (leq ==&gt; leq) (@it_eqF I E X1 X2 RX Y1 Y2) :=
  it_eqF_mon _ _ H1 _ _ _ (EqRet r_rel) := EqRet r_rel ;
  it_eqF_mon _ _ H1 _ _ _ (EqTau t_rel) := EqTau (H1 _ _ _ t_rel) ;
  it_eqF_mon _ _ H1 _ _ _ (EqVis k_rel) := EqVis (<span class="kr">fun</span> <span class="nv">r</span> =&gt; H1 _ _ _ (k_rel r)) .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Existing Instance</span> <span class="nf">it_eqF_mon</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">it_eq_map</span> {<span class="nv">I</span>} <span class="nv">E</span> {<span class="nv">X1</span> <span class="nv">X2</span>} <span class="nv">RX</span> : mon (rel·µ¢ (@itree I E X1) (@itree I E X2)) := {|
  body RR i x y := it_eqF E RX RR i (observe x) (observe y) ;
  Hbody _ _ H _ _ _ r := it_eqF_mon _ _ H _ _ _ r ;
|}.</span></span></pre><p>Now the definition of the bisimilarity itself as greatest fixed point. See Def. 10.</p>
<pre class="alectryon-io highlight" id="sbisim"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">it_eq</span> {<span class="nv">I</span> <span class="nv">E</span> <span class="nv">X1</span> <span class="nv">X2</span>} <span class="nv">RX</span> [i] := gfp (@it_eq_map I E X1 X2 RX) i.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="nf">it_eq_t</span> E RX := (t (it_eq_map E RX)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="nf">it_eq_bt</span> E RX := (bt (it_eq_map E RX)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="nf">it_eq_T</span> E RX := (T (it_eq_map E RX)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;a ‚âä b&quot;</span> := (it_eq (eq·µ¢ _) a b) (<span class="kn">at level</span> <span class="mi">20</span>).</span></span></pre><div class="section" id="basic-properties">
<h2>Basic properties</h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">it_eq&#39;</span> {<span class="nv">I</span> <span class="nv">E</span> <span class="nv">X1</span> <span class="nv">X2</span>} <span class="nv">RX</span> [i]
  := @it_eqF I E X1 X2 RX (itree E X1) (itree E X2) (it_eq RX) i.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">it_eq_step</span> {<span class="nv">I</span> <span class="nv">E</span> <span class="nv">X1</span> <span class="nv">X2</span> <span class="nv">RX</span>} : it_eq RX &lt;= @it_eq_map I E X1 X2 RX (it_eq RX)
  := <span class="kr">fun</span> <span class="nv">i</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; proj1 (gfp_fp (it_eq_map E RX) i x y) .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">it_eq_unstep</span> {<span class="nv">I</span> <span class="nv">E</span> <span class="nv">X1</span> <span class="nv">X2</span> <span class="nv">RX</span>} : @it_eq_map I E X1 X2 RX (it_eq RX) &lt;= it_eq RX
  := <span class="kr">fun</span> <span class="nv">i</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; proj2 (gfp_fp (it_eq_map E RX) i x y) .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk0">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">it_eqbt_mon</span> {<span class="nv">I</span>} {<span class="nv">E</span> : event I I} {<span class="nv">X1</span> <span class="nv">X2</span>} {<span class="nv">RX</span> : rel·µ¢ X1 X2}
  : Proper (leq ==&gt; leq) (it_eq_bt E RX).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (leq ==&gt; leq) (it_eq_bt E RX)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (leq ==&gt; leq) (it_eq_bt E RX)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk2"><span class="nb">intros</span> R1 R2 H i x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>R1, R2</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X1) (itree E X2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>R1 &lt;= R2</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_bt E RX R1 i x y &lt;= it_eq_bt E RX R2 i x y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk3"><span class="nb">apply</span> it_eqF_mon.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>R1, R2</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X1) (itree E X2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>R1 &lt;= R2</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_t E RX R1 &lt;= it_eq_t E RX R2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk4"><span class="nb">rewrite</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>R1, R2</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X1) (itree E X2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>R1 &lt;= R2</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_t E RX R2 &lt;= it_eq_t E RX R2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Justifying strong bisimulations up-to reflexivity, symmetry, and transitivity.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">it_eq_facts</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">I</span>} {<span class="nv">E</span> : event I I} {<span class="nv">X</span> : psh I} {<span class="nv">RX</span> : rel·µ¢ X X}.</span></span></pre><p>Reversal, symmetry.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk5"><span class="kn">Lemma</span> <span class="nf">it_eqF_sym</span> `{Symmetric·µ¢ RX} {Y1 Y2} {RR : rel·µ¢ Y1 Y2} : rev·µ¢ (it_eqF E RX RR) &lt;= it_eqF E RX (rev·µ¢ RR).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Symmetric·µ¢0</var><span class="hyp-type"><b>: </b><span>Symmetric·µ¢ RX</span></span></span><br><span><var>Y1, Y2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y1 Y2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev·µ¢ (it_eqF E RX RR) &lt;= it_eqF E RX (rev·µ¢ RR)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? ? ? p; <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="nb">destruct</span> p; <span class="kp">try</span> <span class="nb">symmetry in</span> r_rel; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk6"><span class="kn">Lemma</span> <span class="nf">it_eq_up2sym</span> `{Symmetric·µ¢ RX} : converse·µ¢ &lt;= it_eq_t E RX.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Symmetric·µ¢0</var><span class="hyp-type"><b>: </b><span>Symmetric·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">converse·µ¢ &lt;= it_eq_t E RX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Symmetric·µ¢0</var><span class="hyp-type"><b>: </b><span>Symmetric·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">converse·µ¢ &lt;= it_eq_t E RX</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> leq_t; <span class="kp">repeat</span> <span class="nb">intro</span>; <span class="bp">now</span> <span class="nb">apply</span> it_eqF_sym.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk8">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">it_eq_t_sym</span> `{Symmetric·µ¢ RX} {RR} : Symmetric·µ¢ (it_eq_t E RX RR).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Symmetric·µ¢0</var><span class="hyp-type"><b>: </b><span>Symmetric·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Symmetric·µ¢ (it_eq_t E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Symmetric·µ¢0</var><span class="hyp-type"><b>: </b><span>Symmetric·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Symmetric·µ¢ (it_eq_t E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> build_symmetric, (ft_t it_eq_up2sym RR).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Reflexivity.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chka"><span class="kn">Lemma</span> <span class="nf">it_eqF_rfl</span> `{Reflexive·µ¢ RX} {Y} : eq·µ¢ _ &lt;= it_eqF E RX (eq·µ¢ Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Reflexive·µ¢0</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RX</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eq·µ¢ (itreeF E X Y) &lt;= it_eqF E RX (eq·µ¢ Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Reflexive·µ¢0</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RX</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eq·µ¢ (itreeF E X Y) &lt;= it_eqF E RX (eq·µ¢ Y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? [] ? &lt;-; <span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chkc"><span class="kn">Lemma</span> <span class="nf">it_eq_up2rfl</span> `{Reflexive·µ¢ RX} : const (eq·µ¢ _) &lt;= it_eq_t E RX.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Reflexive·µ¢0</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">const (eq·µ¢ (itree E X)) &lt;= it_eq_t E RX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Reflexive·µ¢0</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">const (eq·µ¢ (itree E X)) &lt;= it_eq_t E RX</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> leq_t; <span class="kp">repeat</span> <span class="nb">intro</span>; <span class="bp">now</span> <span class="nb">apply</span> (it_eqF_rfl), (<span class="nb">f_equal</span> observe).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chke">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">it_eq_t_refl</span> `{Reflexive·µ¢ RX} {RR} : Reflexive·µ¢ (it_eq_t E RX RR).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Reflexive·µ¢0</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflexive·µ¢ (it_eq_t E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chkf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Reflexive·µ¢0</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflexive·µ¢ (it_eq_t E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> build_reflexive, (ft_t it_eq_up2rfl RR).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Concatenation, transitivity.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk10"><span class="kn">Lemma</span> <span class="nf">it_eqF_tra</span> `{Transitive·µ¢ RX} {Y1 Y2 Y3} {R1 : rel·µ¢ Y1 Y2}  {R2 : rel·µ¢ Y2 Y3}
        : (it_eqF E RX R1 ‚®ü it_eqF E RX R2) &lt;= it_eqF E RX (R1 ‚®ü R2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>Y1, Y2, Y3</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>R1</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y1 Y2</span></span></span><br><span><var>R2</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y2 Y3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(it_eqF E RX R1 ‚®ü it_eqF E RX R2) &lt;=
it_eqF E RX (R1 ‚®ü R2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>Y1, Y2, Y3</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>R1</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y1 Y2</span></span></span><br><span><var>R2</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y2 Y3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(it_eqF E RX R1 ‚®ü it_eqF E RX R2) &lt;=
it_eqF E RX (R1 ‚®ü R2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk12"><span class="nb">intros</span> ? ? ? [ ? [ u v ] ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>Y1, Y2, Y3</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>R1</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y1 Y2</span></span></span><br><span><var>R2</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y2 Y3</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>itreeF E X Y1 a</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>itreeF E X Y3 a</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itreeF E X Y2 a</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R1 a a0 x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R2 a x a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RX (R1 ‚®ü R2) a a0 a1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk13"><span class="nb">destruct</span> u; <span class="nb">dependent destruction</span> v; simpl_depind; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>Y1, Y2, Y3</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>R1</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y1 Y2</span></span></span><br><span><var>R2</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y2 Y3</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>r3, r1, r2</var><span class="hyp-type"><b>: </b><span>X a</span></span></span><br><span><var>r_rel</var><span class="hyp-type"><b>: </b><span>RX a r1 r2</span></span></span><br><span><var>r_rel0</var><span class="hyp-type"><b>: </b><span>RX a r2 r3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RX (R1 ‚®ü R2) a (RetF r1) (RetF r3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">econstructor</span>; <span class="nb">transitivity</span> r2; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk14"><span class="kn">Lemma</span> <span class="nf">it_eq_up2tra</span> `{Transitive·µ¢ RX} : square·µ¢ &lt;= it_eq_t E RX.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">square·µ¢ &lt;= it_eq_t E RX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk15"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">square·µ¢ &lt;= it_eq_t E RX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk16"><span class="nb">apply</span> leq_t; <span class="nb">intros</span> ? ? ? ? []; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a1, a2, x</var><span class="hyp-type"><b>: </b><span>itree E X a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>it_eqF E RX a a0 (observe a1) (observe x) /\
it_eqF E RX a a0 (observe x) (observe a2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RX (a ‚®ü a) a0 (observe a1) (observe a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> it_eqF_tra; <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk17">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">it_eq_t_trans</span> `{Transitive·µ¢ RX} {RR} : Transitive·µ¢ (it_eq_t E RX RR).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Transitive·µ¢ (it_eq_t E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk18"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Transitive·µ¢ (it_eq_t E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> build_transitive, (ft_t it_eq_up2tra RR).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>We can now package the previous properties as equivalences.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk19">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">it_eq_t_equiv</span> `{Equivalence·µ¢ RX} {RR}
    : Equivalence·µ¢ (it_eq_t E RX RR).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equivalence·µ¢ (it_eq_t E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk1a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equivalence·µ¢ (it_eq_t E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">econstructor</span>; <span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk1b">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">it_eq_bt_equiv</span> `{Equivalence·µ¢ RX} {RR}
    : Equivalence·µ¢ (it_eq_bt E RX RR).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equivalence·µ¢ (it_eq_bt E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equivalence·µ¢ (it_eq_bt E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk1d"><span class="nb">apply</span> build_equivalence.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eq·µ¢ (itree E X) &lt;= it_eq_bt E RX RR</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="eq-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><label class="goal-separator" for="eq-v-chk1e"><hr></label><div class="goal-conclusion">converse·µ¢ (it_eq_bt E RX RR) &lt;= it_eq_bt E RX RR</div></blockquote><input class="alectryon-extra-goal-toggle" id="eq-v-chk1f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><label class="goal-separator" for="eq-v-chk1f"><hr></label><div class="goal-conclusion">square·µ¢ (it_eq_bt E RX RR) &lt;= it_eq_bt E RX RR</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk20">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eq·µ¢ (itree E X) &lt;= it_eq_bt E RX RR</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (fbt_bt it_eq_up2rfl).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk21">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">converse·µ¢ (it_eq_bt E RX RR) &lt;= it_eq_bt E RX RR</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (fbt_bt it_eq_up2sym).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk22">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">square·µ¢ (it_eq_bt E RX RR) &lt;= it_eq_bt E RX RR</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (fbt_bt it_eq_up2tra).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk23">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">it_eq_t_bt</span> {<span class="nv">RR</span>} : Subrelation·µ¢ (it_eq RX) (it_eq_bt E RX RR).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Subrelation·µ¢ (it_eq RX) (it_eq_bt E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk24"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Subrelation·µ¢ (it_eq RX) (it_eq_bt E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk25"><span class="nb">intros</span> ? ? ? r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>it_eq RX x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_bt E RX RR i x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk26"><span class="nb">apply</span> (gfp_fp (it_eq_map E RX)) <span class="kr">in</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>it_eq_map E RX (gfp (it_eq_map E RX)) i x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_bt E RX RR i x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk27"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (gfp (it_eq_map E RX)) i (observe x)
  (observe y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RX (it_eq_t E RX RR) i (observe x)
  (observe y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk28"><span class="nb">dependent induction</span> r; simpl_depind; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>t_rel</var><span class="hyp-type"><b>: </b><span>gfp (it_eq_map E RX) i t1 t2</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RX (it_eq_t E RX RR) i (TauF t1) (TauF t2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="eq-v-chk29" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k1, k2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : e_rsp q, itree E X (e_nxt x)</span></span></span><br><span><var>k_rel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q,
gfp (it_eq_map E RX) (e_nxt r) (k1 r) (k2 r)</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br></div><label class="goal-separator" for="eq-v-chk29"><hr></label><div class="goal-conclusion">it_eqF E RX (it_eq_t E RX RR) i 
  (VisF q k1) (VisF q k2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk2a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>t_rel</var><span class="hyp-type"><b>: </b><span>gfp (it_eq_map E RX) i t1 t2</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RX (it_eq_t E RX RR) i (TauF t1) (TauF t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">econstructor</span>; <span class="nb">apply</span> (gfp_t (it_eq_map E RX)); <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k1, k2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : e_rsp q, itree E X (e_nxt x)</span></span></span><br><span><var>k_rel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q,
gfp (it_eq_map E RX) (e_nxt r) (k1 r) (k2 r)</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RX (it_eq_t E RX RR) i (VisF q k1)
  (VisF q k2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">econstructor</span>; <span class="nb">intro</span> r; <span class="nb">apply</span> (gfp_t (it_eq_map E RX)); <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">it_eq_facts</span>.</span></span></pre></div>
</div>
<div class="section" id="weak-bisimilarity">
<h1>Weak bisimilarity</h1>
<p>Similarly to strong bisimilarity, we define weak bisimilarity as the greatest fixpoint
of a monotone endofunction. A characteristic of weak bisimilarity is that it can
&quot;skip over&quot; a finite number of <tt class="docutils literal">Tau</tt> nodes on either side. As such, the endofunction
will allow &quot;eating&quot; a number of <tt class="docutils literal">Tau</tt> nodes before a synchronization step.</p>
<p>Note that <tt class="docutils literal">itree</tt> encodes deterministic LTSs, hence we do not need to worry about
allowing to strip off <tt class="docutils literal">Tau</tt> nodes after the synchronization as well.</p>
<p>We will start by defining an inductive &quot;eating&quot; relation, such that intuitively
<tt class="docutils literal">it_eat X Y := ‚àÉ n, X = Tau^n(Y)</tt>.</p>
<pre class="alectryon-io highlight" id="eat"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">it_eat</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">I</span> : <span class="kt">Type</span>} {<span class="nv">E</span> : event I I} {<span class="nv">R</span> : psh I}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">it_eat</span> <span class="nv">i</span> : itree&#39; E R i -&gt; itree&#39; E R i -&gt; <span class="kt">Prop</span> :=
  | EatRefl {t} : it_eat i t t
  | EatStep {t1 t2} : it_eat _ (observe t1) t2 -&gt; it_eat i (TauF t1) t2
  .</span></span></pre><p>Let's prove some easy properties.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk2c">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">eat_trans</span> : Transitive·µ¢ it_eat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Transitive·µ¢ it_eat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk2d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Transitive·µ¢ it_eat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> i x y z r1 r2; <span class="nb">dependent induction</span> r1; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">eat_cmp</span> : (rev·µ¢ it_eat ‚®ü it_eat) &lt;= (it_eat ‚à®·µ¢ rev·µ¢ it_eat) :=
    eat_cmp i&#39; x&#39; y&#39; (ex_intro _ z&#39; (conj p&#39; q&#39;)) := _eat_cmp p&#39; q&#39;
  <span class="kn">where</span> _eat_cmp {i x y z}
        : it_eat i x y -&gt; it_eat i x z -&gt; (it_eat i y z \/ it_eat i z y) :=
    _eat_cmp (EatRefl)   q           := or_introl q ;
    _eat_cmp p           (EatRefl)   := or_intror p ;
    _eat_cmp (EatStep p) (EatStep q) := _eat_cmp p q .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">it_eat&#39;</span> : rel·µ¢ (itree E R) (itree E R) :=
    <span class="kr">fun</span> <span class="nv">i</span> <span class="nv">u</span> <span class="nv">v</span> =&gt; it_eat i u.(_observe) v.(_observe).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk2e"><span class="kn">Definition</span> <span class="nf">it_eat_tau</span> {<span class="nv">i</span> <span class="nv">x</span> <span class="nv">y</span>} (<span class="nv">H</span> : it_eat i (TauF x) (TauF y)) :
    it_eat i x.(_observe) y.(_observe).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E R i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>it_eat i (TauF x) (TauF y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eat i (_observe x) (_observe y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk2f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E R i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>it_eat i (TauF x) (TauF y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eat i (_observe x) (_observe y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk30"><span class="nb">dependent induction</span> H; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E R i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>it_eat i (observe x) (TauF y)</span></span></span><br><span><var>IHit_eat</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y0</span> <span class="nv">x0</span> : itree E R i,
observe x = TauF x0 -&gt;
TauF y = TauF y0 -&gt;
it_eat i (_observe x0) (_observe y0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eat i (_observe x) (_observe y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unfold</span> observe <span class="kr">in</span> H; <span class="nb">destruct</span> x.(_observe) <span class="nb">eqn</span>:Hx; <span class="kp">try</span> <span class="nb">inversion</span> H; <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">it_eat</span>.</span></span></pre><p>Now we are ready to define the monotone endofunction on indexed relations for
weak bisimilarity.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">wbisim</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">I</span> : <span class="kt">Type</span>} (<span class="nv">E</span> : event I I) {<span class="nv">X1</span> <span class="nv">X2</span> : psh I} (<span class="nv">RX</span> : rel·µ¢ X1 X2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">it_wbisimF</span> <span class="nv">RR</span> <span class="nv">i</span> (<span class="nv">t1</span> : itree&#39; E X1 i) (<span class="nv">t2</span> : itree&#39; E X2 i) : <span class="kt">Prop</span> :=
    | WBisim {x1 x2}
        (r1 : it_eat i t1 x1)
        (r2 : it_eat i t2 x2)
        (rr : it_eqF E RX RR i x1 x2).</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">it_wbisim_map</span> : mon (rel·µ¢ (itree E X1) (itree E X2)) :=
    {|
      body RR i x y := it_wbisimF RR i (observe x) (observe y) ;
      Hbody _ _ H _ _ _ &#39;(WBisim r1 r2 rr) := WBisim r1 r2 (it_eqF_mon _ _ H _ _ _ rr) ;
    |}.</span></span></pre><p>And this is it, we can define heterogeneous weak bisimilarity by <tt class="docutils literal">it_wbisim RR</tt> for some
value relation <tt class="docutils literal">RR</tt>. See Def. 10.</p>
<pre class="alectryon-io highlight" id="wbisim"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">it_wbisim</span> := gfp it_wbisim_map.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">it_wbisim&#39;</span> := it_wbisimF it_wbisim.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">wbisim</span>.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;a ‚âà b&quot;</span> := (it_wbisim (eq·µ¢ _) _ a b) (<span class="kn">at level</span> <span class="mi">20</span>).</span></span></pre><div class="section" id="properties">
<h2>Properties</h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">it_wbisim_step</span> {<span class="nv">I</span> <span class="nv">E</span> <span class="nv">X1</span> <span class="nv">X2</span> <span class="nv">RX</span>} :
  it_wbisim RX &lt;= @it_wbisim_map I E X1 X2 RX (it_wbisim RX) :=
  <span class="kr">fun</span> <span class="nv">i</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; proj1 (gfp_fp (it_wbisim_map E RX) i x y) .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">it_wbisim_unstep</span> {<span class="nv">I</span> <span class="nv">E</span> <span class="nv">X1</span> <span class="nv">X2</span> <span class="nv">RX</span>} :
  @it_wbisim_map I E X1 X2 RX (it_wbisim RX) &lt;= it_wbisim RX :=
  <span class="kr">fun</span> <span class="nv">i</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; proj2 (gfp_fp (it_wbisim_map E RX) i x y) .</span></span></pre><p>Weak bisimilarity up to synchronization.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk31"><span class="kn">Lemma</span> <span class="nf">it_wbisim_up2eqF_t</span> {<span class="nv">I</span> <span class="nv">E</span> <span class="nv">X1</span> <span class="nv">X2</span> <span class="nv">RX</span>} :
  @it_eq_map I E X1 X2 RX &lt;= it_wbisim_t E RX.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_map E RX &lt;= it_wbisim_t E RX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk32"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_map E RX &lt;= it_wbisim_t E RX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk33"><span class="nb">apply</span> Coinduction; <span class="nb">intros</span> R i x y H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X1) (itree E X2)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(it_eq_map E RX ¬∞ it_wbisim_map E RX) R i x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bT (it_wbisim_map E RX) (it_eq_map E RX) R i x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk34"><span class="nb">cbn</span> <span class="kr">in</span> *; <span class="nb">dependent destruction</span> H; simpl_depind; <span class="nb">econstructor</span>; <span class="nb">eauto</span>; <span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X1) (itree E X2)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x0, t1</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br><span><var>t_rel</var><span class="hyp-type"><b>: </b><span>it_wbisimF E RX R i (observe t1) (observe t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_T E RX (it_eq_map E RX) R i t1 t2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="eq-v-chk35" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X1) (itree E X2)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : e_rsp q, itree E X1 (e_nxt x)</span></span></span><br><span><var>k2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : e_rsp q, itree E X2 (e_nxt x)</span></span></span><br><span><var>k_rel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q,
it_wbisimF E RX R (e_nxt r) 
  (observe (k1 r)) (observe (k2 r))</span></span></span><br></div><label class="goal-separator" for="eq-v-chk35"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q,
it_wbisim_T E RX (it_eq_map E RX) R 
  (e_nxt r) (k1 r) (k2 r)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk36">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X1) (itree E X2)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x0, t1</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br><span><var>t_rel</var><span class="hyp-type"><b>: </b><span>it_wbisimF E RX R i (observe t1) (observe t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_T E RX (it_eq_map E RX) R i t1 t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (b_T (it_wbisim_map E RX)), t_rel.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk37">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X1) (itree E X2)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : e_rsp q, itree E X1 (e_nxt x)</span></span></span><br><span><var>k2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : e_rsp q, itree E X2 (e_nxt x)</span></span></span><br><span><var>k_rel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q,
it_wbisimF E RX R (e_nxt r) 
  (observe (k1 r)) (observe (k2 r))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q,
it_wbisim_T E RX (it_eq_map E RX) R (e_nxt r) (k1 r)
  (k2 r)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> r; <span class="nb">apply</span> (b_T (it_wbisim_map E RX)), k_rel.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">wbisim_facts_het</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">I</span> : <span class="kt">Type</span>} {<span class="nv">E</span> : event I I} {<span class="nv">X1</span> <span class="nv">X2</span> : psh I} {<span class="nv">RX</span> : rel·µ¢ X1 X2}.</span></span></pre><p>Transitivity will be quite more involved to prove than for strong bisimilarity. In order
to prove it, we will need quite a bit of lemmata for moving synchronization points around.</p>
<p>First a helper for <tt class="docutils literal">go</tt>/<tt class="docutils literal">_observe</tt> (&quot;in&quot;/&quot;out&quot;) maps of the final coalgebra.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk38"><span class="kn">Lemma</span> <span class="nf">it_wbisim_obs</span> {<span class="nv">i</span> <span class="nv">x</span> <span class="nv">y</span>} :
    it_wbisim (E:=E) RX i x y -&gt;
    it_wbisim RX i (go x.(_observe)) (go y.(_observe)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim RX i x y -&gt;
it_wbisim RX i {| _observe := _observe x |}
  {| _observe := _observe y |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk39"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim RX i x y -&gt;
it_wbisim RX i {| _observe := _observe x |}
  {| _observe := _observe y |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk3a"><span class="nb">intro</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>it_wbisim RX i x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim RX i {| _observe := _observe x |}
  {| _observe := _observe y |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk3b"><span class="nb">apply</span> it_wbisim_step <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>it_wbisim_map E RX (it_wbisim RX) i x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim RX i {| _observe := _observe x |}
  {| _observe := _observe y |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk3c"><span class="nb">apply</span> it_wbisim_unstep.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>it_wbisim_map E RX (it_wbisim RX) i x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_map E RX (it_wbisim RX) i
  {| _observe := _observe x |}
  {| _observe := _observe y |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Strong bisimilarity implies weak bisimilarity.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk3d"><span class="kn">Lemma</span> <span class="nf">it_eq_wbisim</span> : it_eq (E:=E) RX &lt;= it_wbisim (E:=E) RX.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq RX &lt;= it_wbisim RX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk3e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq RX &lt;= it_wbisim RX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk3f"><span class="nb">unfold</span> it_wbisim, leq; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : I) (<span class="nv">a0</span> : itree E X1 a) (<span class="nv">a1</span> : itree E X2 a),
Basics.impl (it_eq RX a0 a1)
  (gfp (it_wbisim_map E RX) a a0 a1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk40"><span class="nb">unfold</span> Basics.impl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : I) (<span class="nv">a0</span> : itree E X1 a) (<span class="nv">a1</span> : itree E X2 a),
it_eq RX a0 a1 -&gt; gfp (it_wbisim_map E RX) a a0 a1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk41">coinduction R CIH; <span class="nb">intros</span> i x y H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X1) (itree E X2)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : I) (<span class="nv">a0</span> : itree E X1 a) (<span class="nv">a1</span> : itree E X2 a),
it_eq RX a0 a1 -&gt; it_wbisim_t E RX R a a0 a1</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>it_eq RX x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E RX R i x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk42"><span class="nb">apply</span> it_eq_step <span class="kr">in</span> H; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X1) (itree E X2)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : I) (<span class="nv">a0</span> : itree E X1 a) (<span class="nv">a1</span> : itree E X2 a),
it_eq RX a0 a1 -&gt; it_wbisim_t E RX R a a0 a1</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i (observe x) (observe y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_t E RX R) i (observe x)
  (observe y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">dependent destruction</span> H; simpl_depind; <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Adding a <tt class="docutils literal">Tau</tt> left or right.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk43"><span class="kn">Lemma</span> <span class="nf">wbisim_unstep_l</span> {<span class="nv">R</span>} {<span class="nv">i</span> <span class="nv">x</span> <span class="nv">y</span>} :
    it_wbisimF E RX R i x (observe y) -&gt;
    it_wbisimF E RX R i x (TauF y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X1) (itree E X2)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itree&#39; E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX R i x (observe y) -&gt;
it_wbisimF E RX R i x (TauF y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk44"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X1) (itree E X2)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itree&#39; E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX R i x (observe y) -&gt;
it_wbisimF E RX R i x (TauF y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk45"><span class="nb">intros</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X1) (itree E X2)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itree&#39; E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree E X2 i</span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>itree&#39; E X1 i</span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X2 i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (observe y) x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i x1 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX R i x (TauF y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (WBisim r1 (EatStep r2) rr).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk46"><span class="kn">Lemma</span> <span class="nf">wbisim_unstep_r</span> {<span class="nv">R</span>} {<span class="nv">i</span> <span class="nv">x</span> <span class="nv">y</span>} :
    it_wbisimF E RX R i (observe x) y -&gt;
    it_wbisimF E RX R i (TauF x) y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X1) (itree E X2)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree&#39; E X2 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX R i (observe x) y -&gt;
it_wbisimF E RX R i (TauF x) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk47"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X1) (itree E X2)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree&#39; E X2 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX R i (observe x) y -&gt;
it_wbisimF E RX R i (TauF x) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk48"><span class="nb">intros</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X1, X2</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X1 X2</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X1) (itree E X2)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>itree E X1 i</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>itree&#39; E X2 i</span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>itree&#39; E X1 i</span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X2 i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (observe x) x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i y x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i x1 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX R i (TauF x) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (WBisim (EatStep r1) r2 rr).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Removing a <tt class="docutils literal">Tau</tt> left or right.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">wbisim_step_l</span> {<span class="nv">i</span> <span class="nv">x</span> <span class="nv">y</span>} :
    it_wbisim&#39; E RX i x (TauF y) -&gt;
    it_wbisim&#39; E RX i x (observe y)
    :=
    wbisim_step_l (WBisim p (EatRefl) (EqTau r))
      <span class="kr">with</span> it_wbisim_step _ _ _ r :=
      { | WBisim w1 w2 s := WBisim (eat_trans _ _ _ _ p (EatStep w1)) w2 s } ;
    wbisim_step_l (WBisim p (EatStep q) v) := WBisim p q v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">wbisim_step_r</span> {<span class="nv">i</span> <span class="nv">x</span> <span class="nv">y</span>} :
    it_wbisim&#39; E RX i (TauF x) y -&gt;
    it_wbisim&#39; E RX i (observe x) y
    :=
    wbisim_step_r (WBisim (EatRefl) q (EqTau r))
      <span class="kr">with</span> it_wbisim_step _ _ _ r :=
      { | WBisim w1 w2 s := WBisim w1 (eat_trans _ _ _ _ q (EatStep w2)) s } ;
    wbisim_step_r (WBisim (EatStep p) q v) := WBisim p q v.</span></span></pre><p>Pulling a <tt class="docutils literal">Tau</tt> synchronization point up.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">wbisim_tau_up_r</span> {<span class="nv">i</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>}
    (<span class="nv">u</span> : it_eat i x (TauF y))
    (<span class="nv">v</span> : it_eqF E RX (it_wbisim RX) i (TauF y) z) :
    it_eqF E RX (it_wbisim RX) i x z
    :=
    wbisim_tau_up_r (EatRefl)   q         := q ;
    wbisim_tau_up_r (EatStep p) (EqTau q) <span class="kr">with</span> it_wbisim_step _ _ _ q := {
      | WBisim w1 w2 s :=
          EqTau (it_wbisim_unstep _ _ _ (WBisim (eat_trans _ _ _ _ p (EatStep w1)) w2 s))
      }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">wbisim_tau_up_l</span> {<span class="nv">i</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>}
    (<span class="nv">u</span> : it_eqF E RX (it_wbisim RX) i x (TauF y))
    (<span class="nv">v</span> : it_eat i z (TauF y)) :
    it_eqF E RX (it_wbisim RX) i x z
    :=
    wbisim_tau_up_l p         (EatRefl)   := p ;
    wbisim_tau_up_l (EqTau p) (EatStep q) <span class="kr">with</span> it_wbisim_step _ _ _ p := {
      | WBisim w1 w2 s :=
          EqTau (it_wbisim_unstep _ _ _ (WBisim w1 (eat_trans _ _ _ _ q (EatStep w2)) s))
      }.</span></span></pre><p>Pushing a <tt class="docutils literal">Ret</tt> or <tt class="docutils literal">Vis</tt> synchronization down.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">wbisim_ret_down_l</span> {<span class="nv">i</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">r</span>} :
    it_wbisim&#39; E RX i x y -&gt;
    it_eat i y (RetF r) -&gt;
    (it_eat ‚®ü it_eqF E RX (it_wbisim RX)) i x (RetF r)
    :=
    wbisim_ret_down_l (WBisim p (EatRefl) w) (EatRefl)   := p ‚®ü‚®ü w ;
    wbisim_ret_down_l w                      (EatStep q) := wbisim_ret_down_l
                                                              (wbisim_step_l w) q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">wbisim_ret_down_r</span> {<span class="nv">i</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">r</span>} :
    it_eat i x (RetF r) -&gt;
    it_wbisim&#39; E RX i x y -&gt;
    (it_eqF E RX (it_wbisim RX) ‚®ü rev·µ¢ it_eat) i (RetF r) y
    :=
    wbisim_ret_down_r (EatRefl)   (WBisim (EatRefl) q w) := w ‚®ü‚®ü q ;
    wbisim_ret_down_r (EatStep p) w                      := wbisim_ret_down_r p
                                                              (wbisim_step_r w).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">wbisim_vis_down_l</span> {<span class="nv">i</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">e</span> <span class="nv">k</span>} :
    it_wbisim&#39; E RX i x y -&gt;
    it_eat i y (VisF e k) -&gt;
    (it_eat ‚®ü it_eqF E RX (it_wbisim RX)) i x (VisF e k)
    :=
    wbisim_vis_down_l (WBisim p (EatRefl) w) (EatRefl)   := p ‚®ü‚®ü w ;
    wbisim_vis_down_l w                      (EatStep q) := wbisim_vis_down_l
                                                              (wbisim_step_l w) q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">wbisim_vis_down_r</span> {<span class="nv">i</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">e</span> <span class="nv">k</span>} :
    it_eat i x (VisF e k) -&gt;
    it_wbisim&#39; E RX i x y -&gt;
    (it_eqF E RX (it_wbisim RX) ‚®ü rev·µ¢ it_eat) i (VisF e k) y
    :=
    wbisim_vis_down_r (EatRefl)   (WBisim (EatRefl) q w) := w ‚®ü‚®ü q ;
    wbisim_vis_down_r (EatStep p) w                      := wbisim_vis_down_r p
                                                              (wbisim_step_r w) .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">wbisim_facts_het</span>.</span></span></pre><p>We are now ready to prove the useful properties.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">wbisim_facts_hom</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">I</span> : <span class="kt">Type</span>} {<span class="nv">E</span> : event I I} {<span class="nv">X</span> : psh I} {<span class="nv">RX</span> : rel·µ¢ X X}.</span></span></pre><p>Registering that strong bisimilarity is a subrelation.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">it_eq_wbisim_subrel</span> :
    Subrelation·µ¢ (it_eq (E:=E) RX) (it_wbisim (E:=E) RX)
    := it_eq_wbisim.</span></span></pre><p>Reflexivity.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk49"><span class="kn">Lemma</span> <span class="nf">it_wbisim_up2rfl</span> `{Reflexive·µ¢ RX} :
    const (eq·µ¢ _) &lt;= it_wbisim_t E RX.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Reflexive·µ¢0</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">const (eq·µ¢ (itree E X)) &lt;= it_wbisim_t E RX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk4a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Reflexive·µ¢0</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">const (eq·µ¢ (itree E X)) &lt;= it_wbisim_t E RX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk4b"><span class="nb">apply</span> leq_t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Reflexive·µ¢0</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">const (eq·µ¢ (itree E X)) ¬∞ it_wbisim_map E RX &lt;=
it_wbisim_map E RX ¬∞ const (eq·µ¢ (itree E X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk4c"><span class="kp">repeat</span> <span class="nb">intro</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Reflexive·µ¢0</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RX</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>itree E X a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(const (eq·µ¢ (itree E X)) ¬∞ it_wbisim_map E RX) a
  a0 a1 a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(it_wbisim_map E RX ¬∞ const (eq·µ¢ (itree E X))) a a0 a1
  a2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk4d"><span class="nb">rewrite</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Reflexive·µ¢0</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RX</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>itree E X a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(const (eq·µ¢ (itree E X)) ¬∞ it_wbisim_map E RX) a
  a0 a1 a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(it_wbisim_map E RX ¬∞ const (eq·µ¢ (itree E X))) a a0 a2
  a2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk4e"><span class="nb">econstructor</span>; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Reflexive·µ¢0</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RX</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>itree E X a0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(const (eq·µ¢ (itree E X)) ¬∞ it_wbisim_map E RX) a
  a0 a1 a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RX (const (eq·µ¢ (itree E X)) a) a0
  (observe a2) (observe a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> it_eqF_rfl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk4f">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">it_wbisim_t_refl</span> `{Reflexive·µ¢ RX} {RR} :
    Reflexive·µ¢ (it_wbisim_t E RX RR).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Reflexive·µ¢0</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflexive·µ¢ (it_wbisim_t E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk50"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Reflexive·µ¢0</var><span class="hyp-type"><b>: </b><span>Reflexive·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflexive·µ¢ (it_wbisim_t E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> build_reflexive, (ft_t it_wbisim_up2rfl RR).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Symmetry.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk51"><span class="kn">Lemma</span> <span class="nf">it_wbisim_up2sym</span> `{Symmetric·µ¢ RX} :
    converse·µ¢ &lt;= it_wbisim_t E RX.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Symmetric·µ¢0</var><span class="hyp-type"><b>: </b><span>Symmetric·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">converse·µ¢ &lt;= it_wbisim_t E RX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk52"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Symmetric·µ¢0</var><span class="hyp-type"><b>: </b><span>Symmetric·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">converse·µ¢ &lt;= it_wbisim_t E RX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk53"><span class="nb">apply</span> leq_t; <span class="nb">intros</span> ? ? ? ? [ ? ? r1 r2 rr ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Symmetric·µ¢0</var><span class="hyp-type"><b>: </b><span>Symmetric·µ¢ RX</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>itree E X a0</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X a0</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat a0 (observe a2) x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat a0 (observe a1) x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX a a0 x1 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(it_wbisim_map E RX ¬∞ converse·µ¢) a a0 a1 a2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk54"><span class="nb">refine</span> (WBisim r2 r1 _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Symmetric·µ¢0</var><span class="hyp-type"><b>: </b><span>Symmetric·µ¢ RX</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>itree E X a0</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X a0</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat a0 (observe a2) x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat a0 (observe a1) x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX a a0 x1 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RX (converse·µ¢ a) a0 x2 x1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> it_eqF_sym.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk55">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">it_wbisim_t_sym</span> `{Symmetric·µ¢ RX} {RR} :
    Symmetric·µ¢ (it_wbisim_t E RX RR).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Symmetric·µ¢0</var><span class="hyp-type"><b>: </b><span>Symmetric·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Symmetric·µ¢ (it_wbisim_t E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk56"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Symmetric·µ¢0</var><span class="hyp-type"><b>: </b><span>Symmetric·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Symmetric·µ¢ (it_wbisim_t E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> build_symmetric, (ft_t it_wbisim_up2sym RR).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk57">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">it_wbisim_bt_sym</span> `{Symmetric·µ¢ RX} {RR} :
    Symmetric·µ¢ (it_wbisim_bt E RX RR).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Symmetric·µ¢0</var><span class="hyp-type"><b>: </b><span>Symmetric·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Symmetric·µ¢ (it_wbisim_bt E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk58"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Symmetric·µ¢0</var><span class="hyp-type"><b>: </b><span>Symmetric·µ¢ RX</span></span></span><br><span><var>RR</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Symmetric·µ¢ (it_wbisim_bt E RX RR)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> build_symmetric, (fbt_bt it_wbisim_up2sym RR).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Concatenation, transitivity.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk59"><span class="kn">Lemma</span> <span class="nf">it_wbisimF_tra</span> `{Transitive·µ¢ RX} :
    (it_wbisim&#39; E RX ‚®ü it_wbisim&#39; E RX) &lt;= it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(it_wbisim&#39; E RX ‚®ü it_wbisim&#39; E RX) &lt;=
it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk5a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(it_wbisim&#39; E RX ‚®ü it_wbisim&#39; E RX) &lt;=
it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk5b"><span class="nb">intros</span> i x y [z [[x1 x2 u1 u2 uS] [y1 y2 v1 v2 vS]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, z, x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>u2</var><span class="hyp-type"><b>: </b><span>it_eat i z x2</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 x2</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>it_eat i z y1</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i y1 y2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk5c"><span class="nb">destruct</span> (eat_cmp _ _ _ (u2 ‚®ü‚®ü v1)) <span class="kr">as</span> [w | w]; <span class="nb">clear</span> z u2 v1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 x2</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i y1 y2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>it_eat i x2 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="eq-v-chk5d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 x2</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i y1 y2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>rev·µ¢ it_eat i x2 y1</span></span></span><br></div><label class="goal-separator" for="eq-v-chk5d"><hr></label><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk5e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 x2</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i y1 y2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>it_eat i x2 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk5f"><span class="nb">destruct</span> y1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 x2</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i (RetF r) y2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>it_eat i x2 (RetF r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="eq-v-chk60" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 x2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i (TauF t) y2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>it_eat i x2 (TauF t)</span></span></span><br></div><label class="goal-separator" for="eq-v-chk60"><hr></label><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote><input class="alectryon-extra-goal-toggle" id="eq-v-chk61" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 x2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E X (e_nxt r)</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i (VisF q k) y2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>it_eat i x2 (VisF q k)</span></span></span><br></div><label class="goal-separator" for="eq-v-chk61"><hr></label><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk62">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 x2</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i (RetF r) y2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>it_eat i x2 (RetF r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk63"><span class="nb">destruct</span> (wbisim_ret_down_l (WBisim u1 EatRefl uS) w) <span class="kr">as</span> [z [w1 ww]];
          <span class="nb">clear</span> u1 uS w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i (RetF r) y2</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>w1</var><span class="hyp-type"><b>: </b><span>it_eat i x z</span></span></span><br><span><var>ww</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i z (RetF r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk64"><span class="nb">dependent destruction</span> vS; <span class="nb">dependent destruction</span> ww.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r, r2</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y (RetF r2)</span></span></span><br><span><var>r_rel</var><span class="hyp-type"><b>: </b><span>RX i r r2</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>w1</var><span class="hyp-type"><b>: </b><span>it_eat i x (RetF r1)</span></span></span><br><span><var>r_rel0</var><span class="hyp-type"><b>: </b><span>RX i r1 r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (WBisim w1 v2 (EqRet _)); <span class="bp">now</span> <span class="nb">transitivity</span> r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk65">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 x2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i (TauF t) y2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>it_eat i x2 (TauF t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (WBisim u1 v2 (it_eqF_tra _ _ _ (uS ‚®ü‚®ü wbisim_tau_up_r w vS))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk66">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 x2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E X (e_nxt r)</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i (VisF q k) y2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>it_eat i x2 (VisF q k)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk67"><span class="nb">destruct</span> (wbisim_vis_down_l (WBisim u1 EatRefl uS) w) <span class="kr">as</span> [z [w1 ww]];
          <span class="nb">clear</span> u1 uS w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E X (e_nxt r)</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i (VisF q k) y2</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>w1</var><span class="hyp-type"><b>: </b><span>it_eat i x z</span></span></span><br><span><var>ww</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i z (VisF q k)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk68"><span class="nb">dependent destruction</span> vS; <span class="nb">dependent destruction</span> ww.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k, k2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : e_rsp q, itree E X (e_nxt x)</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y (VisF q k2)</span></span></span><br><span><var>k_rel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q,
it_wbisim RX (e_nxt r) (k r) (k2 r)</span></span></span><br><span><var>k1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : e_rsp q, itree E X (e_nxt x)</span></span></span><br><span><var>w1</var><span class="hyp-type"><b>: </b><span>it_eat i x (VisF q k1)</span></span></span><br><span><var>k_rel0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q,
it_wbisim RX (e_nxt r) (k1 r) (k r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (WBisim w1 v2 (EqVis (<span class="kr">fun</span> <span class="nv">r</span> =&gt; k_rel0 r ‚®ü‚®ü k_rel r))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk69">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 x2</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i y1 y2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>rev·µ¢ it_eat i x2 y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk6a"><span class="nb">destruct</span> x2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 (RetF r)</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i y1 y2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>rev·µ¢ it_eat i (RetF r) y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="eq-v-chk6b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 (TauF t)</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i y1 y2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>rev·µ¢ it_eat i (TauF t) y1</span></span></span><br></div><label class="goal-separator" for="eq-v-chk6b"><hr></label><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote><input class="alectryon-extra-goal-toggle" id="eq-v-chk6c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E X (e_nxt r)</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 (VisF q k)</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i y1 y2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>rev·µ¢ it_eat i (VisF q k) y1</span></span></span><br></div><label class="goal-separator" for="eq-v-chk6c"><hr></label><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk6d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 (RetF r)</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i y1 y2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>rev·µ¢ it_eat i (RetF r) y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk6e"><span class="nb">destruct</span> (wbisim_ret_down_r w (WBisim EatRefl v2 vS)) <span class="kr">as</span> [z [ww w1]];
          <span class="nb">clear</span> v2 vS w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 (RetF r)</span></span></span><br><span><var>y1, y2, z</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>ww</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i (RetF r) z</span></span></span><br><span><var>w1</var><span class="hyp-type"><b>: </b><span>rev·µ¢ it_eat i z y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk6f"><span class="nb">dependent destruction</span> uS; <span class="nb">dependent destruction</span> ww.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1, r</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x (RetF r1)</span></span></span><br><span><var>r_rel</var><span class="hyp-type"><b>: </b><span>RX i r1 r</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>r_rel0</var><span class="hyp-type"><b>: </b><span>RX i r r2</span></span></span><br><span><var>w1</var><span class="hyp-type"><b>: </b><span>rev·µ¢ it_eat i (RetF r2) y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (WBisim u1 w1 (EqRet _)); <span class="bp">now</span> <span class="nb">transitivity</span> r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk70">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 (TauF t)</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i y1 y2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>rev·µ¢ it_eat i (TauF t) y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (WBisim u1 v2 (it_eqF_tra _ _ _ (wbisim_tau_up_l uS w ‚®ü‚®ü vS))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk71">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E X (e_nxt r)</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 (VisF q k)</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>it_eat i y y2</span></span></span><br><span><var>vS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i y1 y2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>rev·µ¢ it_eat i (VisF q k) y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk72"><span class="nb">destruct</span> (wbisim_vis_down_r w (WBisim EatRefl v2 vS)) <span class="kr">as</span> [z [ww w1]];
          <span class="nb">clear</span> v2 vS w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y, x1</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E X (e_nxt r)</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x x1</span></span></span><br><span><var>uS</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i x1 (VisF q k)</span></span></span><br><span><var>y1, y2, z</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>ww</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_wbisim RX) i (VisF q k) z</span></span></span><br><span><var>w1</var><span class="hyp-type"><b>: </b><span>rev·µ¢ it_eat i z y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk73"><span class="nb">dependent destruction</span> uS; <span class="nb">dependent destruction</span> ww.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k1, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, itree E X (e_nxt r)</span></span></span><br><span><var>u1</var><span class="hyp-type"><b>: </b><span>it_eat i x (VisF q k1)</span></span></span><br><span><var>k_rel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q,
it_wbisim RX (e_nxt r) (k1 r) (k r)</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>k2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : e_rsp q, itree E X (e_nxt x)</span></span></span><br><span><var>k_rel0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q,
it_wbisim RX (e_nxt r) (k r) (k2 r)</span></span></span><br><span><var>w1</var><span class="hyp-type"><b>: </b><span>rev·µ¢ it_eat i (VisF q k2) y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim RX ‚®ü it_wbisim RX) i x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (WBisim u1 w1 (EqVis (<span class="kr">fun</span> <span class="nv">r</span> =&gt; k_rel r ‚®ü‚®ü k_rel0 r))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk74">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">it_wbisim_tra</span> `{Transitive·µ¢ RX} :
    Transitive·µ¢ (@it_wbisim I E X X RX).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Transitive·µ¢ (it_wbisim RX)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk75"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Transitive·µ¢ (it_wbisim RX)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk76"><span class="nb">apply</span> build_transitive, coinduction; <span class="nb">intros</span> ? ? ? [ ? [ u v ] ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a0, a1, x</var><span class="hyp-type"><b>: </b><span>itree E X a</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_wbisim RX a a0 x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_wbisim RX a x a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_bt E RX (square·µ¢ (it_wbisim RX)) a a0 a1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk77"><span class="nb">eapply</span> (Hbody (it_wbisim_map _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a0, a1, x</var><span class="hyp-type"><b>: </b><span>itree E X a</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_wbisim RX a a0 x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_wbisim RX a x a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?x</span> &lt;= it_wbisim_t E RX (square·µ¢ (it_wbisim RX))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="eq-v-chk78" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a0, a1, x</var><span class="hyp-type"><b>: </b><span>itree E X a</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_wbisim RX a a0 x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_wbisim RX a x a1</span></span></span><br></div><label class="goal-separator" for="eq-v-chk78"><hr></label><div class="goal-conclusion">it_wbisim_map E RX <span class="nl">?x</span> a a0 a1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk79">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a0, a1, x</var><span class="hyp-type"><b>: </b><span>itree E X a</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_wbisim RX a a0 x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_wbisim RX a x a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?x</span> &lt;= it_wbisim_t E RX (square·µ¢ (it_wbisim RX))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> id_t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk7a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a0, a1, x</var><span class="hyp-type"><b>: </b><span>itree E X a</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_wbisim RX a a0 x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_wbisim RX a x a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_map E RX (id (square·µ¢ (it_wbisim RX))) a a0
  a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk7b"><span class="nb">apply</span> it_wbisimF_tra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a0, a1, x</var><span class="hyp-type"><b>: </b><span>itree E X a</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_wbisim RX a a0 x</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_wbisim RX a x a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(it_wbisim&#39; E RX ‚®ü it_wbisim&#39; E RX) a 
  (observe a0) (observe a1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (_ ‚®ü‚®ü _) ; <span class="nb">apply</span> it_wbisim_step; [ <span class="bp">exact</span> u | <span class="bp">exact</span> v ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Packaging the above as equivalence.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk7c">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">it_wbisim_equiv</span> `{Equivalence·µ¢ RX} :
    Equivalence·µ¢ (it_wbisim (E:=E) RX).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equivalence·µ¢ (it_wbisim RX)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk7d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equivalence·µ¢ (it_wbisim RX)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">econstructor</span>; <span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Eliminating <tt class="docutils literal">Tau</tt> on both sides.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk7e"><span class="kn">Lemma</span> <span class="nf">it_wbisim_tau</span> `{Equivalence·µ¢ RX} {i x y} :
    it_wbisim (E:=E) RX i (Tau&#39; x) (Tau&#39; y) -&gt; it_wbisim RX i x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim RX i (Tau&#39; x) (Tau&#39; y) -&gt; it_wbisim RX i x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk7f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim RX i (Tau&#39; x) (Tau&#39; y) -&gt; it_wbisim RX i x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk80"><span class="nb">intro</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>it_wbisim RX i (Tau&#39; x) (Tau&#39; y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim RX i x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk81"><span class="nb">transitivity</span> (Tau&#39; x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>it_wbisim RX i (Tau&#39; x) (Tau&#39; y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim RX i x (Tau&#39; x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="eq-v-chk82" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>it_wbisim RX i (Tau&#39; x) (Tau&#39; y)</span></span></span><br></div><label class="goal-separator" for="eq-v-chk82"><hr></label><div class="goal-conclusion">it_wbisim RX i (Tau&#39; x) y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk83"><span class="nb">apply</span> it_wbisim_unstep.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>it_wbisim RX i (Tau&#39; x) (Tau&#39; y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_map E RX (it_wbisim RX) i x (Tau&#39; x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="eq-v-chk84" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>it_wbisim RX i (Tau&#39; x) (Tau&#39; y)</span></span></span><br></div><label class="goal-separator" for="eq-v-chk84"><hr></label><div class="goal-conclusion">it_wbisim RX i (Tau&#39; x) y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk85"><span class="nb">econstructor</span>; [ <span class="bp">exact</span> EatRefl | <span class="bp">exact</span> (EatStep EatRefl) | <span class="nb">destruct</span> (observe x); <span class="nb">eauto</span> ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>it_wbisim RX i (Tau&#39; x) (Tau&#39; y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim RX i (Tau&#39; x) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk86"><span class="nb">transitivity</span> (Tau&#39; y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>it_wbisim RX i (Tau&#39; x) (Tau&#39; y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim RX i (Tau&#39; x) (Tau&#39; y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="eq-v-chk87" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>it_wbisim RX i (Tau&#39; x) (Tau&#39; y)</span></span></span><br></div><label class="goal-separator" for="eq-v-chk87"><hr></label><div class="goal-conclusion">it_wbisim RX i (Tau&#39; y) y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk88"><span class="bp">exact</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>it_wbisim RX i (Tau&#39; x) (Tau&#39; y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim RX i (Tau&#39; y) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk89"><span class="nb">apply</span> it_wbisim_unstep.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Equivalence·µ¢0</var><span class="hyp-type"><b>: </b><span>Equivalence·µ¢ RX</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>it_wbisim RX i (Tau&#39; x) (Tau&#39; y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_map E RX (it_wbisim RX) i (Tau&#39; y) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">econstructor</span>; [ <span class="bp">exact</span> (EatStep EatRefl) | <span class="bp">exact</span> EatRefl | <span class="nb">destruct</span> (observe y); <span class="nb">eauto</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>We have proven that strong bisimilarity entails weak bisimilarity, but now we prove the
much more powerful fact that we can prove weak bisimilarity <em>up-to</em> strong bisimilarity.
That is, we will be allowed to close any weak bisimulation candidate by strong bisimilarity.
Let us first define a helper relation taking a relation to its saturation by strong
bisimilarity.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">eq_clo</span> (<span class="nv">R</span> : rel·µ¢ (itree E X) (itree E X)) <span class="nv">i</span> (<span class="nv">x</span> <span class="nv">y</span> : itree E X i) : <span class="kt">Prop</span> :=
    | EqClo {a b} : it_eq RX x a -&gt; it_eq RX b y -&gt; R i a b -&gt; eq_clo R i x y
  .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Arguments</span> EqClo {R i x y a b}.</span></span></pre><p>This helper is monotone...</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eq_clo_map</span> : mon (rel·µ¢ (itree E X) (itree E X)) :=
    {| body R := eq_clo R ;
      Hbody _ _ H _ _ _ &#39;(EqClo p q r) := EqClo p q (H _ _ _ r) |}.</span></span></pre><p>... and below the companion of weak bisimilarity, hence justifying the up-to.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk8a"><span class="kn">Lemma</span> <span class="nf">it_wbisim_up2eq</span> `{Transitive·µ¢ RX} : eq_clo_map &lt;= it_wbisim_t E RX.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eq_clo_map &lt;= it_wbisim_t E RX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk8b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eq_clo_map &lt;= it_wbisim_t E RX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk8c"><span class="nb">apply</span> Coinduction; <span class="nb">intros</span> R i a b [ c d u v [] ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eq RX a c</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eq RX d b</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (observe c) x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (observe d) x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i x1 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bT (it_wbisim_map E RX) eq_clo_map R i a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk8d"><span class="nb">apply</span> it_eq_step <span class="kr">in</span> u, v; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i (observe a) (observe c)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i (observe d) (observe b)</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (observe c) x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (observe d) x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i x1 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R) i
  (observe a) (observe b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk8e"><span class="nb">remember</span> (observe a) <span class="kr">as</span> oa; <span class="nb">clear</span> a Heqoa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>b, c, d</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>oa</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i oa (observe c)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i (observe d) (observe b)</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (observe c) x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (observe d) x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i x1 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R) i oa
  (observe b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk8f"><span class="nb">remember</span> (observe b) <span class="kr">as</span> ob; <span class="nb">clear</span> b Heqob.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>c, d</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>oa</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i oa (observe c)</span></span></span><br><span><var>ob</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i (observe d) ob</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (observe c) x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (observe d) x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i x1 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R) i oa
  ob</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk90"><span class="nb">remember</span> (observe c) <span class="kr">as</span> oc; <span class="nb">clear</span> c Heqoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>oa, oc</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i oa oc</span></span></span><br><span><var>ob</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i (observe d) ob</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i oc x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (observe d) x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i x1 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R) i oa
  ob</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk91"><span class="nb">remember</span> (observe d) <span class="kr">as</span> od; <span class="nb">clear</span> d Heqod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>oa, oc</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i oa oc</span></span></span><br><span><var>ob, od</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i od ob</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i oc x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i od x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i x1 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R) i oa
  ob</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk92"><span class="nb">revert</span> oa ob od x2 u r2 v rr; <span class="nb">induction</span> r1; <span class="nb">intros</span> oa ob od x2 u r2 v rr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t, oa, ob, od, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i oa t</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i od x2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i od ob</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i t x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R) i oa
  ob</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="eq-v-chk93" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (observe t1) t2</span></span></span><br><span><var>IHr1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> <span class="nv">ob</span> <span class="nv">od</span> <span class="nv">x2</span> : itree&#39; E X i,
it_eqF E RX (it_eq RX) i oa (observe t1) -&gt;
it_eat i od x2 -&gt;
it_eqF E RX (it_eq RX) i od ob -&gt;
it_eqF E RX R i t2 x2 -&gt;
it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R)
  i oa ob</span></span></span><br><span><var>oa, ob, od, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i oa (TauF t1)</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i od x2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i od ob</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i t2 x2</span></span></span><br></div><label class="goal-separator" for="eq-v-chk93"><hr></label><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R) i oa
  ob</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk94">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t, oa, ob, od, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i oa t</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i od x2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i od ob</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i t x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R) i oa
  ob</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk95"><span class="nb">revert</span> oa ob u v rr; <span class="nb">induction</span> r2; <span class="nb">intros</span> oa ob u v rr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t, t0, oa, ob</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i oa t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i t0 ob</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i t t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R) i oa
  ob</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="eq-v-chk96" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (observe t1) t2</span></span></span><br><span><var>IHr2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> <span class="nv">ob</span> : itree&#39; E X i,
it_eqF E RX (it_eq RX) i oa t -&gt;
it_eqF E RX (it_eq RX) i (observe t1) ob -&gt;
it_eqF E RX R i t t2 -&gt;
it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R)
  i oa ob</span></span></span><br><span><var>oa, ob</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i oa t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i (TauF t1) ob</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i t t2</span></span></span><br></div><label class="goal-separator" for="eq-v-chk96"><hr></label><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R) i oa
  ob</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk97">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t, t0, oa, ob</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i oa t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i t0 ob</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i t t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R) i oa
  ob</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk98"><span class="nb">destruct</span> rr; dependent elimination u; dependent elimination v;
          <span class="nb">refine</span> (WBisim EatRefl EatRefl _); <span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>r3, r5, r4</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>r_rel0</var><span class="hyp-type"><b>: </b><span>RX i r3 r4</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>r_rel1</var><span class="hyp-type"><b>: </b><span>RX i r1 r5</span></span></span><br><span><var>r_rel</var><span class="hyp-type"><b>: </b><span>RX i r4 r1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RX i r3 r5</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="eq-v-chk99" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t3, t5, t4</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>t_rel0</var><span class="hyp-type"><b>: </b><span>it_eq RX t3 t4</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>t_rel1</var><span class="hyp-type"><b>: </b><span>it_eq RX t1 t5</span></span></span><br><span><var>t_rel</var><span class="hyp-type"><b>: </b><span>R i t4 t1</span></span></span><br></div><label class="goal-separator" for="eq-v-chk99"><hr></label><div class="goal-conclusion">it_wbisim_T E RX eq_clo_map R i t3 t5</div></blockquote><input class="alectryon-extra-goal-toggle" id="eq-v-chk9a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k3, k5, k4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : e_rsp q, itree E X (e_nxt x)</span></span></span><br><span><var>k_rel0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, it_eq RX (k3 r) (k4 r)</span></span></span><br><span><var>k1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : e_rsp q, itree E X (e_nxt x)</span></span></span><br><span><var>k_rel1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, it_eq RX (k1 r) (k5 r)</span></span></span><br><span><var>k_rel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, R (e_nxt r) (k4 r) (k1 r)</span></span></span><br></div><label class="goal-separator" for="eq-v-chk9a"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q,
it_wbisim_T E RX eq_clo_map R (e_nxt r) (k3 r) (k5 r)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk9b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>r3, r5, r4</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>r_rel0</var><span class="hyp-type"><b>: </b><span>RX i r3 r4</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>X i</span></span></span><br><span><var>r_rel1</var><span class="hyp-type"><b>: </b><span>RX i r1 r5</span></span></span><br><span><var>r_rel</var><span class="hyp-type"><b>: </b><span>RX i r4 r1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RX i r3 r5</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">transitivity</span> r4; <span class="nb">auto</span>; <span class="nb">transitivity</span> r1; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk9c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t3, t5, t4</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>t_rel0</var><span class="hyp-type"><b>: </b><span>it_eq RX t3 t4</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>t_rel1</var><span class="hyp-type"><b>: </b><span>it_eq RX t1 t5</span></span></span><br><span><var>t_rel</var><span class="hyp-type"><b>: </b><span>R i t4 t1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisim_T E RX eq_clo_map R i t3 t5</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (f_Tf (it_wbisim_map E RX)); <span class="bp">exact</span> (EqClo t_rel0 t_rel1 t_rel).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk9d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry i</span></span></span><br><span><var>k3, k5, k4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : e_rsp q, itree E X (e_nxt x)</span></span></span><br><span><var>k_rel0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, it_eq RX (k3 r) (k4 r)</span></span></span><br><span><var>k1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : e_rsp q, itree E X (e_nxt x)</span></span></span><br><span><var>k_rel1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, it_eq RX (k1 r) (k5 r)</span></span></span><br><span><var>k_rel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q, R (e_nxt r) (k4 r) (k1 r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q,
it_wbisim_T E RX eq_clo_map R (e_nxt r) (k3 r) (k5 r)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> r; <span class="nb">apply</span> (f_Tf (it_wbisim_map E RX)); <span class="bp">exact</span> (EqClo (k_rel0 r) (k_rel1 r) (k_rel r)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk9e">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (observe t1) t2</span></span></span><br><span><var>IHr2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> <span class="nv">ob</span> : itree&#39; E X i,
it_eqF E RX (it_eq RX) i oa t -&gt;
it_eqF E RX (it_eq RX) i (observe t1) ob -&gt;
it_eqF E RX R i t t2 -&gt;
it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R)
  i oa ob</span></span></span><br><span><var>oa, ob</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i oa t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i (TauF t1) ob</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i t t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R) i oa
  ob</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chk9f">dependent elimination v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>t3</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (observe t3) t2</span></span></span><br><span><var>IHr2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> <span class="nv">ob</span> : itree&#39; E X i,
it_eqF E RX (it_eq RX) i oa t -&gt;
it_eqF E RX (it_eq RX) i (observe t3) ob -&gt;
it_eqF E RX R i t t2 -&gt;
it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R)
  i oa ob</span></span></span><br><span><var>oa</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>t4</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i oa t</span></span></span><br><span><var>t_rel</var><span class="hyp-type"><b>: </b><span>it_eq RX t3 t4</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i t t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R) i oa
  (TauF t4)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chka0"><span class="nb">apply</span> it_eq_step <span class="kr">in</span> t_rel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>t3</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (observe t3) t2</span></span></span><br><span><var>IHr2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> <span class="nv">ob</span> : itree&#39; E X i,
it_eqF E RX (it_eq RX) i oa t -&gt;
it_eqF E RX (it_eq RX) i (observe t3) ob -&gt;
it_eqF E RX R i t t2 -&gt;
it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R)
  i oa ob</span></span></span><br><span><var>oa</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>t4</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i oa t</span></span></span><br><span><var>t_rel</var><span class="hyp-type"><b>: </b><span>it_eq_map E RX (it_eq RX) i t3 t4</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i t t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R) i oa
  (TauF t4)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> wbisim_unstep_l, IHr2; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chka1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (observe t1) t2</span></span></span><br><span><var>IHr1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> <span class="nv">ob</span> <span class="nv">od</span> <span class="nv">x2</span> : itree&#39; E X i,
it_eqF E RX (it_eq RX) i oa (observe t1) -&gt;
it_eat i od x2 -&gt;
it_eqF E RX (it_eq RX) i od ob -&gt;
it_eqF E RX R i t2 x2 -&gt;
it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R)
  i oa ob</span></span></span><br><span><var>oa, ob, od, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i oa (TauF t1)</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i od x2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i od ob</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i t2 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R) i oa
  ob</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chka2">dependent elimination u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t4</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (observe t4) t2</span></span></span><br><span><var>IHr1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> <span class="nv">ob</span> <span class="nv">od</span> <span class="nv">x2</span> : itree&#39; E X i,
it_eqF E RX (it_eq RX) i oa (observe t4) -&gt;
it_eat i od x2 -&gt;
it_eqF E RX (it_eq RX) i od ob -&gt;
it_eqF E RX R i t2 x2 -&gt;
it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R)
  i oa ob</span></span></span><br><span><var>t3</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>ob, od, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>t_rel</var><span class="hyp-type"><b>: </b><span>it_eq RX t3 t4</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i od x2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i od ob</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i t2 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R) i
  (TauF t3) ob</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chka3"><span class="nb">apply</span> it_eq_step <span class="kr">in</span> t_rel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>t4</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (observe t4) t2</span></span></span><br><span><var>IHr1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> <span class="nv">ob</span> <span class="nv">od</span> <span class="nv">x2</span> : itree&#39; E X i,
it_eqF E RX (it_eq RX) i oa (observe t4) -&gt;
it_eat i od x2 -&gt;
it_eqF E RX (it_eq RX) i od ob -&gt;
it_eqF E RX R i t2 x2 -&gt;
it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R)
  i oa ob</span></span></span><br><span><var>t3</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>ob, od, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>t_rel</var><span class="hyp-type"><b>: </b><span>it_eq_map E RX (it_eq RX) i t3 t4</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i od x2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eqF E RX (it_eq RX) i od ob</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i t2 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (it_wbisim_T E RX eq_clo_map R) i
  (TauF t3) ob</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> wbisim_unstep_r, (IHr1 (observe t3) ob od x2); <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>We now do the same for up-to eating.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">eat_clo</span> (<span class="nv">R</span> : rel·µ¢ (itree E X) (itree E X)) <span class="nv">i</span> (<span class="nv">x</span> <span class="nv">y</span> : itree E X i) : <span class="kt">Prop</span> :=
    | EatClo {a b} : it_eat&#39; i x a -&gt; it_eat&#39; i y b -&gt; R i a b -&gt; eat_clo R i x y
  .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Arguments</span> EatClo {R i x y a b}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eat_clo_map</span> : mon (rel·µ¢ (itree E X) (itree E X)) :=
    {| body R := eat_clo R ;
       Hbody _ _ H _ _ _ &#39;(EatClo p q r) := EatClo p q (H _ _ _ r) |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chka4"><span class="kn">Lemma</span> <span class="nf">it_wbisim_up2eat</span> `{Transitive·µ¢ RX} : eat_clo_map &lt;= it_wbisim_t E RX.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eat_clo_map &lt;= it_wbisim_t E RX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chka5"><span class="nb">apply</span> leq_t; <span class="nb">intros</span> R i a b [ c d u v [] ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eat&#39; i a c</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eat&#39; i b d</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (observe c) x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (observe d) x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i x1 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(it_wbisim_map E RX ¬∞ eat_clo_map) R i a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chka6"><span class="nb">unfold</span> it_eat&#39; <span class="kr">in</span> u,v; <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="nb">unfold</span> observe <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe a) (_observe c)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe b) (_observe d)</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe c) x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe d) x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i x1 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_wbisimF E RX (eat_clo R) i (_observe a)
  (_observe b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chka7"><span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe a) (_observe c)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe b) (_observe d)</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe c) x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe d) x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i x1 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eat i (_observe a) <span class="nl">?x1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="eq-v-chka8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe a) (_observe c)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe b) (_observe d)</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe c) x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe d) x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i x1 x2</span></span></span><br></div><label class="goal-separator" for="eq-v-chka8"><hr></label><div class="goal-conclusion">it_eat i (_observe b) <span class="nl">?x2</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="eq-v-chka9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe a) (_observe c)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe b) (_observe d)</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe c) x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe d) x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i x1 x2</span></span></span><br></div><label class="goal-separator" for="eq-v-chka9"><hr></label><div class="goal-conclusion">it_eqF E RX (eat_clo R) i <span class="nl">?x1</span> <span class="nl">?x2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chkaa">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe a) (_observe c)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe b) (_observe d)</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe c) x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe d) x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i x1 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eat i (_observe a) <span class="nl">?x1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">etransitivity</span>; [ <span class="bp">exact</span> u | <span class="bp">exact</span> r1 ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chkab">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe a) (_observe c)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe b) (_observe d)</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe c) x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe d) x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i x1 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eat i (_observe b) <span class="nl">?x2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">etransitivity</span>; [ <span class="bp">exact</span> v | <span class="bp">exact</span> r2 ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chkac">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe a) (_observe c)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe b) (_observe d)</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe c) x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe d) x2</span></span></span><br><span><var>rr</var><span class="hyp-type"><b>: </b><span>it_eqF E RX R i x1 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RX (eat_clo R) i x1 x2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="eq-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="eq-v-chkad"><span class="nb">revert</span> rr; <span class="nb">apply</span> it_eqF_mon.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>rel·µ¢ X X</span></span></span><br><span><var>Transitive·µ¢0</var><span class="hyp-type"><b>: </b><span>Transitive·µ¢ RX</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E X) (itree E X)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>itree E X i</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe a) (_observe c)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe b) (_observe d)</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>itree&#39; E X i</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe c) x1</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>it_eat i (_observe d) x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R &lt;= eat_clo R</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">econstructor</span>; <span class="kp">try</span> <span class="nb">econstructor</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">wbisim_facts_hom</span>.</span></span></pre></div>
</div>
</div>
</div></body>
</html>
