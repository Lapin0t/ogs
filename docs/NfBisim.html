<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>NfBisim.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-windowed"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> OGS <span class="kn">Require Import</span> Prelude.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> OGS.Utils <span class="kn">Require Import</span> Rel.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="kn">From</span> OGS.Ctx <span class="kn">Require Import</span> All Ctx Covering Subst.
<span class="kn">From</span> OGS.ITree <span class="kn">Require Import</span> Event ITree Eq Delay.
<span class="kn">From</span> OGS.OGS <span class="kn">Require Import</span> Obs Game Machine.

<span class="kn">Section</span> <span class="nf">with_param</span>.
  <span class="kn">Context</span> `{CC : <span class="kp">context</span> T C} {CL : context_laws T C} (obs : obs_struct T C).
  <span class="kn">Context</span> {<span class="nv">val</span>} {<span class="nv">VM</span> : subst_monoid val} {<span class="nv">VML</span> : subst_monoid_laws val}.
  <span class="kn">Context</span> {<span class="nv">conf</span>} {<span class="nv">CM</span> : subst_module val conf} {<span class="nv">CML</span> : subst_module_laws val conf}.
  <span class="kn">Context</span> (<span class="nv">M</span> : machine val conf obs).

  <span class="c">(* NF bisimulation game *)</span>
  <span class="kn">Definition</span> <span class="nf">nfb_g</span> : game C (C √ó C)
    := {| g_client := {| g_move Œì := obs‚àô Œì ;
                         g_next Œì o := (Œì , dom o.(cut_r)) |} ;
          g_server := {| g_move &#39;(Œì , Œî) := obs‚àô Œî ;
                         g_next &#39;(Œì , Œî) o := Œì +‚ñ∂ dom o.(cut_r) |} |}.

  <span class="kn">Definition</span> <span class="nf">nfb_e</span> : event C C
    := e_of_g nfb_g.

  <span class="c">(* active NF bisimulation *)</span>
  <span class="kn">Definition</span> <span class="nf">nfb_act</span> := itree nfb_e ‚àÖ·µ¢.
  <span class="c">(* single-var passive NF bisimulation *)</span>
  <span class="kn">Definition</span> <span class="nf">nfb_pas‚ÇÅ</span> (<span class="nv">Œì</span> : C) (<span class="nv">x</span> : T) := <span class="kr">forall</span> <span class="nv">o</span> : obs x, nfb_act (Œì +‚ñ∂ dom o) .
  <span class="c">(* full passive NF bisimulation *)</span>
  <span class="kn">Definition</span> <span class="nf">nfb_pas</span> &#39;(Œì , Œî) := Œî =[nfb_pas‚ÇÅ]&gt; Œì .

  <span class="c">(* active NF bisimulation with cut-off *)</span>
  <span class="kn">Definition</span> <span class="nf">nfb_fin</span> <span class="nv">Œî</span> <span class="nv">Œì</span> := itree nfb_e (<span class="kr">fun</span> <span class="nv">_</span> =&gt; obs‚àô Œî) Œì.
  <span class="c">(* single-var passive NF bisimulation with cut-off *)</span>
  <span class="kn">Definition</span> <span class="nf">nfb_fin_pas‚ÇÅ</span> (<span class="nv">Œî</span> <span class="nv">Œì</span> : C) (<span class="nv">x</span> : T) := <span class="kr">forall</span> <span class="nv">o</span> : obs x, nfb_fin Œî (Œì +‚ñ∂ dom o) .

  <span class="c">(* renaming active NF bisim *)</span>
  <span class="kn">Definition</span> <span class="nf">nfb_ren</span> : <span class="kr">forall</span> <span class="nv">Œì1</span> <span class="nv">Œì2</span>, Œì1 ‚äÜ Œì2 -&gt; nfb_act Œì1 -&gt; nfb_act Œì2 :=
    <span class="kr">cofix</span> _nfb_ren _ _ œÅ t :=
      go <span class="kr">match</span> t.(_observe) <span class="kr">with</span>
         | RetF r =&gt; <span class="kr">match</span> r <span class="kr">with</span> <span class="kr">end</span>
         | TauF t =&gt; TauF (_nfb_ren _ _ œÅ t)
         | VisF q k =&gt;
            VisF (œÅ _ q.(cut_l) ‚ãÖ q.(cut_r) : nfb_e.(e_qry) _)
                 (<span class="kr">fun</span> <span class="nv">r</span> =&gt; _nfb_ren _ _ (r_shift (m_dom r) œÅ) (k r))
         <span class="kr">end</span> .

  <span class="kn">Definition</span> <span class="nf">nfb_var</span> : c_var ‚áí<span class="err">‚ÇÅ</span> nfb_pas‚ÇÅ
    := <span class="kr">cofix</span> _nfb_var Œì x i o :=
      Vis&#39; (r_cat_l i ‚ãÖ o : nfb_e.(e_qry) _)
           (<span class="kr">fun</span> <span class="nv">r</span> =&gt; _nfb_var _ _ (r_cat_r r.(cut_l)) r.(cut_r)) .

  <span class="c">(* renaming active NF bisim with cut-off *)</span>
  <span class="kn">Program Definition</span> <span class="nf">nfb_fin_ren</span> {<span class="nv">Œî</span>} : <span class="kr">forall</span> <span class="nv">Œì1</span> <span class="nv">Œì2</span>, Œì1 ‚äÜ Œì2 -&gt; nfb_fin Œî Œì1 -&gt; nfb_fin Œî Œì2 :=
    <span class="kr">cofix</span> _nfb_fin_ren _ _ œÅ t :=
      go <span class="kr">match</span> t.(_observe) <span class="kr">with</span>
         | RetF r =&gt; RetF r
         | TauF t =&gt; TauF (_nfb_fin_ren _ _ œÅ t)
         | VisF q k =&gt;
            VisF (œÅ _ q.(cut_l) ‚ãÖ q.(cut_r) : nfb_e.(e_qry) _)
                 (<span class="kr">fun</span> <span class="nv">r</span> =&gt; _nfb_fin_ren _ _ (r_shift (m_dom r) œÅ) (k r))
         <span class="kr">end</span> .

  <span class="c">(* tail-cutting of NF bisim *)</span>
  <span class="kn">Program Definition</span> <span class="nf">nfb_stop</span> : <span class="kr">forall</span> <span class="nv">Œî</span> <span class="nv">Œì</span>, nfb_act (Œî +‚ñ∂ Œì) -&gt; nfb_fin Œî Œì :=
    <span class="kr">cofix</span> _nfb_stop Œî _ t :=
      go <span class="kr">match</span> t.(_observe) <span class="kr">with</span>
         | RetF r =&gt; <span class="kr">match</span> r <span class="kr">with</span> <span class="kr">end</span>
         | TauF t =&gt; TauF (_nfb_stop _ _ t)
         | VisF q k =&gt; <span class="kp">ltac</span>:(<span class="bp">exact</span>
            <span class="kr">match</span> c_view_cat q.(cut_l) <span class="kr">with</span>
            | Vcat_l i =&gt; RetF (i ‚ãÖ q.(cut_r))
            | Vcat_r j =&gt; VisF (j ‚ãÖ q.(cut_r) : nfb_e.(e_qry) _)
                              (<span class="kr">fun</span> <span class="nv">r</span> =&gt; _nfb_stop _ _ (nfb_ren _ _ r_assoc_r (k r)))
            <span class="kr">end</span>)
          <span class="kr">end</span>.

  <span class="c">(* embed active NF-bisim with cut-off to active OGS strategy (generalized) *)</span>
  <span class="kn">Definition</span> <span class="nf">nfb_to_ogs_aux</span> {<span class="nv">Œî</span>}
    : <span class="kr">forall</span> <span class="nv">Œ¶</span> (<span class="nv">ks</span> : ‚Üì‚ÅªŒ¶ =[nfb_fin_pas‚ÇÅ Œî]&gt; ‚Üì‚Å∫Œ¶), nfb_fin Œî ‚Üì‚Å∫Œ¶ -&gt; ogs_act (obs:=obs) Œî Œ¶.
    <span class="kr">cofix</span> _nfb_to_ogs; <span class="nb">intros</span> Œ¶ ks t.
    <span class="nb">apply</span> go; <span class="nb">destruct</span> (t.(_observe)).
    + <span class="nb">apply</span> RetF; <span class="bp">exact</span> r.
    + <span class="nb">apply</span> TauF; <span class="bp">exact</span> (_nfb_to_ogs _ ks t0).
    + <span class="nb">unshelve</span> <span class="nb">eapply</span> VisF; [ <span class="bp">exact</span> q | ].
      <span class="nb">intro</span> r.
      <span class="nb">pose</span> (ks&#39; := [ ks , <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">j</span> <span class="nv">o</span> =&gt; k (j ‚ãÖ o) ]%asgn).
      <span class="nb">refine</span> (_nfb_to_ogs (Œ¶ ‚ñ∂‚Çì _ ‚ñ∂‚Çì _)%ctx _ (ks&#39; _ r.(cut_l) r.(cut_r))).
      <span class="nb">intros</span> ? i o.
      <span class="nb">refine</span> (nfb_fin_ren _ _ [ r_cat_l ·µ£‚äõ r_cat_l , r_cat_r ]%asgn (ks&#39; _ i o)).
  <span class="kn">Defined</span>.

  <span class="c">(* embed active NF-bisim with cut-off to active OGS strategy (initial state) *)</span>
  <span class="kn">Definition</span> <span class="nf">nfb_to_ogs</span> {<span class="nv">Œî</span> <span class="nv">Œì</span>} : nfb_fin Œî Œì -&gt; ogs_act Œî (‚àÖ ‚ñ∂‚Çì Œì)
    := <span class="kr">fun</span> <span class="nv">u</span> =&gt; nfb_to_ogs_aux (‚àÖ ‚ñ∂‚Çì Œì) ! (nfb_fin_ren _ _ r_cat_r u) .

  <span class="kn">Definition</span> <span class="nf">app_no_arg</span> {<span class="nv">Œì</span> <span class="nv">x</span>} (<span class="nv">v</span> : val Œì x) (<span class="nv">o</span> : obs x)
    : conf (Œì +‚ñ∂ dom o)
    := v ·µ•‚äõ·µ£ r_cat_l ‚äô o ‚¶ó r_emb r_cat_r ‚¶ò.

  <span class="c">(* language machine to NF-bisim *)</span>
  <span class="kn">Definition</span> <span class="nf">m_nfb_act</span> : conf ‚áí<span class="err">‚ÇÄ</span> nfb_act
    := <span class="kr">cofix</span> _m_nfb Œì c
      := subst_delay
           (<span class="kr">fun</span> <span class="nv">n</span> =&gt; Vis&#39; (nf_to_obs _ n : nfb_e.(e_qry) _)
                       (<span class="kr">fun</span> <span class="nv">o</span> =&gt; _m_nfb _ (app_no_arg (nf_args n _ o.(cut_l)) o.(cut_r)))) 
           (<span class="kp">eval</span> c).

  <span class="kn">Definition</span> <span class="nf">m_nfb_pas</span> : val ‚áí<span class="err">‚ÇÅ</span> nfb_pas‚ÇÅ
    := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">v</span> <span class="nv">o</span> =&gt; m_nfb_act _ (app_no_arg v o).
<span class="kn">End</span> <span class="nf">with_param</span>.</span></pre>
</div>
</div></body>
</html>
