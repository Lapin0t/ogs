<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>Delay Monad</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-windowed"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="delay-monad">
<h1 class="title">Delay Monad</h1>

<p>Instead of defining the delay monad from scratch, we construct it as a special case of
<tt class="docutils literal">itree</tt>, namely ones with an empty signature <tt class="docutils literal">‚àÖ‚Çë</tt> (disallowing <tt class="docutils literal">Vis</tt> nodes) and
indexed over the singleton type <tt class="docutils literal">T1</tt>.</p>
<p>The delay monad (Def. 9) is formalized as an itree over an empty signature: in the
absence of events, <tt class="docutils literal">Tau</tt> and <tt class="docutils literal">Ret</tt> are the only possible transitions.</p>
<p>Relevant definitions can be found:</p>
<ul class="simple">
<li>for the underlying itree datatype, in <a class="reference external" href="ITree.html">ITree/ITree.v</a>,</li>
<li>for the combinators, in <a class="reference external" href="Structure.html">ITree/Structure.v</a>,</li>
<li>for the (strong/weak) bisimilarity, in <a class="reference external" href="Eq.html">ITree/Eq.v</a>,</li>
<li>for guarded iteration (¬ß 6.2), in <a class="reference external" href="Guarded.html">ITree/Guarded.v</a>.</li>
</ul>
<pre class="alectryon-io highlight" id="delay"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">delay</span> (<span class="nv">X</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> := itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> =&gt; X) T1_0.</span></span></pre><p>Embedding <tt class="docutils literal">delay</tt> into itrees over arbitrary signatures.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">emb_delay</span> {<span class="nv">I</span>} {<span class="nv">E</span> : event I I} {<span class="nv">X</span> <span class="nv">i</span>} : delay X -&gt; itree E (X @ i) i :=
  <span class="kr">cofix</span> _emb_delay x :=
      go (<span class="kr">match</span> x.(_observe) <span class="kr">with</span>
         | RetF r =&gt; RetF (Fib r)
         | TauF t =&gt; TauF (_emb_delay t)
         | VisF e k =&gt; <span class="kr">match</span> e <span class="kr">with</span> <span class="kr">end</span>
         <span class="kr">end</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;&#39;RetD&#39; x&quot;</span> := (RetF (x : (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; _) T1_0)) (<span class="kn">at level</span> <span class="mi">40</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;&#39;TauD&#39; t&quot;</span> := (TauF (t : itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; _) T1_0)) (<span class="kn">at level</span> <span class="mi">40</span>).</span></span></pre><p>Specialization of the operations to the delay monad. Most of them are a bit cumbersome
since our definition of <tt class="docutils literal">itree</tt> is indexed, but <tt class="docutils literal">delay</tt> should not. As such there
is a bit of a dance around the singleton type <tt class="docutils literal">T1</tt> which is used as index. Too bad,
since Coq does not have typed conversion we don't get definitional eta-law for the unit
type...</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ret_delay</span> {<span class="nv">X</span>} : X -&gt; delay X := <span class="kr">fun</span> <span class="nv">x</span> =&gt; Ret&#39; x .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tau_delay</span> {<span class="nv">X</span>} : delay X -&gt; delay X :=
  <span class="kr">fun</span> <span class="nv">t</span> =&gt; go (TauF (t : itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0)) .</span></span></pre><p>Binding a delay computation in the context of an itree.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">bind_delay</span> {<span class="nv">I</span>} {<span class="nv">E</span> : event I I} {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">i</span>}
  : delay X -&gt; (X -&gt; itree E Y i) -&gt; itree E Y i
  := <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">f</span> =&gt; bind (emb_delay x) (<span class="kr">fun</span> <span class="nv">_</span> &#39;(Fib x) =&gt; f x) .</span></span></pre><p>Simpler definition of bind when the conclusion is again in delay.
See Not. 4.</p>
<pre class="alectryon-io highlight" id="delaybind"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">bind_delay&#39;</span> {<span class="nv">X</span> <span class="nv">Y</span>}
  : delay X -&gt; (X -&gt; delay Y) -&gt; delay Y
  := <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">f</span> =&gt; bind x (<span class="kr">fun</span> <span class="nv">&#39;T1_0</span> <span class="nv">y</span> =&gt; f y).</span></span></pre><p>Functorial action on maps.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fmap_delay</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">f</span> : X -&gt; Y) : delay X -&gt; delay Y :=
  fmap (<span class="kr">fun</span> <span class="nv">_</span> =&gt; f) T1_0 .</span></span></pre><p>Iteration operator.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">iter_delay</span> {<span class="nv">X</span> <span class="nv">Y</span>} : (X -&gt; delay (X + Y)) -&gt; X -&gt; delay Y :=
  <span class="kr">fun</span> <span class="nv">f</span> =&gt; iter (<span class="kr">fun</span> <span class="nv">&#39;T1_0</span> =&gt; f) T1_0 .</span></span></pre><p>Alternative to <tt class="docutils literal">bind_delay</tt>, written from scratch.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">subst_delay</span> {<span class="nv">I</span>} {<span class="nv">E</span> : event I I} {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">i</span>} (<span class="nv">f</span> : X -&gt; itree E Y i)
  : delay X -&gt; itree E Y i
  := <span class="kr">cofix</span> _subst_delay x := go <span class="kr">match</span> x.(_observe) <span class="kr">with</span>
                                | RetF r =&gt; (f r).(_observe)
                                | TauF t =&gt; TauF (_subst_delay t)
                                | VisF e k =&gt; <span class="kr">match</span> e <span class="kr">with</span> <span class="kr">end</span>
                                <span class="kr">end</span> .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="delay-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="delay-v-chk0">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">subst_delay_eq</span> {<span class="nv">I</span> <span class="nv">E</span> <span class="nv">X</span> <span class="nv">RX</span> <span class="nv">Y</span> <span class="nv">RY</span> <span class="nv">i</span>}
    : Proper ((RX ==&gt; it_eq RY (i:=i)) ==&gt; (it_eq (<span class="kr">fun</span> <span class="nv">_</span> =&gt; RX) (i:=T1_0) ==&gt; it_eq RY (i:=i)))
    (@subst_delay I E X Y i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>relation X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  ((RX ==&gt; it_eq RY (i:=i)) ==&gt;
   it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) (i:=T1_0) ==&gt;
   it_eq RY (i:=i)) subst_delay</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="delay-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="delay-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>relation X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  ((RX ==&gt; it_eq RY (i:=i)) ==&gt;
   it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) (i:=T1_0) ==&gt;
   it_eq RY (i:=i)) subst_delay</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="delay-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="delay-v-chk2"><span class="nb">intros</span> ? ? Hf; <span class="nb">unfold</span> it_eq <span class="nb">at</span> <span class="mi">2</span>; <span class="nb">unfold</span> respectful; coinduction R CIH; <span class="nb">intros</span> t1 t2 H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>relation X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X -&gt; itree E Y i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>(RX ==&gt; it_eq RY (i:=i))%signature x y</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0,
it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) x0 y0 -&gt;
it_eq_t E RY R i (subst_delay x x0) (subst_delay y y0)</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) t1 t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eq_bt E RY R i (subst_delay x t1)
  (subst_delay y t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="delay-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="delay-v-chk3"><span class="nb">apply</span> it_eq_step <span class="kr">in</span> H; <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="nb">unfold</span> observe <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>relation X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X -&gt; itree E Y i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>(RX ==&gt; it_eq RY (i:=i))%signature x y</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0,
it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) x0 y0 -&gt;
it_eq_t E RY R i (subst_delay x x0) (subst_delay y y0)</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>it_eqF ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX)
  (it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX)) T1_0 (_observe t1)
  (_observe t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  <span class="kr">match</span> _observe t1 <span class="kr">with</span>
  | RetF r =&gt; _observe (x r)
  | TauF t =&gt; TauF (subst_delay x t)
  | VisF e _ =&gt; <span class="kr">match</span> e <span class="kr">return</span> (itree&#39; E Y i) <span class="kr">with</span>
                <span class="kr">end</span>
  <span class="kr">end</span>
  <span class="kr">match</span> _observe t2 <span class="kr">with</span>
  | RetF r =&gt; _observe (y r)
  | TauF t =&gt; TauF (subst_delay y t)
  | VisF e _ =&gt; <span class="kr">match</span> e <span class="kr">return</span> (itree&#39; E Y i) <span class="kr">with</span>
                <span class="kr">end</span>
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="delay-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="delay-v-chk4"><span class="nb">remember</span> (_observe t1) <span class="kr">as</span> ot1; <span class="nb">clear</span> t1 Heqot1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>relation X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X -&gt; itree E Y i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>(RX ==&gt; it_eq RY (i:=i))%signature x y</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0,
it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) x0 y0 -&gt;
it_eq_t E RY R i (subst_delay x x0) (subst_delay y y0)</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0</span></span></span><br><span><var>ot1</var><span class="hyp-type"><b>: </b><span>itree&#39; ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>it_eqF ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX)
  (it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX)) T1_0 ot1
  (_observe t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  <span class="kr">match</span> ot1 <span class="kr">with</span>
  | RetF r =&gt; _observe (x r)
  | TauF t =&gt; TauF (subst_delay x t)
  | VisF e _ =&gt; <span class="kr">match</span> e <span class="kr">return</span> (itree&#39; E Y i) <span class="kr">with</span>
                <span class="kr">end</span>
  <span class="kr">end</span>
  <span class="kr">match</span> _observe t2 <span class="kr">with</span>
  | RetF r =&gt; _observe (y r)
  | TauF t =&gt; TauF (subst_delay y t)
  | VisF e _ =&gt; <span class="kr">match</span> e <span class="kr">return</span> (itree&#39; E Y i) <span class="kr">with</span>
                <span class="kr">end</span>
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="delay-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="delay-v-chk5"><span class="nb">remember</span> (_observe t2) <span class="kr">as</span> ot2; <span class="nb">clear</span> t2 Heqot2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>relation X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X -&gt; itree E Y i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>(RX ==&gt; it_eq RY (i:=i))%signature x y</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0,
it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) x0 y0 -&gt;
it_eq_t E RY R i (subst_delay x x0) (subst_delay y y0)</span></span></span><br><span><var>ot1, ot2</var><span class="hyp-type"><b>: </b><span>itree&#39; ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>it_eqF ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX)
  (it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX)) T1_0 ot1 ot2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  <span class="kr">match</span> ot1 <span class="kr">with</span>
  | RetF r =&gt; _observe (x r)
  | TauF t =&gt; TauF (subst_delay x t)
  | VisF e _ =&gt; <span class="kr">match</span> e <span class="kr">return</span> (itree&#39; E Y i) <span class="kr">with</span>
                <span class="kr">end</span>
  <span class="kr">end</span>
  <span class="kr">match</span> ot2 <span class="kr">with</span>
  | RetF r =&gt; _observe (y r)
  | TauF t =&gt; TauF (subst_delay y t)
  | VisF e _ =&gt; <span class="kr">match</span> e <span class="kr">return</span> (itree&#39; E Y i) <span class="kr">with</span>
                <span class="kr">end</span>
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="delay-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="delay-v-chk6">dependent elimination H; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>relation X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X -&gt; itree E Y i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>(RX ==&gt; it_eq RY (i:=i))%signature x y</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0,
it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) x0 y0 -&gt;
it_eq_t E RY R i (subst_delay x x0) (subst_delay y y0)</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0</span></span></span><br><span><var>r_rel</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) T1_0 r1 r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i (_observe (x r1))
  (_observe (y r2))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="delay-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>relation X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X -&gt; itree E Y i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>(RX ==&gt; it_eq RY (i:=i))%signature x y</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0,
it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) x0 y0 -&gt;
it_eq_t E RY R i (subst_delay x x0)
  (subst_delay y y0)</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0</span></span></span><br><span><var>t_rel</var><span class="hyp-type"><b>: </b><span>it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) t1 t2</span></span></span><br></div><label class="goal-separator" for="delay-v-chk7"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  (TauF (subst_delay x t1)) 
  (TauF (subst_delay y t2))</div></blockquote><input class="alectryon-extra-goal-toggle" id="delay-v-chk8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>relation X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X -&gt; itree E Y i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>(RX ==&gt; it_eq RY (i:=i))%signature x y</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0,
it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) x0 y0 -&gt;
it_eq_t E RY R i (subst_delay x x0)
  (subst_delay y y0)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry T1_0</span></span></span><br><span><var>k1, k2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : e_rsp q,
itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) (e_nxt x)</span></span></span><br><span><var>k_rel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q,
it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) (k1 r) (k2 r)</span></span></span><br></div><label class="goal-separator" for="delay-v-chk8"><hr></label><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  <span class="kr">match</span> q <span class="kr">return</span> (itree&#39; E Y i) <span class="kr">with</span>
  <span class="kr">end</span> <span class="kr">match</span> q <span class="kr">return</span> (itree&#39; E Y i) <span class="kr">with</span>
      <span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="delay-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="delay-v-chk9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>relation X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X -&gt; itree E Y i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>(RX ==&gt; it_eq RY (i:=i))%signature x y</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0,
it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) x0 y0 -&gt;
it_eq_t E RY R i (subst_delay x x0)
  (subst_delay y y0)</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0</span></span></span><br><span><var>r_rel</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) T1_0 r1 r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i 
  (_observe (x r1)) (_observe (y r2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="delay-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="delay-v-chka"><span class="nb">eapply</span> it_eqF_mon; [ <span class="nb">apply</span> gfp_t | ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>relation X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X -&gt; itree E Y i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>(RX ==&gt; it_eq RY (i:=i))%signature x y</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0,
it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) x0 y0 -&gt;
it_eq_t E RY R i (subst_delay x x0)
  (subst_delay y y0)</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0</span></span></span><br><span><var>r_rel</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) T1_0 r1 r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (gfp (it_eq_map E RY)) i 
  (_observe (x r1)) (_observe (y r2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">specialize</span> (Hf _ _ r_rel); <span class="nb">apply</span> it_eq_step <span class="kr">in</span> Hf; <span class="bp">exact</span> Hf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="delay-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="delay-v-chkb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>relation X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X -&gt; itree E Y i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>(RX ==&gt; it_eq RY (i:=i))%signature x y</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0,
it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) x0 y0 -&gt;
it_eq_t E RY R i (subst_delay x x0)
  (subst_delay y y0)</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0</span></span></span><br><span><var>t_rel</var><span class="hyp-type"><b>: </b><span>it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) t1 t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  (TauF (subst_delay x t1)) 
  (TauF (subst_delay y t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">econstructor</span>; <span class="bp">now</span> <span class="nb">apply</span> CIH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="delay-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="delay-v-chkc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>I</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>event I I</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>RX</var><span class="hyp-type"><b>: </b><span>relation X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>psh I</span></span></span><br><span><var>RY</var><span class="hyp-type"><b>: </b><span>rel·µ¢ Y Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>I</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X -&gt; itree E Y i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>(RX ==&gt; it_eq RY (i:=i))%signature x y</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>rel·µ¢ (itree E Y) (itree E Y)</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) T1_0,
it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) x0 y0 -&gt;
it_eq_t E RY R i (subst_delay x x0)
  (subst_delay y y0)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e_qry T1_0</span></span></span><br><span><var>k1, k2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : e_rsp q,
itree ‚àÖ‚Çë (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; X) (e_nxt x)</span></span></span><br><span><var>k_rel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">r</span> : e_rsp q,
it_eq (<span class="kr">fun</span> <span class="nv">_</span> : T1 =&gt; RX) (k1 r) (k2 r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">it_eqF E RY (it_eq_t E RY R) i
  <span class="kr">match</span> q <span class="kr">return</span> (itree&#39; E Y i) <span class="kr">with</span>
  <span class="kr">end</span> <span class="kr">match</span> q <span class="kr">return</span> (itree&#39; E Y i) <span class="kr">with</span>
      <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre>
</div>
</div></body>
</html>
