<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>Substitution structures (§ 4.1)</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-windowed"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+↑</kbd> <kbd>Ctrl+↓</kbd> to navigate, <kbd>Ctrl+🖱️</kbd> to focus. On Mac, use <kbd>⌘</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="substitution-structures-4-1">
<h1 class="title">Substitution structures (§ 4.1)</h1>

<p>In this file we axiomatize what it means for a family to support substitution.</p>
<div class="section" id="substitution-monoid-def-7">
<h1>Substitution Monoid (Def. 7)</h1>
<p>The specification of an evaluator will be separated in several steps. First we will ask
for a family of values, i.e. objects that can be substituted for variables. We formalize
well-typed well-scoped substitutions in the monoidal style of Fiore et al and Allais et al.
Here we are generic over a notion of context, treating lists and DeBruijn indices in the
usual well-typed well-scoped style, but also other similar notions. See
<a class="reference external" href="Abstract.html">Ctx/Abstract.v</a> for more background on notions of variables and contexts
and for the categorical presentation of substitution.</p>
<pre class="alectryon-io highlight" id="submonoid"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">subst_monoid</span> `{CC : <span class="kp">context</span> T C} (val : Fam₁ T C) := {
  v_var : c_var ⇒<span class="err">₁</span> val ;
  v_sub : val ⇒<span class="err">₁</span> ⟦ val , val ⟧<span class="err">₁</span> ;
}.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;v ᵥ⊛ a&quot;</span> := (v_sub v a%asgn) (<span class="kn">at level</span> <span class="mi">30</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">a_id</span> := v_var.</span></span></pre><p>By pointwise lifting of substitution we can define composition of assignments.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a_comp</span> `{subst_monoid T C val} {Γ1 Γ2 Γ3}
  : Γ1 =[val]&gt; Γ2 -&gt; Γ2 =[val]&gt; Γ3 -&gt; Γ1 =[val]&gt; Γ3
  := <span class="kr">fun</span> <span class="nv">u</span> <span class="nv">v</span> <span class="nv">_</span> <span class="nv">i</span> =&gt; u _ i ᵥ⊛ v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Infix</span> <span class="s2">&quot;⊛&quot;</span> := a_comp (<span class="kn">at level</span> <span class="mi">14</span>) : asgn_scope.</span></span></pre><p>The laws for monoids and modules are pretty straightforward. A specificity is that
assignments are represented by functions from variables to values, as such their
well-behaved equality is pointwise equality and we require substitution to respect it.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">subst_monoid_laws</span> `{CC : <span class="kp">context</span> T C} (val : Fam₁ T C) {VM : subst_monoid val} := {
  v_sub_proper :: Proper (<span class="kr">∀</span><span class="nv">ₕ</span> <span class="nv">Γ</span>, <span class="kr">∀</span><span class="nv">ₕ</span> <span class="nv">_</span>, eq ==&gt; <span class="kr">∀</span><span class="nv">ₕ</span> <span class="nv">Δ</span>, asgn_eq Γ Δ ==&gt; eq) v_sub ;
  v_sub_var {Γ1 Γ2 x} (i : Γ1 ∋ x) (p : Γ1 =[val]&gt; Γ2)
    : v_var i ᵥ⊛ p = p _ i ;
  v_var_sub {Γ x} (v : val Γ x)
    : v ᵥ⊛ a_id = v ;
  v_sub_sub {Γ1 Γ2 Γ3 x} (v : val Γ1 x) (a : Γ1 =[val]&gt; Γ2) (b : Γ2 =[val]&gt; Γ3)
   : v ᵥ⊛ (a ⊛ b) = (v ᵥ⊛ a) ᵥ⊛ b ;
} .</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk0">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">v_sub_proper_a</span> `{subst_monoid_laws T C val}
          {Γ1 Γ2 x} {v : val Γ1 x} : Proper (asgn_eq Γ1 Γ2 ==&gt; eq) (v_sub v).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val Γ1 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (asgn_eq Γ1 Γ2 ==&gt; eq) (v_sub v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val Γ1 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (asgn_eq Γ1 Γ2 ==&gt; eq) (v_sub v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> v_sub_proper.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="substitution-module-def-8">
<h1>Substitution Module (Def. 8)</h1>
<p>Next, we ask for a module over the monoid of values, to represent the configurations
of the machine.</p>
<pre class="alectryon-io highlight" id="submodule"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">subst_module</span> `{CC : <span class="kp">context</span> T C} (val : Fam₁ T C) (conf : Fam₀ T C) := {
  c_sub : conf ⇒<span class="err">₀</span> ⟦ val , conf ⟧<span class="err">₀</span> ;
}.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;c ₜ⊛ a&quot;</span> := (c_sub c a%asgn) (<span class="kn">at level</span> <span class="mi">30</span>).</span></span></pre><p>Again the laws should not be surprising.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">subst_module_laws</span> `{CC : <span class="kp">context</span> T C} (val : Fam₁ T C) (conf : Fam₀ T C)
      {VM : subst_monoid val} {CM : subst_module val conf} := {
  c_sub_proper :: Proper (<span class="kr">∀</span><span class="nv">ₕ</span> <span class="nv">Γ</span>, eq ==&gt; <span class="kr">∀</span><span class="nv">ₕ</span> <span class="nv">Δ</span>, asgn_eq Γ Δ ==&gt; eq) c_sub ;
  c_var_sub {Γ} (c : conf Γ) : c ₜ⊛ a_id = c ;
  c_sub_sub {Γ1 Γ2 Γ3} (c : conf Γ1) (a : Γ1 =[val]&gt; Γ2) (b : Γ2 =[val]&gt; Γ3)
    : c ₜ⊛ (a ⊛ b) = (c ₜ⊛ a) ₜ⊛ b ;
} .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk2">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">c_sub_proper_a</span> `{subst_module_laws T C val conf}
          {Γ1 Γ2 c} : Proper (asgn_eq Γ1 Γ2 ==&gt; eq) (c_sub c).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>conf</var><span class="hyp-type"><b>: </b><span>Fam₀ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>CM</var><span class="hyp-type"><b>: </b><span>subst_module val conf</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>subst_module_laws val conf</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>conf Γ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (asgn_eq Γ1 Γ2 ==&gt; eq) (c_sub c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>conf</var><span class="hyp-type"><b>: </b><span>Fam₀ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>CM</var><span class="hyp-type"><b>: </b><span>subst_module val conf</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>subst_module_laws val conf</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>conf Γ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (asgn_eq Γ1 Γ2 ==&gt; eq) (c_sub c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> c_sub_proper.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Now that we know that our families have a substitution operation and variables, we
can readily derive a renaming operation. While we could have axiomatized it, together with
its compatibility with substitution, allowing for possibly more efficient implementations,
we prefer simplicity and work with this generic implementation in terms of substitution.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">renaming</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{CC : <span class="kp">context</span> T C} {val : Fam₁ T C} {conf : Fam₀ T C}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">VM</span> : subst_monoid val} {<span class="nv">VML</span> : subst_monoid_laws val}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">CM</span> : subst_module val conf} {<span class="nv">CML</span> : subst_module_laws val conf}.</span></span></pre><p>By post-composing with the substitution identity, we can embed renamings into assignments.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">r_emb</span> {<span class="nv">Γ</span> <span class="nv">Δ</span>} (<span class="nv">r</span> : Γ ⊆ Δ) : Γ =[val]&gt; Δ
    := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">i</span> =&gt; v_var (r _ i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Arguments</span> r_emb {_ _} _ _ /.</span></span></pre><p>Renaming is now simply a matter of substituting by the embedded renaming.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">v_ren</span> : val ⇒<span class="err">₁</span> ⟦ c_var , val ⟧<span class="err">₁</span>
    := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">v</span> <span class="nv">_</span> <span class="nv">r</span> =&gt; v ᵥ⊛ r_emb r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c_ren</span> : conf ⇒<span class="err">₀</span> ⟦ c_var , conf ⟧<span class="err">₀</span>
    := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">c</span> <span class="nv">_</span> <span class="nv">r</span> =&gt; c ₜ⊛ r_emb r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Arguments</span> v_ren [Γ x] v [Δ] r /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Arguments</span> c_ren [Γ] v [Δ] r /.</span></span></pre><p>Finally we can rename assignments on the right.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a_ren_r</span> {<span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">Γ3</span>} : Γ1 =[val]&gt; Γ2 -&gt; Γ2 ⊆ Γ3 -&gt; Γ1 =[val]&gt; Γ3
    := <span class="kr">fun</span> <span class="nv">a</span> <span class="nv">r</span> =&gt; (a ⊛ (r_emb r))%asgn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Arguments</span> a_ren_r _ _ _ _ _ _ /.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">renaming</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;v ᵥ⊛ᵣ r&quot;</span> := (v_ren v r%asgn) (<span class="kn">at level</span> <span class="mi">14</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;c ₜ⊛ᵣ r&quot;</span> := (c_ren c r%asgn) (<span class="kn">at level</span> <span class="mi">14</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;a ⊛ᵣ r&quot;</span> := (a_ren_r a r) (<span class="kn">at level</span> <span class="mi">14</span>) : asgn_scope.</span></span></pre><p>Something which we have absolutely pushed under the rug in the paper is a couple more
mild technical hypotheses on the substitution monoid of values: since in the
<a class="reference external" href="CompGuarded.html">eventual guardedness proof</a> we need to case split on whether
or not a value is a variable, we need to ask for that to be possible! As such,
we need the following additional assumptions:</p>
<ul class="simple">
<li><tt class="docutils literal">v_var</tt> has decidable fibers</li>
<li><tt class="docutils literal">v_var</tt> is injective</li>
<li>the fibers of <tt class="docutils literal">v_var</tt> pull back along renamings</li>
</ul>
<p>These assumptions are named &quot;clear-cut&quot; in the paper (Def. 27).</p>
<p>We first define the fibers of <tt class="docutils literal">v_var</tt>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">is_var</span> `{VM : subst_monoid T C val} {Γ x} : val Γ x -&gt; <span class="kt">Type</span> :=
| Vvar (i : Γ ∋ x) : <span class="nb">is_var</span> (v_var i)
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">is_var_get</span> `{VM : subst_monoid T C val} {Γ x} {v : val Γ x} : <span class="nb">is_var</span> v -&gt; Γ ∋ x :=
  is_var_get (Vvar i) := i .</span></span></pre><p>Which are obviously stable under renamings.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk4"><span class="kn">Lemma</span> <span class="nf">ren_is_var</span> `{VM : subst_monoid_laws T C val} {Γ1 Γ2} (r : Γ1 ⊆ Γ2) {x} {v : val Γ1 x} 
      : <span class="nb">is_var</span> v -&gt; <span class="nb">is_var</span> (v ᵥ⊛ᵣ r).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM0</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Γ1 ⊆ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val Γ1 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">is_var</span> v -&gt; <span class="nb">is_var</span> (v ᵥ⊛ᵣ r)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM0</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Γ1 ⊆ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val Γ1 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">is_var</span> v -&gt; <span class="nb">is_var</span> (v ᵥ⊛ᵣ r)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk6"><span class="nb">intro</span> p; dependent elimination p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM0</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Γ1 ⊆ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Γ1 ∋ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">is_var</span> (a_id i ᵥ⊛ᵣ r)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk7"><span class="nb">cbn</span>; <span class="nb">rewrite</span> v_sub_var.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM0</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Γ1 ⊆ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Γ1 ∋ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">is_var</span> (r_emb r x i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">econstructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>At last we define our last assumptions on variables (Def. 28).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">var_assumptions</span> `{CC : <span class="kp">context</span> T C} (val : Fam₁ T C) {VM : subst_monoid val} := {
  v_var_inj {Γ x} : injective (@v_var _ _ _ _ _ Γ x) ;
  is_var_dec {Γ x} (v : val Γ x) : decidable (<span class="nb">is_var</span> v) ;
  is_var_ren {Γ1 Γ2 x} (v : val Γ1 x) (r : Γ1 ⊆ Γ2) : <span class="nb">is_var</span> (v ᵥ⊛ᵣ r) -&gt; <span class="nb">is_var</span> v ;
}.</span></span></pre><p>Here we derive a couple helpers around these new assumptions.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">variables</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{CC : <span class="kp">context</span> T C} {val : Fam₁ T C}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">VM</span> : subst_monoid val} {<span class="nv">VML</span> : subst_monoid_laws val}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">VA</span> : var_assumptions val}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk8"><span class="kn">Lemma</span> <span class="nf">is_var_irr</span> {<span class="nv">Γ</span> <span class="nv">x</span>} {<span class="nv">v</span> : val Γ x} (<span class="nv">p</span> <span class="nv">q</span> : <span class="nb">is_var</span> v) : p = q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>VA</var><span class="hyp-type"><b>: </b><span>var_assumptions val</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val Γ x</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span><span class="nb">is_var</span> v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>VA</var><span class="hyp-type"><b>: </b><span>var_assumptions val</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val Γ x</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span><span class="nb">is_var</span> v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chka"><span class="nb">refine</span> (<span class="kr">match</span> p <span class="kr">as</span> i <span class="kr">in</span> <span class="nb">is_var</span> v
            <span class="kr">return</span> <span class="kr">forall</span> <span class="nv">w</span> (<span class="nv">H</span> : w = v) (<span class="nv">q</span> : <span class="nb">is_var</span> w), i = rew [<span class="nb">is_var</span>] H <span class="kr">in</span> q
            <span class="kr">with</span> Vvar i =&gt; <span class="kr">fun</span> <span class="nv">w</span> <span class="nv">H</span> <span class="nv">q</span> =&gt; _
            <span class="kr">end</span> v eq_refl q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>VA</var><span class="hyp-type"><b>: </b><span>var_assumptions val</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val Γ x</span></span></span><br><span><var>p, q0</var><span class="hyp-type"><b>: </b><span><span class="nb">is_var</span> v</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Γ ∋ x</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>val Γ x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>w = a_id i</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="nb">is_var</span> w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vvar i = rew [<span class="nb">is_var</span>] H <span class="kr">in</span> q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chkb">dependent elimination q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>VA</var><span class="hyp-type"><b>: </b><span>var_assumptions val</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val Γ x</span></span></span><br><span><var>p, q0</var><span class="hyp-type"><b>: </b><span><span class="nb">is_var</span> v</span></span></span><br><span><var>i, i0</var><span class="hyp-type"><b>: </b><span>Γ ∋ x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>a_id i0 = a_id i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vvar i = rew [<span class="nb">is_var</span>] H <span class="kr">in</span> Vvar i0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chkc"><span class="nb">pose proof</span> (v_var_inj _ _ H) <span class="kr">as</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>VA</var><span class="hyp-type"><b>: </b><span>var_assumptions val</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val Γ x</span></span></span><br><span><var>p, q0</var><span class="hyp-type"><b>: </b><span><span class="nb">is_var</span> v</span></span></span><br><span><var>i, i0</var><span class="hyp-type"><b>: </b><span>Γ ∋ x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>a_id i0 = a_id i</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>i0 = i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vvar i = rew [<span class="nb">is_var</span>] H <span class="kr">in</span> Vvar i0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> dependent elimination H&#39;; dependent elimination H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chkd"><span class="kn">Lemma</span> <span class="nf">is_var_simpl</span> {<span class="nv">Γ</span> <span class="nv">x</span>} {<span class="nv">i</span> : Γ ∋ x} (<span class="nv">p</span> : <span class="nb">is_var</span> (v_var i)) : p = Vvar i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>VA</var><span class="hyp-type"><b>: </b><span>var_assumptions val</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Γ ∋ x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="nb">is_var</span> (a_id i)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = Vvar i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>VA</var><span class="hyp-type"><b>: </b><span>var_assumptions val</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Γ ∋ x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="nb">is_var</span> (a_id i)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = Vvar i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> is_var_irr.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">is_var_ren_view</span> {<span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">x</span>}
    (<span class="nv">v</span> : val Γ1 x) (<span class="nv">r</span> : Γ1 ⊆ Γ2) : <span class="nb">is_var</span> (v ᵥ⊛ᵣ r) -&gt; <span class="kt">Type</span> :=
  | Vvren (H : <span class="nb">is_var</span> v) : is_var_ren_view v r (ren_is_var r H) .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chkf"><span class="kn">Lemma</span> <span class="nf">view_is_var_ren</span> {<span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">x</span>} (<span class="nv">v</span> : val Γ1 x) (<span class="nv">r</span> : Γ1 ⊆ Γ2) (<span class="nv">H</span> : <span class="nb">is_var</span> (v ᵥ⊛ᵣ r))
    : is_var_ren_view v r H .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>VA</var><span class="hyp-type"><b>: </b><span>var_assumptions val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val Γ1 x</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Γ1 ⊆ Γ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">is_var</span> (v ᵥ⊛ᵣ r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_var_ren_view v r H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>VA</var><span class="hyp-type"><b>: </b><span>var_assumptions val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val Γ1 x</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Γ1 ⊆ Γ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">is_var</span> (v ᵥ⊛ᵣ r)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_var_ren_view v r H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> (is_var_irr H (ren_is_var r (is_var_ren v r H))); <span class="nb">econstructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk11"><span class="kn">Lemma</span> <span class="nf">ren_is_var_get</span> {<span class="nv">Γ1</span> <span class="nv">Γ2</span>} {<span class="nv">r</span> : Γ1 ⊆ Γ2}
    {<span class="nv">x</span> <span class="nv">v</span>} (<span class="nv">H</span> : <span class="nb">is_var</span> v) : is_var_get (ren_is_var r H) = r x (is_var_get H) .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>VA</var><span class="hyp-type"><b>: </b><span>var_assumptions val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Γ1 ⊆ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val Γ1 x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">is_var</span> v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_var_get (ren_is_var r H) = r x (is_var_get H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>VA</var><span class="hyp-type"><b>: </b><span>var_assumptions val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Γ1 ⊆ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val Γ1 x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">is_var</span> v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_var_get (ren_is_var r H) = r x (is_var_get H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk13"><span class="nb">destruct</span> H; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>VA</var><span class="hyp-type"><b>: </b><span>var_assumptions val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Γ1 ⊆ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Γ1 ∋ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_var_get (ren_is_var r (Vvar i)) = r x i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk14"><span class="nb">generalize</span> (ren_is_var r (Vvar i)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>VA</var><span class="hyp-type"><b>: </b><span>var_assumptions val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Γ1 ⊆ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Γ1 ∋ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i0</span> : <span class="nb">is_var</span> (a_id i ᵥ⊛ᵣ r),
is_var_get i0 = r x i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk15"><span class="nb">unfold</span> v_ren; <span class="nb">rewrite</span> v_sub_var; <span class="nb">unfold</span> r_emb; <span class="nb">intro</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>VA</var><span class="hyp-type"><b>: </b><span>var_assumptions val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Γ1 ⊆ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Γ1 ∋ x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">is_var</span> (a_id (r x i))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_var_get H = r x i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (is_var_irr H (Vvar (r _ i))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk16"><span class="kn">Lemma</span> <span class="nf">is_var_get_eq</span> {<span class="nv">Γ</span> <span class="nv">x</span>} {<span class="nv">v</span> : val Γ x} (<span class="nv">H</span> : <span class="nb">is_var</span> v) : v = v_var (is_var_get H) .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>VA</var><span class="hyp-type"><b>: </b><span>var_assumptions val</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val Γ x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">is_var</span> v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">v = a_id (is_var_get H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>VA</var><span class="hyp-type"><b>: </b><span>var_assumptions val</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val Γ x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">is_var</span> v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">v = a_id (is_var_get H)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">destruct</span> H.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">variables</span>.</span></span></pre><p>Finally we end with a couple derived property on assignments.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">properties</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">T</span> <span class="nv">C</span>} {<span class="nv">CC</span> : <span class="kp">context</span> T C} (<span class="nv">val</span> : Fam₁ T C).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">VM</span> : subst_monoid val} {<span class="nv">VML</span> : subst_monoid_laws val}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk18">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">a_comp_proper</span> {<span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">Γ3</span>} :
    Proper (asgn_eq Γ1 Γ2 ==&gt; asgn_eq Γ2 Γ3 ==&gt; asgn_eq Γ1 Γ3) a_comp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2, Γ3</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  (asgn_eq Γ1 Γ2 ==&gt; asgn_eq Γ2 Γ3 ==&gt; asgn_eq Γ1 Γ3)
  a_comp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk19"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2, Γ3</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  (asgn_eq Γ1 Γ2 ==&gt; asgn_eq Γ2 Γ3 ==&gt; asgn_eq Γ1 Γ3)
  a_comp</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ?? H1 ?? H2 ??; <span class="nb">cbn</span>; <span class="bp">now</span> <span class="nb">rewrite</span> H1, H2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk1a">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">r_emb_proper</span> {<span class="nv">Γ1</span> <span class="nv">Γ2</span>} : Proper (asgn_eq Γ1 Γ2 ==&gt; asgn_eq Γ1 Γ2) r_emb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (asgn_eq Γ1 Γ2 ==&gt; asgn_eq Γ1 Γ2) r_emb</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk1b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (asgn_eq Γ1 Γ2 ==&gt; asgn_eq Γ1 Γ2) r_emb</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ?? H ??; <span class="nb">cbn</span>; <span class="bp">now</span> <span class="nb">rewrite</span> H.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk1c">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">a_ren_proper</span> {<span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">Γ3</span>} :
    Proper (asgn_eq Γ1 Γ2 ==&gt; asgn_eq Γ2 Γ3 ==&gt; asgn_eq Γ1 Γ3) a_ren_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2, Γ3</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  (asgn_eq Γ1 Γ2 ==&gt; asgn_eq Γ2 Γ3 ==&gt; asgn_eq Γ1 Γ3)
  a_ren_r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk1d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2, Γ3</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  (asgn_eq Γ1 Γ2 ==&gt; asgn_eq Γ2 Γ3 ==&gt; asgn_eq Γ1 Γ3)
  a_ren_r</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ?? H1 ?? H2 ??; <span class="nb">cbn</span>; <span class="bp">now</span> <span class="nb">rewrite</span> H1, H2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk1e"><span class="kn">Lemma</span> <span class="nf">a_ren_r_simpl</span> {<span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">Γ3</span>} (<span class="nv">r</span> : Γ1 ⊆ Γ2) (<span class="nv">a</span> : Γ2 =[val]&gt; Γ3) 
        : r_emb r ⊛ a ≡ₐ r ᵣ⊛ a .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2, Γ3</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Γ1 ⊆ Γ2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Γ2 =[ val ]&gt; Γ3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r_emb r ⊛ a ≡ₐ r ᵣ⊛ a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk1f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2, Γ3</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Γ1 ⊆ Γ2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Γ2 =[ val ]&gt; Γ3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r_emb r ⊛ a ≡ₐ r ᵣ⊛ a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ??; <span class="nb">cbn</span>; <span class="bp">now</span> <span class="nb">rewrite</span> v_sub_var.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk20"><span class="kn">Lemma</span> <span class="nf">a_ren_id</span> {<span class="nv">Γ</span>} : r_emb r_id ≡ₐ a_id (Γ:=Γ) .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r_emb r_id ≡ₐ a_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r_emb r_id ≡ₐ a_id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk22"><span class="kn">Lemma</span> <span class="nf">a_comp_ren</span> {<span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">Γ3</span> <span class="nv">Γ4</span>} (<span class="nv">a</span> : Γ1 =[val]&gt; Γ2) (<span class="nv">b</span> : Γ2 =[val]&gt; Γ3) (<span class="nv">r</span> : Γ3 ⊆ Γ4)
    : (a ⊛ b) ⊛ᵣ r ≡ₐ a ⊛ (b ⊛ᵣ r).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2, Γ3, Γ4</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Γ1 =[ val ]&gt; Γ2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Γ2 =[ val ]&gt; Γ3</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Γ3 ⊆ Γ4</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a ⊛ b) ⊛ᵣ r ≡ₐ a ⊛ (b ⊛ᵣ r)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk23"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2, Γ3, Γ4</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Γ1 =[ val ]&gt; Γ2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Γ2 =[ val ]&gt; Γ3</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Γ3 ⊆ Γ4</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a ⊛ b) ⊛ᵣ r ≡ₐ a ⊛ (b ⊛ᵣ r)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ??; <span class="nb">cbn</span>; <span class="bp">now</span> <span class="nb">rewrite</span> &lt;-v_sub_sub.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk24"><span class="kn">Lemma</span> <span class="nf">a_ren_comp</span> {<span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">Γ3</span> <span class="nv">Γ4</span>} (<span class="nv">a</span> : Γ1 =[val]&gt; Γ2) (<span class="nv">r</span> : Γ2 ⊆ Γ3) (<span class="nv">b</span> : Γ3 =[val]&gt; Γ4)
    : (a ⊛ᵣ r) ⊛ b ≡ₐ a ⊛ (r ᵣ⊛ b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2, Γ3, Γ4</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Γ1 =[ val ]&gt; Γ2</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Γ2 ⊆ Γ3</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Γ3 =[ val ]&gt; Γ4</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a ⊛ᵣ r) ⊛ b ≡ₐ a ⊛ (r ᵣ⊛ b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk25"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2, Γ3, Γ4</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Γ1 =[ val ]&gt; Γ2</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Γ2 ⊆ Γ3</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Γ3 =[ val ]&gt; Γ4</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a ⊛ᵣ r) ⊛ b ≡ₐ a ⊛ (r ᵣ⊛ b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ??; <span class="nb">cbn</span>; <span class="bp">now</span> <span class="nb">rewrite</span> &lt;-v_sub_sub, a_ren_r_simpl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk26"><span class="kn">Lemma</span> <span class="nf">a_comp_comp</span> {<span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">Γ3</span> <span class="nv">Γ4</span>} (<span class="nv">a</span> : Γ1 =[val]&gt; Γ2) (<span class="nv">b</span> : Γ2 =[val]&gt; Γ3)
                    (<span class="nv">c</span> : Γ3 =[val]&gt; Γ4)
    : (a ⊛ b) ⊛ c ≡ₐ a ⊛ (b ⊛ c).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2, Γ3, Γ4</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Γ1 =[ val ]&gt; Γ2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Γ2 =[ val ]&gt; Γ3</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Γ3 =[ val ]&gt; Γ4</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a ⊛ b) ⊛ c ≡ₐ a ⊛ (b ⊛ c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk27"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2, Γ3, Γ4</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Γ1 =[ val ]&gt; Γ2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Γ2 =[ val ]&gt; Γ3</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Γ3 =[ val ]&gt; Γ4</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a ⊛ b) ⊛ c ≡ₐ a ⊛ (b ⊛ c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ??; <span class="nb">cbn</span>; <span class="bp">now</span> <span class="nb">rewrite</span> v_sub_sub.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk28"><span class="kn">Lemma</span> <span class="nf">a_comp_id</span> {<span class="nv">Γ1</span> <span class="nv">Γ2</span>} (<span class="nv">a</span> : Γ1 =[val]&gt; Γ2) : a ⊛ a_id ≡ₐ a .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Γ1 =[ val ]&gt; Γ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ⊛ a_id ≡ₐ a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk29"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Γ1 =[ val ]&gt; Γ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ⊛ a_id ≡ₐ a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ??; <span class="nb">cbn</span>; <span class="bp">now</span> <span class="nb">rewrite</span> v_var_sub.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk2a"><span class="kn">Lemma</span> <span class="nf">a_id_comp</span> {<span class="nv">Γ1</span> <span class="nv">Γ2</span>} (<span class="nv">a</span> : Γ1 =[val]&gt; Γ2) : a_id ⊛ a ≡ₐ a .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Γ1 =[ val ]&gt; Γ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a_id ⊛ a ≡ₐ a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk2b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Γ1 =[ val ]&gt; Γ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a_id ⊛ a ≡ₐ a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="subst-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="subst-v-chk2c"><span class="nb">intros</span> ??; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>VM</var><span class="hyp-type"><b>: </b><span>subst_monoid val</span></span></span><br><span><var>VML</var><span class="hyp-type"><b>: </b><span>subst_monoid_laws val</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Γ1 =[ val ]&gt; Γ2</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>Γ1 ∋ a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a_id a1 ᵥ⊛ a = a a0 a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> v_sub_var.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">properties</span>.</span></span></pre></div>
</div>
</div></body>
</html>
