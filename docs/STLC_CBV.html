<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>A Minimal Example: Call-by-Value Simply Typed Lambda Calculus</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-windowed"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+â†‘</kbd> <kbd>Ctrl+â†“</kbd> to navigate, <kbd>Ctrl+ğŸ–±ï¸</kbd> to focus. On Mac, use <kbd>âŒ˜</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="a-minimal-example-call-by-value-simply-typed-lambda-calculus">
<h1 class="title">A Minimal Example: Call-by-Value Simply Typed Lambda Calculus</h1>

<p>We demonstrate how to instantiate our framework to define the OGS associated
to the CBV Î»-calculus. With the instance comes the proof that bisimilarity of
the OGS entails substitution equivalence, which coincides with
CIU-equivalence.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This example is designed to be minimal, hiding by nature some
difficulties. In particular it has no positive types, which simplifies the
development a lot.</p>
</div>
<div class="section" id="syntax">
<h1>Syntax</h1>
<div class="section" id="types">
<h2>Types</h2>
<p>As discussed in the paper, our framework applies not really to a language but
more to an abstract machine. In order to ease this instanciation, we will
focus directly on a CBV machine and define evaluation contexts early on.
Working with intrinsically typed syntax, we need to give types to these
contexts: we will type them by the &quot;formal negation&quot; of the type of their
hole. In order to do so we first define the usual types <code class="highlight coq"><span class="n">ty0</span></code> of STLC with
functions and a ground type.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> ty_scope .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">ty0</span> : <span class="kt">Type</span> :=
| Î¹ : ty0
| Arr : ty0 -&gt; ty0 -&gt; ty0
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A â†’ B&quot;</span> := (Arr A B) (<span class="kn">at level</span> <span class="mi">40</span>) : ty_scope .</span></span></pre><p>We then define &quot;tagged types&quot;, where <code class="highlight coq"><span class="n">t</span><span class="o">+</span> <span class="n">a</span></code> will be the type of terms of type
<code class="highlight coq"><span class="n">a</span></code>, and <code class="highlight coq"><span class="n">t</span><span class="o">-</span> <span class="n">a</span></code> the type of evaluation contexts of hole <code class="highlight coq"><span class="n">a</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">ty</span> : <span class="kt">Type</span> :=
| VTy : ty0 -&gt; ty
| KTy : ty0 -&gt; ty
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;+ t&quot;</span> := (VTy t) (<span class="kn">at level</span> <span class="mi">5</span>) : ty_scope .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;Â¬ t&quot;</span> := (KTy t) (<span class="kn">at level</span> <span class="mi">5</span>) : ty_scope .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">VTy</span> : ty0 &gt;-&gt; ty .</span></span></pre></div>
<div class="section" id="typing-contexts">
<h2>Typing Contexts</h2>
<p>Typing contexts are now simply defined as lists of tagged types. This is
perhaps the slightly surprising part: contexts will now contain &quot;continuation
variables&quot;. Rest assured terms will make no use of them. These are solely
needed for evaluation contexts: as they are only typed with their hole, we are
missing the type of their outside. We fix this problem by <em>naming</em> the outside
and make evaluation contexts end with a continuation variable.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Our choices make a bit more sense if we realize that what we are
writing is exactly the subset of Î»Î¼-calculus that is the image of the CBV
translation from Î»-calculus.</p>
</div>
<!--  -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stlc-cbv-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="stlc-cbv-v-chk0"><span class="kn">Definition</span> <span class="nf">t_ctx</span> : <span class="kt">Type</span> := ctx ty .</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The reference ctx was not found <span class="kr">in</span> the current
environment.</blockquote></div></div></small></span></pre></div>
<div class="section" id="terms-and-values-and">
<h2>Terms and Values and ...</h2>
<p>We now have all that is needed to define terms, which we define mutually with
values. As discussed above, they are are indexed by a list of tagged types (of
which they only care about the non-negated elements) and by an untagged type.</p>
<p>The only fanciness is the recursive lambda abstraction, which we include to
safeguard ourselves from accidentally using the fact that the language is
strongly normalizing.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Inductive</span> <span class="nf">term</span> (<span class="nv">Î“</span> : t_ctx) : ty0 -&gt; <span class="kt">Type</span> :=
| Val {a} : val Î“ a -&gt; term Î“ a
| App {a b} : term Î“ (a â†’ b) -&gt; term Î“ a -&gt; term Î“ b
<span class="kr">with</span> val (Î“ : t_ctx) : ty0 -&gt; <span class="kt">Type</span> :=
| Var {a} : Î“ âˆ‹ + a -&gt; val Î“ a
| TT : val Î“ Î¹
| Lam {a b} : term (Î“ â–¶â‚“ (a â†’ b) â–¶â‚“ a) b -&gt; val Î“ (a â†’ b)
.</span></pre><p>Evaluation contexts follow. As discussed, there is a &quot;covariable&quot; case, to
&quot;end&quot; the context. The other cases are usual: evaluating the argument of an
application and evaluating the function.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Inductive</span> <span class="nf">ev_ctx</span> (<span class="nv">Î“</span> : t_ctx) : ty0 -&gt; <span class="kt">Type</span> :=
| K0 {a} : Î“ âˆ‹ Â¬ a -&gt; ev_ctx Î“ a
| K1 {a b} : term Î“ (a â†’ b) -&gt; ev_ctx Î“ b -&gt; ev_ctx Î“ a
| K2 {a b} : val Î“ a -&gt; ev_ctx Î“ b -&gt; ev_ctx Î“ (a â†’ b)
.</span></pre><p>Next are the machine states. They consist of an explicit cut and represent
a term in the process of being executed in some context. Notice how states
they are only indexed by a typing context: these are proper &quot;diverging
programs&quot;.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">state</span> := term âˆ¥â‚› ev_ctx.</span></pre><p>Finally the last of syntactic categories: &quot;machine values&quot;. This category is
typed with a tagged type and encompasses both values (for non-negated types)
and evaluation contexts (for negated types). The primary use-case for this
category is to denote &quot;things by which we can substitute (tagged) variables&quot;.</p>
<p>In fact when working with intrinsically-typed syntax, substitution is modelled
as a monoidal multiplication (see <a class="citation-reference" href="#aacmm21" id="citation-reference-1">[AACMM21]</a> and <a class="citation-reference" href="#fs22" id="citation-reference-2">[FS22]</a>). We will prove later
that <code class="highlight coq"><span class="n">val_m</span> <span class="n">Î“</span></code> is indeed a monoid relative to <code class="highlight coq"><span class="n">has</span> <span class="n">Î“</span></code> and that contexts and
assignments form a category.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">val_m</span> : t_ctx -&gt; ty -&gt; <span class="kt">Type</span> :=
  val_m Î“ (+ a) := val Î“ a ;
  val_m Î“ (Â¬ a) := ev_ctx Î“ a .</span></span></pre><p>Together with machine values we define a smart constructor for &quot;machine var&quot;,
embedding tagged variables into these generalized values. It conveniently
serves as the identity assignment, a fact we use to give it this mysterious
point-free style type, which desugars to <code class="highlight coq"><span class="kr">forall</span> <span class="nv">a</span><span class="o">,</span> <span class="n">Î“</span> <span class="o">âˆ‹</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">val_m</span> <span class="n">Î“</span> <span class="n">a</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Equations</span> <span class="nf">a_id</span> {<span class="nv">Î“</span>} : Î“ =[val_m]&gt; Î“ :=
  a_id (+ _) i := Var i ;
  a_id (Â¬ _) i := K0 i .</span></pre></div>
</div>
<div class="section" id="substitution-and-renaming">
<h1>Substitution and Renaming</h1>
<p>In order to define substitution we first need to dance the intrinsically-typed
dance and define renamings, from which we will derive weakenings and then only
define substitution.</p>
<div class="section" id="renaming">
<h2>Renaming</h2>
<p>Lets write intrinsically-typed parallel renaming for all of our syntactic
categories! If you have never seen such intrinsically-typed definitions you
might be surprised by the absence of error-prone de-bruijn index manipulation.
Enjoy this beautiful syntax traversal!</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Equations</span> <span class="nf">t_rename</span> {<span class="nv">Î“</span> <span class="nv">Î”</span>} : Î“ âŠ† Î” -&gt; term Î“ â‡’áµ¢ term Î” :=
  t_rename f _ (Val v)     := Val (v_rename f _ v) ;
  t_rename f _ (App t1 t2) := App (t_rename f _ t1) (t_rename f _ t2) ;
<span class="kr">with</span> v_rename {Î“ Î”} : Î“ âŠ† Î” -&gt; val Î“ â‡’áµ¢ val Î” :=
  v_rename f _ (Var i)    := Var (f _ i) ;
  v_rename f _ (TT)       := TT ;
  v_rename f _ (Lam t) := Lam (t_rename (r_shift2 f) _ t) .

<span class="kn">Equations</span> <span class="nf">e_rename</span> {<span class="nv">Î“</span> <span class="nv">Î”</span>} : Î“ âŠ† Î” -&gt; ev_ctx Î“ â‡’áµ¢ ev_ctx Î” :=
  e_rename f _ (K0 i)   := K0 (f _ i) ;
  e_rename f _ (K1 t Ï€) := K1 (t_rename f _ t) (e_rename f _ Ï€) ;
  e_rename f _ (K2 v Ï€) := K2 (v_rename f _ v) (e_rename f _ Ï€) .

<span class="kn">Equations</span> <span class="nf">s_rename</span> {<span class="nv">Î“</span> <span class="nv">Î”</span>} : Î“ âŠ† Î” -&gt; state Î“ -&gt; state Î” :=
  s_rename f (Cut t Ï€) := Cut (t_rename f _ t) (e_rename f _ Ï€).

<span class="kn">Equations</span> <span class="nf">m_rename</span> {<span class="nv">Î“</span> <span class="nv">Î”</span>} : Î“ âŠ† Î” -&gt; val_m Î“ â‡’áµ¢ val_m Î” :=
  m_rename f (+ _) v := v_rename f _ v ;
  m_rename f (Â¬ _) Ï€ := e_rename f _ Ï€ .

#[<span class="kn">global</span>] <span class="kn">Arguments</span> s_rename _ _ _ /.
#[<span class="kn">global</span>] <span class="kn">Arguments</span> m_rename _ _ _ /.</span></pre><p>We can recast <code class="highlight coq"><span class="n">m_rename</span></code> as an operator on assigments, more precisely as
renaming an assigment on the left.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">a_ren</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} : Î“2 âŠ† Î“3 -&gt; Î“1 =[val_m]&gt; Î“2 -&gt; Î“1 =[val_m]&gt; Î“3 :=
  <span class="kr">fun</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">_</span> <span class="nv">i</span> =&gt; m_rename f _ (g _ i) .</span></pre><p>The following bunch of notations will help us to keep the code readable:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Notation</span> <span class="s2">&quot;t â‚œâŠ›áµ£ r&quot;</span> := (t_rename r%asgn _ t) (<span class="kn">at level</span> <span class="mi">14</span>).
<span class="kn">Notation</span> <span class="s2">&quot;v áµ¥âŠ›áµ£ r&quot;</span> := (v_rename r%asgn _ v) (<span class="kn">at level</span> <span class="mi">14</span>).
<span class="kn">Notation</span> <span class="s2">&quot;Ï€ â‚‘âŠ›áµ£ r&quot;</span> := (e_rename r%asgn _ Ï€) (<span class="kn">at level</span> <span class="mi">14</span>).
<span class="kn">Notation</span> <span class="s2">&quot;v â‚˜âŠ›áµ£ r&quot;</span> := (m_rename r%asgn _ v) (<span class="kn">at level</span> <span class="mi">14</span>).
<span class="kn">Notation</span> <span class="s2">&quot;s â‚›âŠ›áµ£ r&quot;</span> := (s_rename r%asgn s) (<span class="kn">at level</span> <span class="mi">14</span>).
<span class="kn">Notation</span> <span class="s2">&quot;a âŠ›áµ£ r&quot;</span> := (a_ren r%asgn a) (<span class="kn">at level</span> <span class="mi">14</span>) : asgn_scope.</span></pre><p>As discussed above, we can now obtain our precious weakenings. Here are the
three we will need.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">t_shift</span> {<span class="nv">Î“</span> <span class="nv">a</span>} := @t_rename Î“ (Î“ â–¶â‚“ a) r_pop.
<span class="kn">Definition</span> <span class="nf">m_shift2</span> {<span class="nv">Î“</span> <span class="nv">a</span> <span class="nv">b</span>} := @m_rename Î“ (Î“ â–¶â‚“ a â–¶â‚“ b) (r_pop áµ£âŠ› r_pop).
<span class="kn">Definition</span> <span class="nf">a_shift2</span> {<span class="nv">Î“</span> <span class="nv">Î”</span> <span class="nv">a</span> <span class="nv">b</span>} (<span class="nv">f</span> : Î“ =[val_m]&gt; Î”)
  : (Î“ â–¶â‚“ a â–¶â‚“ b) =[val_m]&gt; (Î” â–¶â‚“ a â–¶â‚“ b)
  := [ [ a_map f m_shift2 ,â‚“ a_id a (pop top) ] ,â‚“ a_id b top ].</span></pre></div>
<div class="section" id="substitutions">
<h2>Substitutions</h2>
<p>With weakenings in place we are now equipped to define substitutions. This
goes pretty much like renaming. We have abstained from defining generic syntax
traversal tools like Allais et al's &quot;Kits&quot; to keep our example minimal... And
incidentally showcase the intrinsically-typed style with Matthieu Sozeau's
Equations.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Equations</span> <span class="nf">t_subst</span> {<span class="nv">Î“</span> <span class="nv">Î”</span>} : Î“ =[val_m]&gt; Î” -&gt; term Î“ â‡’áµ¢ term Î” :=
  t_subst f _ (Val v)     := Val (v_subst f _ v) ;
  t_subst f _ (App t1 t2) := App (t_subst f _ t1) (t_subst f _ t2) ;
<span class="kr">with</span> v_subst {Î“ Î”} : Î“ =[val_m]&gt; Î” -&gt; val Î“ â‡’áµ¢ val Î” :=
  v_subst f _ (Var i)    := f _ i ;
  v_subst f _ (TT)       := TT ;
  v_subst f _ (Lam t) := Lam (t_subst (a_shift2 f) _ t) .

<span class="kn">Equations</span> <span class="nf">e_subst</span> {<span class="nv">Î“</span> <span class="nv">Î”</span>} : Î“ =[val_m]&gt; Î” -&gt; ev_ctx Î“ â‡’áµ¢ ev_ctx Î” :=
  e_subst f _ (K0 i)   := f _ i ;
  e_subst f _ (K1 t Ï€) := K1 (t_subst f _ t) (e_subst f _ Ï€) ;
  e_subst f _ (K2 v Ï€) := K2 (v_subst f _ v) (e_subst f _ Ï€) .</span></pre><p>These notations will make everything shine.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Notation</span> <span class="s2">&quot;t `â‚œâŠ› a&quot;</span> := (t_subst a%asgn _ t) (<span class="kn">at level</span> <span class="mi">30</span>).
<span class="kn">Notation</span> <span class="s2">&quot;v `áµ¥âŠ› a&quot;</span> := (v_subst a%asgn _ v) (<span class="kn">at level</span> <span class="mi">30</span>).
<span class="kn">Notation</span> <span class="s2">&quot;Ï€ `â‚‘âŠ› a&quot;</span> := (e_subst a%asgn _ Ï€) (<span class="kn">at level</span> <span class="mi">30</span>).</span></pre><p>These two last substitutions, for states and generalized values, are the ones
we will give to the abstract interface. For categorical abstraction reasons,
the abstract interface has the argument reversed for substitutions: first
the state or value, then the assignment as second argument. To ease instanciation
we will hence do so too. The type is given with tricky combinators but expands to:</p>
<blockquote>
<p>m_subst Î“ a : val_m Î“ a -&gt; forall Î”, Î“ =[val_m]&gt; Î” -&gt; val_m Î” a</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Equations</span> <span class="nf">m_subst</span> : val_m â‡’<span class="err">â‚</span> âŸ¦ val_m , val_m âŸ§<span class="err">â‚</span> :=
  m_subst _ (+ _) v _ f := v `áµ¥âŠ› f ;
  m_subst _ (Â¬ _) Ï€ _ f := Ï€ `â‚‘âŠ› f .

<span class="kn">Definition</span> <span class="nf">s_subst</span> : state â‡’<span class="err">â‚€</span> âŸ¦ val_m , state âŸ§<span class="err">â‚€</span> :=
  <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">s</span> <span class="nv">_</span> <span class="nv">f</span> =&gt; (s.(cut_l) `â‚œâŠ› f) â‹… (s.(cut_r) `â‚‘âŠ› f).
#[<span class="kn">global</span>] <span class="kn">Arguments</span> s_subst _ _ /.</span></pre></blockquote>
<p>We can now instanciate the substitution monoid and module structures.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">val_m_monoid</span> : subst_monoid val_m :=
  {| v_var := @a_id ; v_sub := m_subst |} .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">state_module</span> : subst_module val_m state :=
  {| c_sub := s_subst |} .</span></span></pre><p>Finally we define a more usual substitution function which only substitutes
the top two variables instead of doing parallel substitution.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">assign2</span> {<span class="nv">Î“</span> <span class="nv">a</span> <span class="nv">b</span>} <span class="nv">v1</span> <span class="nv">v2</span>
  : (Î“ â–¶â‚“ a â–¶â‚“ b) =[val_m]&gt; Î“
  := [ [ a_id ,â‚“ v1 ] ,â‚“ v2 ] .
<span class="kn">Definition</span> <span class="nf">t_subst2</span> {<span class="nv">Î“</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>} (<span class="nv">t</span> : term _ c) <span class="nv">v1</span> <span class="nv">v2</span> := t `â‚œâŠ› @assign2 Î“ a b v1 v2.
<span class="kn">Notation</span> <span class="s2">&quot;t /[ v1 , v2 ]&quot;</span> := (t_subst2 t v1 v2) (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">left associativity</span>).</span></pre></div>
</div>
<div class="section" id="an-evaluator">
<h1>An Evaluator</h1>
<p>As motivated earlier, the evaluator will be a defined as a state-machine, the
core definition being a state-transition function. To stick to the intrinsic
style, we wish that this state-machine stops only at <em>evidently</em> normal forms,
instead of stoping at states which happen to be in normal form. Perhaps more
simply said, we want to type the transition function as <code class="highlight coq"><span class="n">state</span> <span class="n">Î“</span> <span class="o">â†’</span> <span class="o">(</span><span class="n">state</span>
<span class="n">Î“</span> <span class="o">+</span> <span class="n">nf</span> <span class="n">Î“</span><span class="o">)</span></code>, where returning in the right component means stoping and outputing
a normal form.</p>
<p>In order to do this we first need to define normal forms! But instead of
defining an inductive definition of normal forms as is customary, we will take
an other route more tailored to OGS based on ultimate patterns.</p>
<div class="section" id="patterns-and-observations">
<h2>Patterns and Observations</h2>
<p>As discussed in the paper, a central aspect of OGS is to circumvent the
problem of naive trace semantics for higher-order languages by mean of
a notion of &quot;abstract values&quot;, or more commonly <em>ultimate patterns</em>, which
define the &quot;shareable part&quot; of a value. For clarity reasons, instead of
patterns we here take the dual point of view of &quot;observations&quot;, which can be
seen as patterns at the dual type (dual in the sense of swapping the tag). For
our basic Î»-calculus, all types are negative -- that is, unsheareble -- hence
the observations are pretty simple:</p>
<ul>
<li><p class="first">Observing a continuation of type <code class="highlight coq"><span class="o">Â¬</span> <span class="n">a</span></code> means returning a (hidden) value to
it. In terms of pattern this corresponds to the &quot;fresh variable&quot; pattern
<code class="highlight coq"><span class="n">Var</span> <span class="n">x</span></code>.</p>
</li>
<li><p class="first">Observing a function of type <code class="highlight coq"><span class="n">a</span> <span class="o">â†’</span> <span class="n">b</span></code> means giving it a hidden value and
a hidden continuation. In terms of patterns this corresponds to the
&quot;application&quot; co-pattern <code class="highlight coq"><span class="n">K2</span> <span class="o">(</span><span class="n">Var</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">K0</span> <span class="n">y</span><span class="o">)</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">obs</span> : ty -&gt; <span class="kt">Type</span> :=
| ORet {a} : obs (Â¬ a)
| OApp {a b} : obs (a â†’ b)
.</span></span></pre></li>
</ul>
<p>As observations correspond to a subset of (machine) values where all the
variables are &quot;fresh&quot;, these variables have no counter-part in de-bruijn
notation (there is no meaningful notion of freshness). As such we have not
indexed <code class="highlight coq"><span class="n">obs</span></code> by any typing context, but to complete the definition we now
need to define a projection into typing contexts denoting the &quot;domain&quot;,
&quot;support&quot; or more accurately &quot;set of nameless fresh variables&quot; of an
observation.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Equations</span> <span class="nf">obs_dom</span> {<span class="nv">a</span>} : obs a -&gt; t_ctx :=
  obs_dom (@ORet a)   := âˆ… â–¶â‚“ + a ;
  obs_dom (@OApp a b) := âˆ… â–¶â‚“ + a â–¶â‚“ Â¬ b .</span></pre><p>These two definitions together form an operator.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">obs_op</span> : Oper ty t_ctx :=
  {| o_op := obs ; o_dom := @obs_dom |} .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="kn">Notation</span> <span class="nf">ORet&#39;</span> := (ORet : o_op obs_op _).
<span class="kn">Notation</span> <span class="nf">OApp&#39;</span> := (OApp : o_op obs_op _).</span></pre><p>Given a value, an observation on its type and a value for each fresh variable
of the observation, we can &quot;refold&quot; everything and form a new state which will
indeed observe this value.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Equations</span> <span class="nf">obs_app</span> {<span class="nv">Î“</span> <span class="nv">a</span>} (<span class="nv">v</span> : val_m Î“ a) (<span class="nv">p</span> : obs a) (<span class="nv">Î³</span> : obs_dom p =[val_m]&gt; Î“) : state Î“ :=
  obs_app v OApp Î³ := Val v â‹… K2 (Î³ _ (pop top)) (Î³ _ top) ;
  obs_app Ï€ ORet Î³ := Val (Î³ _ top) â‹… (Ï€ : ev_ctx _ _) .</span></pre></div>
<div class="section" id="normal-forms">
<h2>Normal forms</h2>
<p>Normal forms for CBV Î»-calculus can be characterized as either a value <code class="highlight coq"><span class="n">v</span></code> or
a stuck application in evaluation context <code class="highlight coq"><span class="n">E</span><span class="o">[</span><span class="n">x</span> <span class="n">v</span><span class="o">]</span></code> (see &quot;eager-normal forms&quot;
in <a class="citation-reference" href="#l05" id="citation-reference-3">[L05]</a>). Now it doesn't take much squinting to see that in our setting,
this corresponds respectively to states of the form <code class="highlight coq"><span class="o">âŸ¨</span> <span class="n">v</span> <span class="o">|</span> <span class="n">K0</span> <span class="n">x</span> <span class="o">âŸ©</span></code> and <code class="highlight coq"><span class="o">âŸ¨</span> <span class="n">Var</span>
<span class="n">x</span> <span class="o">|</span> <span class="n">K2</span> <span class="n">v</span> <span class="n">Ï€</span> <span class="o">âŸ©</span></code>. Squinting a bit more, we can reap the benefits of our unified
treatment of terms and contexts and see that both of these cases work in the
same way: normal states are states given by a variable facing an observation
whose fresh variables have been substituted with values.</p>
<p>Having already defined observation and their set of fresh variables, an
observation stuffed with values in typing context <code class="highlight coq"><span class="n">Î“</span></code> can be represented
simply by a formal substitution of an observation <code class="highlight coq"><span class="n">o</span></code> and an assigment
<code class="highlight coq"><span class="n">obs_dom</span> <span class="n">o</span> <span class="o">=[</span><span class="n">val</span><span class="o">]&gt;</span> <span class="n">Î“</span></code>. This &quot;split&quot; definition of normal forms is the one we
will take.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">nf</span> := c_var âˆ¥â‚› (obs_op # val_m).</span></pre></div>
<div class="section" id="the-cbv-machine">
<h2>The CBV Machine</h2>
<p>Everything is now in place to define our state transition function. The
reduction rules should come to no surprise:</p>
<ol class="arabic simple">
<li><code class="highlight coq"><span class="o">âŸ¨</span> <span class="n">t1</span> <span class="n">t2</span> <span class="o">|</span> <span class="n">Ï€</span> <span class="o">âŸ©</span> <span class="o">â†’</span> <span class="o">âŸ¨</span> <span class="n">t2</span> <span class="o">|</span> <span class="n">t1</span> <span class="o">â‹…</span><span class="mi">1</span> <span class="n">Ï€</span> <span class="o">âŸ©</span></code></li>
<li><code class="highlight coq"><span class="o">âŸ¨</span> <span class="n">v</span> <span class="o">|</span> <span class="n">x</span> <span class="o">âŸ©</span></code> normal</li>
<li><code class="highlight coq"><span class="o">âŸ¨</span> <span class="n">v</span> <span class="o">|</span> <span class="n">t</span> <span class="o">â‹…</span><span class="mi">1</span> <span class="n">Ï€</span> <span class="o">âŸ©</span> <span class="o">â†’</span>  <span class="o">âŸ¨</span> <span class="n">t</span> <span class="o">|</span> <span class="n">v</span> <span class="o">â‹…</span><span class="mi">2</span> <span class="n">Ï€</span> <span class="o">âŸ©</span></code></li>
<li><code class="highlight coq"><span class="o">âŸ¨</span> <span class="n">x</span> <span class="o">|</span> <span class="n">v</span> <span class="o">â‹…</span><span class="mi">2</span> <span class="n">Ï€</span> <span class="o">âŸ©</span></code> normal</li>
<li><code class="highlight coq"><span class="o">âŸ¨</span> <span class="kr">Î»</span><span class="nv">fx</span><span class="o">.</span><span class="n">t</span> <span class="o">|</span> <span class="n">v</span> <span class="o">â‹…</span><span class="mi">2</span> <span class="n">Ï€</span> <span class="o">âŸ©</span> <span class="o">â†’</span> <span class="o">âŸ¨</span> <span class="n">t</span><span class="o">[</span><span class="n">f</span><span class="o">â†¦</span><span class="kr">Î»</span><span class="nv">fx</span><span class="o">.</span><span class="n">t</span><span class="o">;</span> <span class="n">x</span><span class="o">â†¦</span><span class="n">v</span><span class="o">]</span> <span class="o">|</span>  <span class="n">Ï€</span> <span class="o">âŸ©</span></code></li>
</ol>
<p>Rules 1,3,5 step to a new configuration, while cases 2,4 are stuck on normal
forms.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Equations</span> <span class="nf">eval_step</span> {<span class="nv">Î“</span> : t_ctx} : state Î“ -&gt; sum (state Î“) (nf Î“) :=
  eval_step (Cut (App t1 t2)      (Ï€))      := inl (Cut t2 (K1 t1 Ï€)) ;
  eval_step (Cut (Val v)          (K0 i))   := inr (i â‹… ORet&#39; â¦‡ [ ! ,â‚“ v ] â¦ˆ) ;
  eval_step (Cut (Val v)          (K1 t Ï€)) := inl (Cut t (K2 v Ï€)) ;
  eval_step (Cut (Val (Var i))    (K2 v Ï€)) := inr (i â‹… OApp&#39; â¦‡ [ [ ! ,â‚“ v ] ,â‚“ Ï€ ] â¦ˆ) ;
  eval_step (Cut (Val (Lam t)) (K2 v Ï€)) := inl (Cut (t /[ Lam t , v ]) Ï€) .</span></pre><p>Having defined the transition function, we can now iterate it inside the delay
monad. This constructs a possibly non-terminating computation ending with
a normal form.</p>
<pre class="alectryon-io highlight" id="stlceval"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">stlc_eval</span> {<span class="nv">Î“</span> : t_ctx} : state Î“ -&gt; delay (nf Î“)
  := iter_delay (ret_delay âˆ˜ eval_step).</span></span></pre></div>
</div>
<div class="section" id="properties">
<h1>Properties</h1>
<p>We have now finished all the computational parts of the instanciation, but all
the proofs are left to be done. Before attacking the OGS-specific hypotheses,
we will need to prove the usual standard lemmata on renaming and substitution.</p>
<p>There will be a stack of lemmata which will all pretty much be simple
inductions on the syntax, so we start by introducing some helpers for this. In
fact it is not completely direct to do since terms and values are mutually
defined: we will need to derive a mutual induction principle.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme</span> <span class="nf">term_mut</span> := <span class="kn">Induction for</span> term <span class="kn">Sort</span> <span class="kt">Prop</span>
   <span class="kr">with</span> val_mut := <span class="kn">Induction for</span> val <span class="kn">Sort</span> <span class="kt">Prop</span> .</span></span></pre><p>Annoyingly, Coq treats this mutual induction principle as two separate
induction principles. They both have the exact same premises but differ in
their conclusion. Thus we define a datatype for these premises, to avoid
duplicating the proofs. Additionally, evaluation contexts are not defined
mutually with terms and values, but it doesn't hurt to prove their properties
simultaneously too, so <code class="highlight coq"><span class="n">syn_ind_args</span></code> is in fact closer to the premises of
a three-way mutual induction principle between terms, values and evaluation
contexts.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">syn_ind_args</span> (<span class="nv">P_t</span> : <span class="kr">forall</span> <span class="nv">Î“</span> <span class="nv">A</span>, term Î“ A -&gt; <span class="kt">Prop</span>)
                    (<span class="nv">P_v</span> : <span class="kr">forall</span> <span class="nv">Î“</span> <span class="nv">A</span>, val Î“ A -&gt; <span class="kt">Prop</span>)
                    (<span class="nv">P_e</span> : <span class="kr">forall</span> <span class="nv">Î“</span> <span class="nv">A</span>, ev_ctx Î“ A -&gt; <span class="kt">Prop</span>) :=
  {
    ind_val {Î“ a} v (_ : P_v Î“ a v) : P_t Î“ a (Val v) ;
    ind_app {Î“ a b} t1 (_ : P_t Î“ (a â†’ b) t1) t2 (_ : P_t Î“ a t2) : P_t Î“ b (App t1 t2) ;
    ind_var {Î“ a} i : P_v Î“ a (Var i) ;
    ind_tt {Î“} : P_v Î“ (Î¹) (TT) ;
    ind_lamrec {Î“ a b} t (_ : P_t _ b t) : P_v Î“ (a â†’ b) (Lam t) ;
    ind_kvar {Î“ a} i : P_e Î“ a (K0 i) ;
    ind_kfun {Î“ a b} t (_ : P_t Î“ (a â†’ b) t) Ï€ (_ : P_e Î“ b Ï€) : P_e Î“ a (K1 t Ï€) ;
    ind_karg {Î“ a b} v (_ : P_v Î“ a v) Ï€ (_ : P_e Î“ b Ï€) : P_e Î“ (a â†’ b) (K2 v Ï€)
  } .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">term_ind_mut</span> <span class="nv">P_t</span> <span class="nv">P_v</span> <span class="nv">P_e</span> (<span class="nv">H</span> : syn_ind_args P_t P_v P_e) <span class="nv">Î“</span> <span class="nv">a</span> <span class="nv">t</span> : P_t Î“ a t .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> H; <span class="bp">now</span> <span class="nb">apply</span> (term_mut P_t P_v).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">val_ind_mut</span> <span class="nv">P_t</span> <span class="nv">P_v</span> <span class="nv">P_e</span> (<span class="nv">H</span> : syn_ind_args P_t P_v P_e) <span class="nv">Î“</span> <span class="nv">a</span> <span class="nv">v</span> : P_v Î“ a v .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> H; <span class="bp">now</span> <span class="nb">apply</span> (val_mut P_t P_v).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ctx_ind_mut</span> <span class="nv">P_t</span> <span class="nv">P_v</span> <span class="nv">P_e</span> (<span class="nv">H</span> : syn_ind_args P_t P_v P_e) <span class="nv">Î“</span> <span class="nv">a</span> <span class="nv">Ï€</span> : P_e Î“ a Ï€ .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> Ï€.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (ind_kvar _ _ _ H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (ind_kfun _ _ _ H); <span class="nb">auto</span>; <span class="nb">apply</span> (term_ind_mut _ _ _ H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (ind_karg _ _ _ H); <span class="nb">auto</span>; <span class="nb">apply</span> (val_ind_mut _ _ _ H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Now equipped we can start with the first lemma: renaming respects pointwise
equality of assignments. As discussed, we will prove this by mutual induction
on our three &quot;base&quot; syntactic categories of terms, values and evaluation
contexts, and then we will also deduce it for the three &quot;derived&quot; notions of
machine values, states and assigments. Sometimes some of the derived notions
will be omitted if it is not needed later on.</p>
<p>This proof, like all the following ones will follow a simple pattern:
a simplification; an application of congruence; a fixup for the two-time
shifted assigment in the case of Î»; finally a call to the induction
hypothesis.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Here is definitely where the generic syntax traversal kit of
Guillaume Allais et al would shine. Indeed the proof pattern i outlined can
really be formalized into a generic proof.</p>
</div>
<!--  -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">t_ren_proper_P</span> <span class="nv">Î“</span> <span class="nv">a</span> (<span class="nv">t</span> : term Î“ a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î”</span> (<span class="nv">f1</span> <span class="nv">f2</span> : Î“ âŠ† Î”), f1 â‰¡â‚ f2 -&gt; t â‚œâŠ›áµ£ f1 = t â‚œâŠ›áµ£ f2 .
<span class="kn">Definition</span> <span class="nf">v_ren_proper_P</span> <span class="nv">Î“</span> <span class="nv">a</span> (<span class="nv">v</span> : val Î“ a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î”</span> (<span class="nv">f1</span> <span class="nv">f2</span> : Î“ âŠ† Î”), f1 â‰¡â‚ f2 -&gt; v áµ¥âŠ›áµ£ f1 = v áµ¥âŠ›áµ£ f2 .
<span class="kn">Definition</span> <span class="nf">e_ren_proper_P</span> <span class="nv">Î“</span> <span class="nv">a</span> (<span class="nv">Ï€</span> : ev_ctx Î“ a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î”</span> (<span class="nv">f1</span> <span class="nv">f2</span> : Î“ âŠ† Î”), f1 â‰¡â‚ f2 -&gt; Ï€ â‚‘âŠ›áµ£ f1 = Ï€ â‚‘âŠ›áµ£ f2 .
<span class="kn">Lemma</span> <span class="nf">ren_proper_prf</span> : syn_ind_args t_ren_proper_P v_ren_proper_P e_ren_proper_P.
  <span class="nb">econstructor</span>.
  <span class="kp">all</span>: <span class="nb">unfold</span> t_ren_proper_P, v_ren_proper_P, e_ren_proper_P.
  <span class="kp">all</span>: <span class="nb">intros</span>; <span class="nb">cbn</span>; <span class="nb">f_equal</span>; <span class="nb">eauto</span>.
  <span class="kp">all</span>: <span class="nb">eapply</span> H; <span class="bp">now</span> <span class="nb">apply</span> r_shift2_eq.
<span class="kn">Qed</span>.

#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">t_ren_eq</span> {<span class="nv">Î“</span> <span class="nv">Î”</span>}
  : Proper (asgn_eq _ _ ==&gt; forall_relation (<span class="kr">fun</span> <span class="nv">a</span> =&gt; eq ==&gt; eq)) (@t_rename Î“ Î”).
  <span class="nb">intros</span> f1 f2 H1 a x y -&gt;; <span class="bp">now</span> <span class="nb">apply</span> (term_ind_mut _ _ _ ren_proper_prf).
<span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">v_ren_eq</span> {<span class="nv">Î“</span> <span class="nv">Î”</span>}
  : Proper (asgn_eq _ _ ==&gt; forall_relation (<span class="kr">fun</span> <span class="nv">a</span> =&gt; eq ==&gt; eq)) (@v_rename Î“ Î”).
  <span class="nb">intros</span> f1 f2 H1 a x y -&gt;; <span class="bp">now</span> <span class="nb">apply</span> (val_ind_mut _ _ _ ren_proper_prf).
<span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">e_ren_eq</span> {<span class="nv">Î“</span> <span class="nv">Î”</span>}
  : Proper (asgn_eq _ _ ==&gt; forall_relation (<span class="kr">fun</span> <span class="nv">a</span> =&gt; eq ==&gt; eq)) (@e_rename Î“ Î”).
  <span class="nb">intros</span> f1 f2 H1 a x y -&gt;; <span class="bp">now</span> <span class="nb">apply</span> (ctx_ind_mut _ _ _ ren_proper_prf).
<span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">m_ren_eq</span> {<span class="nv">Î“</span> <span class="nv">Î”</span>}
  : Proper (asgn_eq _ _ ==&gt; forall_relation (<span class="kr">fun</span> <span class="nv">a</span> =&gt; eq ==&gt; eq)) (@m_rename Î“ Î”).
  <span class="nb">intros</span> ? ? H1 [] _ ? -&gt;; <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="bp">now</span> <span class="nb">rewrite</span> H1.
<span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">s_ren_eq</span> {<span class="nv">Î“</span> <span class="nv">Î”</span>}
  : Proper (asgn_eq _ _ ==&gt; eq ==&gt; eq) (@s_rename Î“ Î”).
  <span class="nb">intros</span> ? ? H1 _ x -&gt;; <span class="nb">destruct</span> x; <span class="nb">unfold</span> s_rename; <span class="nb">cbn</span>; <span class="bp">now</span> <span class="nb">rewrite</span> H1.
<span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">a_ren_eq</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>}
  : Proper (asgn_eq _ _ ==&gt; asgn_eq _ _ ==&gt; asgn_eq _ _) (@a_ren Î“1 Î“2 Î“3).
  <span class="nb">intros</span> ? ? H1 ? ? H2 ? ?; <span class="nb">apply</span> (m_ren_eq _ _ H1), H2.
<span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">a_shift2_eq</span> {<span class="nv">Î“</span> <span class="nv">Î”</span> <span class="nv">x</span> <span class="nv">y</span>} : Proper (asgn_eq _ _ ==&gt; asgn_eq _ _) (@a_shift2 Î“ Î” x y).
  <span class="nb">intros</span> ? ? H ? v.
  <span class="kp">do</span> <span class="mi">2</span> (dependent elimination v; <span class="nb">cbn</span>; <span class="nb">auto</span>).
  <span class="bp">now</span> <span class="nb">rewrite</span> H.
<span class="kn">Qed</span>.</span></pre><p>Lemma 2: renaming-renaming assocativity. I say &quot;associativity&quot; because it
definitely looks like associativity if we disregard the subscripts. More
precisely it could be described as the composition law a right action.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">t_ren_ren_P</span> <span class="nv">Î“1</span> <span class="nv">a</span> (<span class="nv">t</span> : term Î“1 a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> (<span class="nv">f1</span> : Î“1 âŠ† Î“2) (<span class="nv">f2</span> : Î“2 âŠ† Î“3),
    (t â‚œâŠ›áµ£ f1) â‚œâŠ›áµ£ f2 = t â‚œâŠ›áµ£ (f1 áµ£âŠ› f2).
<span class="kn">Definition</span> <span class="nf">v_ren_ren_P</span> <span class="nv">Î“1</span> <span class="nv">a</span> (<span class="nv">v</span> : val Î“1 a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> (<span class="nv">f1</span> : Î“1 âŠ† Î“2) (<span class="nv">f2</span> : Î“2 âŠ† Î“3),
    (v áµ¥âŠ›áµ£ f1) áµ¥âŠ›áµ£ f2 = v áµ¥âŠ›áµ£ (f1 áµ£âŠ› f2).
<span class="kn">Definition</span> <span class="nf">e_ren_ren_P</span> <span class="nv">Î“1</span> <span class="nv">a</span> (<span class="nv">Ï€</span> : ev_ctx Î“1 a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> (<span class="nv">f1</span> : Î“1 âŠ† Î“2) (<span class="nv">f2</span> : Î“2 âŠ† Î“3),
    (Ï€ â‚‘âŠ›áµ£ f1) â‚‘âŠ›áµ£ f2 = Ï€ â‚‘âŠ›áµ£ (f1 áµ£âŠ› f2).

<span class="kn">Lemma</span> <span class="nf">ren_ren_prf</span> : syn_ind_args t_ren_ren_P v_ren_ren_P e_ren_ren_P .
  <span class="nb">econstructor</span>.
  <span class="kp">all</span>: <span class="nb">unfold</span> t_ren_ren_P, v_ren_ren_P, e_ren_ren_P.
  <span class="kp">all</span>: <span class="nb">intros</span>; <span class="nb">cbn</span>; <span class="nb">f_equal</span>; <span class="nb">auto</span>.
  <span class="nb">rewrite</span> H; <span class="nb">apply</span> t_ren_eq; <span class="nb">auto</span>.
  <span class="nb">intros</span> ? v; <span class="bp">now</span> <span class="kp">do</span> <span class="mi">2</span> (dependent elimination v; <span class="nb">eauto</span>).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">t_ren_ren</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 âŠ† Î“2) (<span class="nv">f2</span> : Î“2 âŠ† Î“3) <span class="nv">a</span> (<span class="nv">t</span> : term Î“1 a) 
    : (t â‚œâŠ›áµ£ f1) â‚œâŠ›áµ£ f2 = t â‚œâŠ›áµ£ (f1 áµ£âŠ› f2).
  <span class="bp">now</span> <span class="nb">apply</span> (term_ind_mut _ _ _ ren_ren_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">v_ren_ren</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 âŠ† Î“2) (<span class="nv">f2</span> : Î“2 âŠ† Î“3) <span class="nv">a</span> (<span class="nv">v</span> : val Î“1 a) 
    : (v áµ¥âŠ›áµ£ f1) áµ¥âŠ›áµ£ f2 = v áµ¥âŠ›áµ£ (f1 áµ£âŠ› f2).
  <span class="bp">now</span> <span class="nb">apply</span> (val_ind_mut _ _ _ ren_ren_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">e_ren_ren</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 âŠ† Î“2) (<span class="nv">f2</span> : Î“2 âŠ† Î“3) <span class="nv">a</span> (<span class="nv">Ï€</span> : ev_ctx Î“1 a) 
    : (Ï€ â‚‘âŠ›áµ£ f1) â‚‘âŠ›áµ£ f2 = Ï€ â‚‘âŠ›áµ£ (f1 áµ£âŠ› f2).
  <span class="bp">now</span> <span class="nb">apply</span> (ctx_ind_mut _ _ _ ren_ren_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">m_ren_ren</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 âŠ† Î“2) (<span class="nv">f2</span> : Î“2 âŠ† Î“3) <span class="nv">a</span> (<span class="nv">v</span> : val_m Î“1 a) 
    : (v â‚˜âŠ›áµ£ f1) â‚˜âŠ›áµ£ f2 = v â‚˜âŠ›áµ£ (f1 áµ£âŠ› f2).
  <span class="nb">destruct</span> a; [ <span class="bp">now</span> <span class="nb">apply</span> v_ren_ren | <span class="bp">now</span> <span class="nb">apply</span> e_ren_ren ].
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">s_ren_ren</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 âŠ† Î“2) (<span class="nv">f2</span> : Î“2 âŠ† Î“3) (<span class="nv">s</span> : state Î“1) 
    : (s â‚›âŠ›áµ£ f1) â‚›âŠ›áµ£ f2 = s â‚›âŠ›áµ£ (f1 áµ£âŠ› f2).
  <span class="nb">destruct</span> s; <span class="nb">apply</span> (f_equal2 Cut); [ <span class="bp">now</span> <span class="nb">apply</span> t_ren_ren | <span class="bp">now</span> <span class="nb">apply</span> e_ren_ren ].
<span class="kn">Qed</span>.</span></pre><p>Lemma 3: left identity law of renaming.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">t_ren_id_l_P</span> <span class="nv">Î“</span> <span class="nv">a</span> (<span class="nv">t</span> : term Î“ a) : <span class="kt">Prop</span> := t â‚œâŠ›áµ£ r_id = t .
<span class="kn">Definition</span> <span class="nf">v_ren_id_l_P</span> <span class="nv">Î“</span> <span class="nv">a</span> (<span class="nv">v</span> : val Î“ a) : <span class="kt">Prop</span> := v áµ¥âŠ›áµ£ r_id = v .
<span class="kn">Definition</span> <span class="nf">e_ren_id_l_P</span> <span class="nv">Î“</span> <span class="nv">a</span> (<span class="nv">Ï€</span> : ev_ctx Î“ a) : <span class="kt">Prop</span> := Ï€ â‚‘âŠ›áµ£ r_id = Ï€.
<span class="kn">Lemma</span> <span class="nf">ren_id_l_prf</span> : syn_ind_args t_ren_id_l_P v_ren_id_l_P e_ren_id_l_P .
  <span class="nb">econstructor</span>.
  <span class="kp">all</span>: <span class="nb">unfold</span> t_ren_id_l_P, v_ren_id_l_P, e_ren_id_l_P.
  <span class="kp">all</span>: <span class="nb">intros</span>; <span class="nb">cbn</span>; <span class="nb">f_equal</span>; <span class="nb">auto</span>.
  <span class="nb">rewrite</span> &lt;- H <span class="nb">at</span> <span class="mi">2</span>; <span class="nb">apply</span> t_ren_eq; <span class="nb">auto</span>.
  <span class="nb">intros</span> ? v; <span class="bp">now</span> <span class="kp">do</span> <span class="mi">2</span> (dependent elimination v; <span class="nb">eauto</span>).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">t_ren_id_l</span> {<span class="nv">Î“</span>} <span class="nv">a</span> (<span class="nv">t</span> : term Î“ a) : t â‚œâŠ›áµ£ r_id = t .
  <span class="bp">now</span> <span class="nb">apply</span> (term_ind_mut _ _ _ ren_id_l_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">v_ren_id_l</span> {<span class="nv">Î“</span>} <span class="nv">a</span> (<span class="nv">v</span> : val Î“ a) : v áµ¥âŠ›áµ£ r_id = v.
  <span class="bp">now</span> <span class="nb">apply</span> (val_ind_mut _ _ _ ren_id_l_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">e_ren_id_l</span> {<span class="nv">Î“</span>} <span class="nv">a</span> (<span class="nv">Ï€</span> : ev_ctx Î“ a) : Ï€ â‚‘âŠ›áµ£ r_id = Ï€ .
  <span class="bp">now</span> <span class="nb">apply</span> (ctx_ind_mut _ _ _ ren_id_l_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">m_ren_id_l</span> {<span class="nv">Î“</span>} <span class="nv">a</span> (<span class="nv">v</span> : val_m Î“ a) : v â‚˜âŠ›áµ£ r_id = v .
  <span class="nb">destruct</span> a; [ <span class="bp">now</span> <span class="nb">apply</span> v_ren_id_l | <span class="bp">now</span> <span class="nb">apply</span> e_ren_id_l ].
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">s_ren_id_l</span> {<span class="nv">Î“</span>} (<span class="nv">s</span> : state Î“) : s â‚›âŠ›áµ£ r_id = s.
  <span class="nb">destruct</span> s; <span class="nb">apply</span> (f_equal2 Cut); [ <span class="bp">now</span> <span class="nb">apply</span> t_ren_id_l | <span class="bp">now</span> <span class="nb">apply</span> e_ren_id_l ].
<span class="kn">Qed</span>.</span></pre><p>Lemma 4: right identity law of renaming. This one basically holds
definitionally, it only needs a case split for some of the derived notions. We
will also prove a consequence on weakenings: identity law.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Lemma</span> <span class="nf">m_ren_id_r</span> {<span class="nv">Î“</span> <span class="nv">Î”</span>} (<span class="nv">f</span> : Î“ âŠ† Î”) {<span class="nv">a</span>} (<span class="nv">i</span> : Î“ âˆ‹ a) : a_id _ i â‚˜âŠ›áµ£ f = a_id _ (f _ i) .
  <span class="bp">now</span> <span class="nb">destruct</span> a.
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">a_ren_id_r</span> {<span class="nv">Î“</span> <span class="nv">Î”</span>} (<span class="nv">f</span> : Î“ âŠ† Î”) : a_id âŠ›áµ£ f â‰¡â‚ f áµ£âŠ› a_id .
  <span class="nb">intros</span> ??; <span class="bp">now</span> <span class="nb">apply</span> m_ren_id_r.
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">a_shift2_id</span> {<span class="nv">Î“</span> <span class="nv">x</span> <span class="nv">y</span>} : @a_shift2 Î“ Î“ x y a_id â‰¡â‚ a_id.
  <span class="nb">intros</span> ? v; <span class="kp">do</span> <span class="mi">2</span> (dependent elimination v; <span class="nb">auto</span>).
  <span class="bp">exact</span> (m_ren_id_r _ _).
<span class="kn">Qed</span>.</span></pre><p>Lemma 5: shifting assigments commutes with left and right renaming.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Lemma</span> <span class="nf">a_shift2_s_ren</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> <span class="nv">a</span> <span class="nv">b</span>} (<span class="nv">f1</span> : Î“1 âŠ† Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3)
  : @a_shift2 _ _ a b (f1 áµ£âŠ› f2) â‰¡â‚ r_shift2 f1 áµ£âŠ› a_shift2 f2 .
  <span class="nb">intros</span> ? v; <span class="kp">do</span> <span class="mi">2</span> (dependent elimination v; <span class="nb">auto</span>).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">a_shift2_a_ren</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> <span class="nv">a</span> <span class="nv">b</span>} (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 âŠ† Î“3)
      : @a_shift2 _ _ a b (f1 âŠ›áµ£ f2) â‰¡â‚ a_shift2 f1 âŠ›áµ£ r_shift2 f2 .
  <span class="nb">intros</span> ? v.
  <span class="kp">do</span> <span class="mi">2</span> (dependent elimination v; <span class="nb">cbn</span>; [ <span class="nb">symmetry</span>; <span class="bp">exact</span> (a_ren_id_r _ _ _) | ]).
  <span class="nb">unfold</span> a_ren; <span class="nb">cbn</span> - [ m_rename ]; <span class="nb">unfold</span> m_shift2; <span class="bp">now</span> <span class="nb">rewrite</span> <span class="mi">2</span> m_ren_ren.
<span class="kn">Qed</span>.</span></pre><p>Lemma 6: substitution respects pointwise equality of assigments.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">t_sub_proper_P</span> <span class="nv">Î“</span> <span class="nv">a</span> (<span class="nv">t</span> : term Î“ a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î”</span> (<span class="nv">f1</span> <span class="nv">f2</span> : Î“ =[val_m]&gt; Î”), f1 â‰¡â‚ f2 -&gt; t `â‚œâŠ› f1 = t `â‚œâŠ› f2 .
<span class="kn">Definition</span> <span class="nf">v_sub_proper_P</span> <span class="nv">Î“</span> <span class="nv">a</span> (<span class="nv">v</span> : val Î“ a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î”</span> (<span class="nv">f1</span> <span class="nv">f2</span> : Î“ =[val_m]&gt; Î”), f1 â‰¡â‚ f2 -&gt; v `áµ¥âŠ› f1 = v `áµ¥âŠ› f2 .
<span class="kn">Definition</span> <span class="nf">e_sub_proper_P</span> <span class="nv">Î“</span> <span class="nv">a</span> (<span class="nv">Ï€</span> : ev_ctx Î“ a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î”</span> (<span class="nv">f1</span> <span class="nv">f2</span> : Î“ =[val_m]&gt; Î”), f1 â‰¡â‚ f2 -&gt; Ï€ `â‚‘âŠ› f1 = Ï€ `â‚‘âŠ› f2.
<span class="kn">Lemma</span> <span class="nf">sub_proper_prf</span> : syn_ind_args t_sub_proper_P v_sub_proper_P e_sub_proper_P.
  <span class="nb">econstructor</span>.
  <span class="kp">all</span>: <span class="nb">unfold</span> t_sub_proper_P, v_sub_proper_P, e_sub_proper_P.
  <span class="kp">all</span>: <span class="nb">intros</span>; <span class="nb">cbn</span>; <span class="nb">f_equal</span>; <span class="nb">auto</span>.
  <span class="bp">now</span> <span class="nb">apply</span> H, a_shift2_eq.
<span class="kn">Qed</span>.

#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">t_sub_eq</span> {<span class="nv">Î“</span> <span class="nv">Î”</span>}
  : Proper (asgn_eq _ _ ==&gt; forall_relation (<span class="kr">fun</span> <span class="nv">a</span> =&gt; eq ==&gt; eq)) (@t_subst Î“ Î”).
  <span class="nb">intros</span> ? ? H1 a _ ? -&gt;; <span class="bp">now</span> <span class="nb">apply</span> (term_ind_mut _ _ _ sub_proper_prf).
<span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">v_sub_eq</span> {<span class="nv">Î“</span> <span class="nv">Î”</span>}
  : Proper (asgn_eq _ _ ==&gt; forall_relation (<span class="kr">fun</span> <span class="nv">a</span> =&gt; eq ==&gt; eq)) (@v_subst Î“ Î”).
  <span class="nb">intros</span> ? ? H1 a _ ? -&gt;; <span class="bp">now</span> <span class="nb">apply</span> (val_ind_mut _ _ _ sub_proper_prf).
<span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">e_sub_eq</span> {<span class="nv">Î“</span> <span class="nv">Î”</span>}
  : Proper (asgn_eq _ _ ==&gt; forall_relation (<span class="kr">fun</span> <span class="nv">a</span> =&gt; eq ==&gt; eq)) (@e_subst Î“ Î”).
  <span class="nb">intros</span> ? ? H1 a _ ? -&gt;; <span class="bp">now</span> <span class="nb">apply</span> (ctx_ind_mut _ _ _ sub_proper_prf).
<span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">m_sub_eq</span>
  : Proper (<span class="kr">âˆ€</span><span class="nv">â‚•</span> <span class="nv">Î“</span>, <span class="kr">âˆ€</span><span class="nv">â‚•</span> <span class="nv">_</span>, eq ==&gt; <span class="kr">âˆ€</span><span class="nv">â‚•</span> <span class="nv">Î”</span>, asgn_eq Î“ Î” ==&gt; eq) m_subst.
  <span class="nb">intros</span> ? [] ?? -&gt; ??? H1; <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="bp">now</span> <span class="nb">rewrite</span> H1.
<span class="kn">Qed</span>.
#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">s_sub_eq</span>
  : Proper (<span class="kr">âˆ€</span><span class="nv">â‚•</span> <span class="nv">Î“</span>, eq ==&gt; <span class="kr">âˆ€</span><span class="nv">â‚•</span> <span class="nv">Î”</span>, asgn_eq Î“ Î” ==&gt; eq) s_subst.
  <span class="nb">intros</span> ??[] -&gt; ??? H1; <span class="nb">cbn</span>; <span class="bp">now</span> <span class="nb">rewrite</span> H1.
<span class="kn">Qed</span>.
<span class="c">(*</span>
<span class="c">#[global] Instance a_comp_eq {Î“1 Î“2 Î“3} : Proper (ass_eq _ _ ==&gt; ass_eq _ _ ==&gt; ass_eq _ _) (@a_comp Î“1 Î“2 Î“3).</span>
<span class="c">  intros ? ? H1 ? ? H2 ? ?; unfold a_comp, s_map; now rewrite H1, H2.</span>
<span class="c">Qed.</span>
<span class="c">*)</span></span></pre><p>Lemma 7: renaming-substitution &quot;associativity&quot;.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">t_ren_sub_P</span> <span class="nv">Î“1</span> <span class="nv">a</span> (<span class="nv">t</span> : term Î“1 a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 âŠ† Î“3) ,
    (t `â‚œâŠ› f1) â‚œâŠ›áµ£ f2 = t `â‚œâŠ› (f1 âŠ›áµ£ f2) .
<span class="kn">Definition</span> <span class="nf">v_ren_sub_P</span> <span class="nv">Î“1</span> <span class="nv">a</span> (<span class="nv">v</span> : val Î“1 a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 âŠ† Î“3) ,
    (v `áµ¥âŠ› f1) áµ¥âŠ›áµ£ f2 = v `áµ¥âŠ› (f1 âŠ›áµ£ f2) .
<span class="kn">Definition</span> <span class="nf">e_ren_sub_P</span> <span class="nv">Î“1</span> <span class="nv">a</span> (<span class="nv">Ï€</span> : ev_ctx Î“1 a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 âŠ† Î“3) ,
    (Ï€ `â‚‘âŠ› f1) â‚‘âŠ›áµ£ f2 = Ï€ `â‚‘âŠ› (f1 âŠ›áµ£ f2) .
<span class="kn">Lemma</span> <span class="nf">ren_sub_prf</span> : syn_ind_args t_ren_sub_P v_ren_sub_P e_ren_sub_P.
  <span class="nb">econstructor</span>.
  <span class="kp">all</span>: <span class="nb">unfold</span> t_ren_sub_P, v_ren_sub_P, e_ren_sub_P.
  <span class="kp">all</span>: <span class="nb">intros</span>; <span class="nb">cbn</span>; <span class="nb">f_equal</span>.
  <span class="kp">all</span>: <span class="kp">try</span> <span class="nb">rewrite</span> a_shift2_a_ren; <span class="nb">auto</span>.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">t_ren_sub</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 âŠ† Î“3) <span class="nv">a</span> (<span class="nv">t</span> : term Î“1 a)
  : (t `â‚œâŠ› f1) â‚œâŠ›áµ£ f2 = t `â‚œâŠ› (f1 âŠ›áµ£ f2) .
  <span class="bp">now</span> <span class="nb">apply</span> (term_ind_mut _ _ _ ren_sub_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">v_ren_sub</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 âŠ† Î“3) <span class="nv">a</span> (<span class="nv">v</span> : val Î“1 a)
  : (v `áµ¥âŠ› f1) áµ¥âŠ›áµ£ f2 = v `áµ¥âŠ› (f1 âŠ›áµ£ f2) .
  <span class="bp">now</span> <span class="nb">apply</span> (val_ind_mut _ _ _ ren_sub_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">e_ren_sub</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 âŠ† Î“3) <span class="nv">a</span> (<span class="nv">Ï€</span> : ev_ctx Î“1 a)
  : (Ï€ `â‚‘âŠ› f1) â‚‘âŠ›áµ£ f2 = Ï€ `â‚‘âŠ› (f1 âŠ›áµ£ f2) .
  <span class="bp">now</span> <span class="nb">apply</span> (ctx_ind_mut _ _ _ ren_sub_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">m_ren_sub</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 âŠ† Î“3) <span class="nv">a</span> (<span class="nv">v</span> : val_m Î“1 a)
  : (v áµ¥âŠ› f1) â‚˜âŠ›áµ£ f2 = v áµ¥âŠ› (f1 âŠ›áµ£ f2) .
  <span class="nb">destruct</span> a; [ <span class="bp">now</span> <span class="nb">apply</span> v_ren_sub | <span class="bp">now</span> <span class="nb">apply</span> e_ren_sub ].
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">s_ren_sub</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 âŠ† Î“3) (<span class="nv">s</span> : state Î“1)
  : (s â‚œâŠ› f1) â‚›âŠ›áµ£ f2 = s â‚œâŠ› (f1 âŠ›áµ£ f2) .
  <span class="nb">destruct</span> s; <span class="nb">cbn</span>; <span class="bp">now</span> <span class="nb">rewrite</span> t_ren_sub, e_ren_sub.
<span class="kn">Qed</span>.</span></pre><p>Lemma 8: substitution-renaming &quot;associativity&quot;.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">t_sub_ren_P</span> <span class="nv">Î“1</span> <span class="nv">a</span> (<span class="nv">t</span> : term Î“1 a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> (<span class="nv">f1</span> : Î“1 âŠ† Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3) ,
  (t â‚œâŠ›áµ£ f1) `â‚œâŠ› f2 = t `â‚œâŠ› (f1 áµ£âŠ› f2) .
<span class="kn">Definition</span> <span class="nf">v_sub_ren_P</span> <span class="nv">Î“1</span> <span class="nv">a</span> (<span class="nv">v</span> : val Î“1 a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> (<span class="nv">f1</span> : Î“1 âŠ† Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3) ,
  (v áµ¥âŠ›áµ£ f1) `áµ¥âŠ› f2 = v `áµ¥âŠ› (f1 áµ£âŠ› f2) .
<span class="kn">Definition</span> <span class="nf">e_sub_ren_P</span> <span class="nv">Î“1</span> <span class="nv">a</span> (<span class="nv">Ï€</span> : ev_ctx Î“1 a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> (<span class="nv">f1</span> : Î“1 âŠ† Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3) ,
  (Ï€ â‚‘âŠ›áµ£ f1) `â‚‘âŠ› f2 = Ï€ `â‚‘âŠ› (f1 áµ£âŠ› f2) .
<span class="kn">Lemma</span> <span class="nf">sub_ren_prf</span> : syn_ind_args t_sub_ren_P v_sub_ren_P e_sub_ren_P.
  <span class="nb">econstructor</span>.
  <span class="kp">all</span>: <span class="nb">unfold</span> t_sub_ren_P, v_sub_ren_P, e_sub_ren_P.
  <span class="kp">all</span>: <span class="nb">intros</span>; <span class="nb">cbn</span>; <span class="nb">f_equal</span>; <span class="nb">auto</span>.
  <span class="bp">now</span> <span class="nb">rewrite</span> a_shift2_s_ren.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">t_sub_ren</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 âŠ† Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3) <span class="nv">a</span> (<span class="nv">t</span> : term Î“1 a)
  : (t â‚œâŠ›áµ£ f1) `â‚œâŠ› f2 = t `â‚œâŠ› (f1 áµ£âŠ› f2) .
  <span class="bp">now</span> <span class="nb">apply</span> (term_ind_mut _ _ _ sub_ren_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">v_sub_ren</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 âŠ† Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3) <span class="nv">a</span> (<span class="nv">v</span> : val Î“1 a)
  : (v áµ¥âŠ›áµ£ f1) `áµ¥âŠ› f2 = v `áµ¥âŠ› (f1 áµ£âŠ› f2) .
  <span class="bp">now</span> <span class="nb">apply</span> (val_ind_mut _ _ _ sub_ren_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">e_sub_ren</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 âŠ† Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3) <span class="nv">a</span> (<span class="nv">Ï€</span> : ev_ctx Î“1 a)
  : (Ï€ â‚‘âŠ›áµ£ f1) `â‚‘âŠ› f2 = Ï€ `â‚‘âŠ› (f1 áµ£âŠ› f2) .
  <span class="bp">now</span> <span class="nb">apply</span> (ctx_ind_mut _ _ _ sub_ren_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">m_sub_ren</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 âŠ† Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3) <span class="nv">a</span> (<span class="nv">v</span> : val_m Î“1 a)
  : (v â‚˜âŠ›áµ£ f1) áµ¥âŠ› f2 = v áµ¥âŠ› (f1 áµ£âŠ› f2) .
  <span class="nb">destruct</span> a; [ <span class="bp">now</span> <span class="nb">apply</span> v_sub_ren | <span class="bp">now</span> <span class="nb">apply</span> e_sub_ren ].
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">s_sub_ren</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 âŠ† Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3) (<span class="nv">s</span> : state Î“1)
  : (s â‚›âŠ›áµ£ f1) â‚œâŠ› f2 = s â‚œâŠ› (f1 áµ£âŠ› f2) .
  <span class="nb">destruct</span> s; <span class="nb">cbn</span>; <span class="bp">now</span> <span class="nb">rewrite</span> t_sub_ren, e_sub_ren.
<span class="kn">Qed</span>.</span></pre><p>Lemma 9: left identity law of substitution.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">t_sub_id_l_P</span> <span class="nv">Î“</span> <span class="nv">a</span> (<span class="nv">t</span> : term Î“ a) : <span class="kt">Prop</span> := t `â‚œâŠ› a_id = t .
<span class="kn">Definition</span> <span class="nf">v_sub_id_l_P</span> <span class="nv">Î“</span> <span class="nv">a</span> (<span class="nv">v</span> : val Î“ a) : <span class="kt">Prop</span> := v `áµ¥âŠ› a_id = v .
<span class="kn">Definition</span> <span class="nf">e_sub_id_l_P</span> <span class="nv">Î“</span> <span class="nv">a</span> (<span class="nv">Ï€</span> : ev_ctx Î“ a) : <span class="kt">Prop</span> := Ï€ `â‚‘âŠ› a_id = Ï€ .
<span class="kn">Lemma</span> <span class="nf">sub_id_l_prf</span> : syn_ind_args t_sub_id_l_P v_sub_id_l_P e_sub_id_l_P.
  <span class="nb">econstructor</span>.
  <span class="kp">all</span>: <span class="nb">unfold</span> t_sub_id_l_P, v_sub_id_l_P, e_sub_id_l_P.
  <span class="kp">all</span>: <span class="nb">intros</span>; <span class="nb">cbn</span>; <span class="nb">f_equal</span>; <span class="nb">auto</span>.
  <span class="bp">now</span> <span class="nb">rewrite</span> a_shift2_id.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">t_sub_id_l</span> {<span class="nv">Î“</span>} <span class="nv">a</span> (<span class="nv">t</span> : term Î“ a) : t `â‚œâŠ› a_id = t .
  <span class="bp">now</span> <span class="nb">apply</span> (term_ind_mut _ _ _ sub_id_l_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">v_sub_id_l</span> {<span class="nv">Î“</span>} <span class="nv">a</span> (<span class="nv">v</span> : val Î“ a) : v `áµ¥âŠ› a_id = v .
  <span class="bp">now</span> <span class="nb">apply</span> (val_ind_mut _ _ _ sub_id_l_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">e_sub_id_l</span> {<span class="nv">Î“</span>} <span class="nv">a</span> (<span class="nv">Ï€</span> : ev_ctx Î“ a) : Ï€ `â‚‘âŠ› a_id = Ï€ .
  <span class="bp">now</span> <span class="nb">apply</span> (ctx_ind_mut _ _ _ sub_id_l_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">m_sub_id_l</span> {<span class="nv">Î“</span>} <span class="nv">a</span> (<span class="nv">v</span> : val_m Î“ a) : v áµ¥âŠ› a_id = v .
  <span class="nb">destruct</span> a; [ <span class="bp">now</span> <span class="nb">apply</span> v_sub_id_l | <span class="bp">now</span> <span class="nb">apply</span> e_sub_id_l ].
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">s_sub_id_l</span> {<span class="nv">Î“</span>} (<span class="nv">s</span> : state Î“) : s â‚œâŠ› a_id = s .
  <span class="nb">destruct</span> s; <span class="nb">cbn</span>; <span class="bp">now</span> <span class="nb">rewrite</span> t_sub_id_l, e_sub_id_l.
<span class="kn">Qed</span>.</span></pre><p>Lemma 9: right identity law of substitution. As for renaming, this one is
mostly by definition.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Lemma</span> <span class="nf">m_sub_id_r</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span>} {<span class="nv">a</span>} (<span class="nv">i</span> : Î“1 âˆ‹ a) (<span class="nv">f</span> : Î“1 =[val_m]&gt; Î“2) : a_id a i áµ¥âŠ› f = f a i.
  <span class="bp">now</span> <span class="nb">destruct</span> a.
<span class="kn">Qed</span>.</span></pre><p>Lemma 10: shifting assigments respects composition.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Lemma</span> <span class="nf">a_shift2_comp</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> <span class="nv">a</span> <span class="nv">b</span>} (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3) 
  : @a_shift2 _ _ a b (f1 âŠ› f2) â‰¡â‚ a_shift2 f1 âŠ› a_shift2 f2 .
  <span class="nb">intros</span> ? v. 
  <span class="kp">do</span> <span class="mi">2</span> (dependent elimination v; [ <span class="nb">symmetry</span>; <span class="bp">exact</span> (m_sub_id_r _ _) | ]).
  <span class="nb">cbn</span>; <span class="nb">unfold</span> m_shift2; <span class="bp">now</span> <span class="nb">rewrite</span> m_ren_sub, m_sub_ren.
<span class="kn">Qed</span>.</span></pre><p>Lemma 11: substitution-substitution associativity, ie composition law.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">t_sub_sub_P</span> <span class="nv">Î“1</span> <span class="nv">a</span> (<span class="nv">t</span> : term Î“1 a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3) ,
  t `â‚œâŠ› (f1 âŠ› f2) = (t `â‚œâŠ› f1) `â‚œâŠ› f2 .
<span class="kn">Definition</span> <span class="nf">v_sub_sub_P</span> <span class="nv">Î“1</span> <span class="nv">a</span> (<span class="nv">v</span> : val Î“1 a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3) ,
  v `áµ¥âŠ› (f1 âŠ› f2) = (v `áµ¥âŠ› f1) `áµ¥âŠ› f2 .
<span class="kn">Definition</span> <span class="nf">e_sub_sub_P</span> <span class="nv">Î“1</span> <span class="nv">a</span> (<span class="nv">Ï€</span> : ev_ctx Î“1 a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3) ,
  Ï€ `â‚‘âŠ› (f1 âŠ› f2) = (Ï€ `â‚‘âŠ› f1) `â‚‘âŠ› f2 .
<span class="kn">Lemma</span> <span class="nf">sub_sub_prf</span> : syn_ind_args t_sub_sub_P v_sub_sub_P e_sub_sub_P.
  <span class="nb">econstructor</span>.
  <span class="kp">all</span>: <span class="nb">unfold</span> t_sub_sub_P, v_sub_sub_P, e_sub_sub_P.
  <span class="kp">all</span>: <span class="nb">intros</span>; <span class="nb">cbn</span>; <span class="nb">f_equal</span>; <span class="nb">auto</span>.
  <span class="bp">now</span> <span class="nb">rewrite</span> a_shift2_comp.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">t_sub_sub</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3) <span class="nv">a</span> (<span class="nv">t</span> : term Î“1 a)
  : t `â‚œâŠ› (f1 âŠ› f2) = (t `â‚œâŠ› f1) `â‚œâŠ› f2 .
  <span class="bp">now</span> <span class="nb">apply</span> (term_ind_mut _ _ _ sub_sub_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">v_sub_sub</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3) <span class="nv">a</span> (<span class="nv">v</span> : val Î“1 a)
  : v `áµ¥âŠ› (f1 âŠ› f2) = (v `áµ¥âŠ› f1) `áµ¥âŠ› f2 .
  <span class="bp">now</span> <span class="nb">apply</span> (val_ind_mut _ _ _ sub_sub_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">e_sub_sub</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3) <span class="nv">a</span> (<span class="nv">Ï€</span> : ev_ctx Î“1 a)
  : Ï€ `â‚‘âŠ› (f1 âŠ› f2) = (Ï€ `â‚‘âŠ› f1) `â‚‘âŠ› f2 .
  <span class="bp">now</span> <span class="nb">apply</span> (ctx_ind_mut _ _ _ sub_sub_prf).
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">m_sub_sub</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} <span class="nv">a</span> (<span class="nv">v</span> : val_m Î“1 a) (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3)
  : v áµ¥âŠ› (f1 âŠ› f2) = (v áµ¥âŠ› f1) áµ¥âŠ› f2 .
  <span class="nb">destruct</span> a; [ <span class="bp">now</span> <span class="nb">apply</span> v_sub_sub | <span class="bp">now</span> <span class="nb">apply</span> e_sub_sub ].
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">s_sub_sub</span> {<span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span>} (<span class="nv">s</span> : state Î“1) (<span class="nv">f1</span> : Î“1 =[val_m]&gt; Î“2) (<span class="nv">f2</span> : Î“2 =[val_m]&gt; Î“3) 
  : s â‚œâŠ› (f1 âŠ› f2) = (s â‚œâŠ› f1) â‚œâŠ› f2 .
  <span class="nb">destruct</span> s; <span class="nb">cbn</span>; <span class="bp">now</span> <span class="nb">rewrite</span> t_sub_sub, e_sub_sub.
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">a_sub2_sub</span> {<span class="nv">Î“</span> <span class="nv">Î”</span> <span class="nv">a</span> <span class="nv">b</span>} (<span class="nv">f</span> : Î“ =[val_m]&gt; Î”) (<span class="nv">v1</span> : val_m Î“ a) (<span class="nv">v2</span> : val_m Î“ b)
  : a_shift2 f âŠ› assign2 (v1 áµ¥âŠ› f) (v2 áµ¥âŠ› f) â‰¡â‚ (assign2 v1 v2) âŠ› f .
  <span class="nb">intros</span> ? v.
  <span class="kp">do</span> <span class="mi">2</span> (dependent elimination v; [ <span class="nb">cbn</span>; <span class="bp">now</span> <span class="nb">rewrite</span> m_sub_id_r | ]).
  <span class="nb">cbn</span>; <span class="nb">unfold</span> m_shift2; <span class="nb">rewrite</span> m_sub_ren, m_sub_id_r.
  <span class="bp">now</span> <span class="nb">apply</span> m_sub_id_l.
<span class="kn">Qed</span>.
<span class="kn">Lemma</span> <span class="nf">t_sub2_sub</span> {<span class="nv">Î“</span> <span class="nv">Î”</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>} (<span class="nv">f</span> : Î“ =[val_m]&gt; Î”) (<span class="nv">t</span> : term (Î“ â–¶â‚“ x â–¶â‚“ y) z) <span class="nv">v1</span> <span class="nv">v2</span>
  : (t `â‚œâŠ› a_shift2 f) /[ v1 áµ¥âŠ› f , v2 áµ¥âŠ› f ] = (t /[ v1 , v2 ]) `â‚œâŠ› f.
  <span class="nb">unfold</span> t_subst2; <span class="bp">now</span> <span class="nb">rewrite</span> &lt;- <span class="mi">2</span> t_sub_sub, a_sub2_sub.
<span class="kn">Qed</span>.</span></pre></div>
<div class="section" id="the-actual-instance">
<h1>The Actual Instance</h1>
<p>Having proved all the basic syntactic properties of STLC, we are now ready to
instanciate our framework!</p>
<p>As we only have negative types, we instanciate the interaction specification
with types and observations. Beware that in more involved cases, the notion of
&quot;types&quot; we give to the OGS construction does not coincide with the
&quot;language types&quot;: you should only give the negative types, or more intuitively,
&quot;non-shareable&quot; types.</p>
<p>As hinted at the beginning, we instanciate the abstract value notion with our
&quot;machine values&quot;. They form a suitable monoid, which means we get a category
of assigments, for which we now provide the proof of the laws.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">stlc_val_laws</span> : subst_monoid_laws val_m :=
  {| v_sub_proper := @m_sub_eq ;
     v_sub_var := @m_sub_id_r ;
     v_var_sub := @m_sub_id_l ;
     Subst.v_sub_sub := @m_sub_sub |} .</span></span></pre><p>Configurations are instanciated with our states, and what we have proved
earlier amounts to showing they are a right-module on values.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">stlc_conf_laws</span> : subst_module_laws val_m state :=
  {| c_sub_proper := @s_sub_eq ;
     c_var_sub := @s_sub_id_l ;
     c_sub_sub := @s_sub_sub |} .</span></span></pre><p>In our generic theorem, there is a finicky lemma that is the counter-part to
the exclusion of any &quot;infinite chit-chat&quot; that one finds in other accounts of
OGS and other game semantics. The way we have proved it requires a little bit
more structure on values. Specifically, we need to show that <code class="highlight coq"><span class="n">a_id</span></code> is
injective and that its fibers are decidable and invert renamings. These
technicalities are easily shown by induction on values but help us to
distinguish conveniently between values which are variables and others.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">stlc_var_laws</span> : var_assumptions val_m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">econstructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? [] ?? H; <span class="bp">now</span> <span class="nb">dependent destruction</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? [] []; <span class="kp">try</span> <span class="bp">now</span> <span class="nb">apply</span> Yes; <span class="bp">exact</span> (Vvar _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">apply</span> No; <span class="nb">intro</span> H; <span class="nb">dependent destruction</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ?? [] v r H; <span class="nb">induction</span> v; <span class="nb">dependent destruction</span> H; <span class="bp">exact</span> (Vvar _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>We now instanciate the machine with <code class="highlight coq"><span class="n">stlc_eval</span></code> as the active step (&quot;compute
the next observable action&quot;) and <code class="highlight coq"><span class="n">obs_app</span></code> as the passive step (&quot;resume from
a stuck state&quot;).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">stlc_machine</span> : machine val_m state obs_op :=
  {| <span class="kp">eval</span> := @stlc_eval ;
     oapp := @obs_app |} .</span></span></pre><p>All that is left is to prove our theorem-specific hypotheses. All but another
technical lemma for the chit-chat problem are again coherence conditions
between <code class="highlight coq"><span class="kp">eval</span></code> and <code class="highlight coq"><span class="n">app</span></code> and the monoidal structure of values and
configurations.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">stlc_machine_law</span> : machine_laws val_m state obs_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">econstructor</span>; <span class="nb">cbn</span>; <span class="nb">intros</span>.</span></span></pre><p>The first one proves that <code class="highlight coq"><span class="n">obs_app</span></code> respects pointwise equality of assigments.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ?? H1; dependent elimination o; <span class="nb">cbn</span>; <span class="kp">repeat</span> (<span class="nb">f_equal</span>; <span class="nb">auto</span>).</span></span></pre><p>The second one proves a commutation law of <code class="highlight coq"><span class="n">obs_app</span></code> with renamings.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> x; dependent elimination o; <span class="nb">cbn</span>; <span class="nb">f_equal</span>.</span></span></pre><p>The meat of our abstract proof is this next one. We need to prove that our
evaluator respects substitution in a suitable sense: evaluating a substituted
configuration must be the same thing as evaluating the configuration, then
&quot;substituting&quot; the normal form and continuing the evaluation.</p>
<p>While potentially scary, the proof is direct and this actually amount to
checking that indeed, when unrolling our evaluator, this is what happens.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">revert</span> c a; <span class="nb">unfold</span> comp_eq, it_eq; coinduction R CIH; <span class="nb">intros</span> c e.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span>; funelim (eval_step c); <span class="nb">cbn</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">+</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (e Â¬ a0 i); <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="nb">remember</span> (v `áµ¥âŠ› e) <span class="kr">as</span> v&#39;; <span class="nb">clear</span> H v Heqv&#39;.
      dependent elimination v&#39;; <span class="nb">cbn</span>; <span class="nb">auto</span>.
    + <span class="nb">econstructor</span>; refold_eval; <span class="nb">apply</span> CIH.
    + <span class="nb">remember</span> (e + (a2 â†’ b0) i) <span class="kr">as</span> vv; <span class="nb">clear</span> H i Heqvv.
      dependent elimination vv; <span class="nb">cbn</span>; <span class="nb">auto</span>.
    + <span class="nb">econstructor</span>;
       refold_eval;
       <span class="nb">change</span> (Lam (t `â‚œâŠ› _)) <span class="kr">with</span> (Lam t `áµ¥âŠ› e);
       <span class="nb">change</span> (<span class="nl">?v</span> `áµ¥âŠ› <span class="nl">?a</span>) <span class="kr">with</span> ((v : val_m _ (+ _)) áµ¥âŠ› a).
      <span class="nb">rewrite</span> t_sub2_sub.
      <span class="nb">apply</span> CIH.
    + <span class="nb">econstructor</span>; refold_eval; <span class="nb">apply</span> CIH.</span></pre><p>Just like the above proof had the flavor of a composition law of module, this
one has the flavor of an identity law. It states that evaluating a normal form
is the identity computation.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> u <span class="kr">as</span> [ a i [ p Î³ ] ]; <span class="nb">cbn</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">dependent elimination p; <span class="nb">cbn</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">unfold</span> comp_eq; <span class="nb">apply</span> it_eq_unstep; <span class="nb">cbn</span>; <span class="nb">econstructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">econstructor</span>; <span class="nb">intros</span> ? v; <span class="kp">do</span> <span class="mi">3</span> (dependent elimination v; <span class="nb">auto</span>).</span></span></pre><p>This last proof is the technical condition we hinted at. It is a proof of
well-foundedness of some relation, and what it amounts to is that if we
repeatedly instantiate the head variable of a normal form by a value which is
not a variable, after a finite number of times doing so we will eventually
reach something that is not a normal form.</p>
<p>For our calculus this number is at most 2, the pathological state being
<code class="highlight coq"><span class="o">âŸ¨</span> <span class="n">x</span> <span class="o">|</span> <span class="n">y</span> <span class="o">âŸ©</span></code>, which starts by being stuck on <code class="highlight coq"><span class="n">y</span></code>, but when instanciating by
some non-variable <code class="highlight coq"><span class="n">Ï€</span></code>, <code class="highlight coq"><span class="o">âŸ¨</span> <span class="n">x</span> <span class="o">|</span> <span class="n">Ï€</span> <span class="o">âŸ©</span></code> is still stuck, this time on <code class="highlight coq"><span class="n">x</span></code>. After
another step it will definitely be unstuck and evaluation will be able to do
a reduction step.</p>
<p>It is slightly tedious to prove but amount again to a &quot;proof by case
splitting&quot;.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [ x p ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> x; dependent elimination p; <span class="nb">econstructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">*</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [ z p ] H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">dependent elimination p; dependent elimination H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: dependent elimination v; <span class="kp">try</span> <span class="bp">now</span> <span class="nb">destruct</span> (t0 (Vvar _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">apply</span> it_eq_step <span class="kr">in</span> i0; <span class="bp">now</span> <span class="nb">inversion</span> i0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">*</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [ z p ] H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">dependent elimination p; dependent elimination H; <span class="nb">cbn</span> <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">dependent elimination v; <span class="kp">try</span> <span class="bp">now</span> <span class="nb">destruct</span> (t0 (Vvar _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">+</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> it_eq_step <span class="kr">in</span> i0; <span class="bp">now</span> <span class="nb">inversion</span> i0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">+</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">remember</span> (a1 _ Ctx.top) <span class="kr">as</span> vv; <span class="nb">clear</span> a1 Heqvv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">dependent elimination vv;
          <span class="nb">apply</span> it_eq_step <span class="kr">in</span> i0; <span class="nb">cbn</span> <span class="kr">in</span> i0; dependent elimination i0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> r_rel.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">+</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">econstructor</span>; <span class="nb">intros</span> [ z p ] H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">dependent elimination p; dependent elimination H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: dependent elimination v0; <span class="kp">try</span> <span class="bp">now</span> <span class="nb">destruct</span> (t1 (Vvar _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">apply</span> it_eq_step <span class="kr">in</span> i2; <span class="bp">now</span> <span class="nb">inversion</span> i2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>At this point we have finished all the hard work! We already enjoy the generic
correctness theorem but don't know it yet! Lets define some shorthands for
some generic notions applied to our case, to make it a welcoming nest.</p>
<p>The whole semantic is parametrized by typing scope <code class="highlight coq"><span class="n">Î”</span></code> of &quot;final channels&quot;.
Typically this can be instanciated with the singleton <code class="highlight coq"><span class="o">[</span> <span class="o">Â¬</span> <span class="n">ans</span> <span class="o">]</span></code> for some
chosen type <code class="highlight coq"><span class="n">ans</span></code>, which will correspond with the outside type of the
testing-contexts from CIU-equivalence. Usually this answer type is taken among
the positive (or shareable) types of our language, but in fact using our
observation machinery we can project the value of any type onto its &quot;shareable
part&quot;. This is why our generic proof abstracts over this answer type and even
allows several of them at the same time (that is, <code class="highlight coq"><span class="n">Î”</span></code>). In our case, as all
types in our language are unshareable, the positive part of any value is
pretty useless: it is always a singleton. Yet our notion of testing still
distinguishes terminating from non-terminating programs.</p>
<p>As discussed in the paper, the &quot;native output&quot; of the generic theorem is
correctness with respect to an equivalence we call &quot;substitution equivalence&quot;.
We will recover a more standard CIU later on.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">subst_eq</span> <span class="nv">Î”</span> {<span class="nv">Î“</span>} : relation (state Î“) :=
  <span class="kr">fun</span> <span class="nv">u</span> <span class="nv">v</span> =&gt; <span class="kr">forall</span> <span class="nv">Ïƒ</span> : Î“ =[val_m]&gt; Î”, evalâ‚’ (u â‚œâŠ› Ïƒ) â‰ˆ evalâ‚’ (v â‚œâŠ› Ïƒ) .
<span class="kn">Notation</span> <span class="s2">&quot;x â‰ˆS[ Î” ]â‰ˆ y&quot;</span> := (subst_eq Î” x y) (<span class="kn">at level</span> <span class="mi">10</span>).</span></pre><p>Our semantic objects live in what is defined in the generic construction as
<code class="highlight coq"><span class="n">ogs_act</span></code>, that is active strategies for the OGS game. They come with their
own notion of equivalence, weak bisimilarity and we get to interpret states
into semantic objects.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">sem_act</span> <span class="nv">Î”</span> <span class="nv">Î“</span> := ogs_act (obs := obs_op) Î” (âˆ… â–¶â‚“ Î“) .

<span class="kn">Definition</span> <span class="nf">ogs_weq_act</span> <span class="nv">Î”</span> {<span class="nv">Î“</span>} : relation (sem_act Î” Î“) := <span class="kr">fun</span> <span class="nv">u</span> <span class="nv">v</span> =&gt; u â‰ˆ v .
<span class="kn">Notation</span> <span class="s2">&quot;u â‰ˆ[ Î” ]â‰ˆ v&quot;</span> := (ogs_weq_act Î” u v) (<span class="kn">at level</span> <span class="mi">40</span>).

<span class="kn">Definition</span> <span class="nf">interp_act_s</span> <span class="nv">Î”</span> {<span class="nv">Î“</span>} (<span class="nv">c</span> : state Î“) : sem_act Î” Î“ :=
  m_strat (âˆ… â–¶â‚“ Î“) (inj_init_act Î” c) .
<span class="kn">Notation</span> <span class="s2">&quot;OGSâŸ¦ t âŸ§&quot;</span> := (interp_act_s _ t) .</span></pre><p>We can now obtain our instance of the correctness result!</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Theorem</span> <span class="nf">stlc_subst_correct</span> <span class="nv">Î”</span> {<span class="nv">Î“</span>} (<span class="nv">x</span> <span class="nv">y</span> : state Î“)
  : OGSâŸ¦xâŸ§ â‰ˆ[Î”]â‰ˆ OGSâŸ¦yâŸ§ -&gt; x â‰ˆS[Î”]â‰ˆ y .
  <span class="bp">exact</span> (ogs_correction Î” x y).
<span class="kn">Qed</span>.</span></pre><div class="section" id="recovering-ciu-equivalence">
<h2>Recovering CIU-equivalence</h2>
<p>CIU-equivalence more usually defined as a relation on terms (and not some
states), and involves an evaluation context. In our formalism it amounts to
the following definition.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">ciu_eq</span> <span class="nv">Î”</span> {<span class="nv">Î“</span> <span class="nv">a</span>} : relation (term Î“ a) :=
  <span class="kr">fun</span> <span class="nv">u</span> <span class="nv">v</span> =&gt; <span class="kr">forall</span> (<span class="nv">Ïƒ</span> : Î“ =[val_m]&gt; Î”) (<span class="nv">Ï€</span> : ev_ctx Î” a),
      evalâ‚’ ((u `â‚œâŠ› Ïƒ) â‹… Ï€) â‰ˆ evalâ‚’ ((v `â‚œâŠ› Ïƒ) â‹… Ï€) .
<span class="kn">Notation</span> <span class="s2">&quot;x â‰ˆC[ Î” ]â‰ˆ y&quot;</span> := (ciu_eq Î” x y) (<span class="kn">at level</span> <span class="mi">10</span>).</span></pre><p>Now from a term we can always construct a state by naming it, that is, placing
the term opposite of a fresh context variable.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">c_init</span> {<span class="nv">Î“</span> <span class="nv">a</span>} (<span class="nv">t</span> : term Î“ a) : state (Î“ â–¶â‚“ Â¬ a)
  := t_shift _ t â‹… K0 Ctx.top .
<span class="kn">Notation</span> <span class="s2">&quot;TâŸ¦ t âŸ§&quot;</span> := (OGSâŸ¦ c_init t âŸ§) .</span></pre><p>Similarly, from an evaluation context and a substitution, we can form an
extended substitution. Without surprise these two constructions simplify well
in terms of substitution.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Definition</span> <span class="nf">a_of_sk</span> {<span class="nv">Î“</span> <span class="nv">Î”</span> <span class="nv">a</span>} (<span class="nv">Ïƒ</span> : Î“ =[val_m]&gt; Î”) (<span class="nv">Ï€</span> : ev_ctx Î” a)
  : (Î“ â–¶â‚“ Â¬ a) =[val_m]&gt; Î” := Ïƒ â–¶â‚ (Ï€ : val_m _ (Â¬ _)) .

<span class="kn">Lemma</span> <span class="nf">sub_init</span> {<span class="nv">Î“</span> <span class="nv">Î”</span> <span class="nv">a</span>} (<span class="nv">t</span> : term Î“ a) (<span class="nv">Ïƒ</span> : Î“ =[val_m]&gt; Î”) (<span class="nv">Ï€</span> : ev_ctx Î” a)
  : (t `â‚œâŠ› Ïƒ) â‹… Ï€ = c_init t â‚œâŠ› a_of_sk Ïƒ Ï€  .
  <span class="nb">cbn</span>; <span class="nb">unfold</span> t_shift; <span class="bp">now</span> <span class="nb">rewrite</span> t_sub_ren.
<span class="kn">Qed</span>.</span></pre><p>We can now obtain a correctness theorem with respect to standard
CIU-equivalence by embedding terms into states. Proving that CIU-equivalence
entails our substitution equivalence is left to the reader!</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Theorem</span> <span class="nf">stlc_ciu_correct</span> <span class="nv">Î”</span> {<span class="nv">Î“</span> <span class="nv">a</span>} (<span class="nv">x</span> <span class="nv">y</span> : term Î“ a)
  : TâŸ¦ x âŸ§ â‰ˆ[Î”]â‰ˆ TâŸ¦ y âŸ§ -&gt; x â‰ˆC[Î”]â‰ˆ y .
  <span class="nb">intros</span> H Ïƒ k; <span class="nb">rewrite</span> <span class="mi">2</span> sub_init.
  <span class="bp">now</span> <span class="nb">apply</span> stlc_subst_correct.
<span class="kn">Qed</span>.</span></pre><table class="docutils citation" frame="void" id="aacmm21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#citation-reference-1">[AACMM21]</a></td><td>Guillaume Allais et al, &quot;A type- and scope-safe universe of
syntaxes with binding: their semantics and proofs&quot;, 2021.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="fs22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#citation-reference-2">[FS22]</a></td><td>Marcelo Fiore &amp; Dmitrij Szamozvancev, &quot;Formal Metatheory of
Second-Order Abstract Syntax&quot;, 2022.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="l05" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#citation-reference-3">[L05]</a></td><td>Soren Lassen, &quot;Eager Normal Form Bisimulation&quot;, 2005.</td></tr>
</tbody>
</table>
</div>
</div>
</div>
</div></body>
</html>
