<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>Free context structure</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-windowed"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+â†‘</kbd> <kbd>Ctrl+â†“</kbd> to navigate, <kbd>Ctrl+ğŸ–±ï¸</kbd> to focus. On Mac, use <kbd>âŒ˜</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="free-context-structure">
<h1 class="title">Free context structure</h1>

<p>Here we instanciate our abstract notion of context structure with the most common example:
lists and DeBruijn indices. More pedantically, this is the free context structure over
a given set <tt class="docutils literal">X</tt>.</p>
<div class="section" id="contexts">
<h1>Contexts</h1>
<p>Contexts are simply lists, with the purely aesthetic choice of representing cons as
coming from the right. Note on paper: we write here &quot;Î“ â–¶ x&quot; instead of &quot;Î“ , x&quot;.</p>
<pre class="alectryon-io highlight" id="concretectx"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">ctx</span> (<span class="nv">X</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
| cnil : ctx X
| ccon : ctx X -&gt; X -&gt; ctx X.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;âˆ…â‚“&quot;</span> := (cnil) : ctx_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;Î“ â–¶â‚“ x&quot;</span> := (ccon Î“%ctx x) (<span class="kn">at level</span> <span class="mi">40</span>, <span class="kn">left associativity</span>) : ctx_scope.</span></span></pre><p>We wish to manipulate intrinsically typed terms. We hence need a tightly typed notion of
position in the context: rather than a loose index, <tt class="docutils literal">var x Î“</tt> is a proof of membership
of <tt class="docutils literal">x</tt> to <tt class="docutils literal">Î“</tt>: a well-scoped and well-typed DeBruijn index. See Ex. 5.</p>
<pre class="alectryon-io highlight" id="concretevar"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">var</span> {<span class="nv">X</span>} (<span class="nv">x</span> : X) : ctx X -&gt; <span class="kt">Type</span> :=
| top {Î“} : var x (Î“ â–¶â‚“ x)
| pop {Î“ y} : var x Î“ -&gt; var x (Î“ â–¶â‚“ y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cvar</span> {<span class="nv">X</span>} <span class="nv">Î“</span> <span class="nv">x</span> := @var X x Î“.</span></span></pre><p>A couple basic functions: length, concatenation and pointwise function application.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">c_length</span> {<span class="nv">X</span>} (<span class="nv">Î“</span> : ctx X) : nat :=
  c_length âˆ…â‚“       := Datatypes.O ;
  c_length (Î“ â–¶â‚“ _) := Datatypes.S (c_length Î“) .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">ccat</span> {<span class="nv">X</span>} : ctx X -&gt; ctx X -&gt; ctx X :=
  ccat Î“ âˆ…â‚“       := Î“ ;
  ccat Î“ (Î” â–¶â‚“ x) := ccat Î“ Î” â–¶â‚“ x .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">c_map</span> {<span class="nv">X</span> <span class="nv">Y</span>} : (X -&gt; Y) -&gt; ctx X -&gt; ctx Y :=
  c_map f âˆ…â‚“       := cnil ;
  c_map f (Î“ â–¶â‚“ x) := c_map f Î“ â–¶â‚“ f x .</span></span></pre><p>Implementation of the revelant part of the abstract context interface.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">free_context</span> {<span class="nv">X</span>} : <span class="kp">context</span> X (ctx X) :=
  {| c_emp := cnil ; c_cat := ccat ; c_var := cvar |}.</span></span></pre><p>Basic theory.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk0"><span class="kn">Lemma</span> <span class="nf">c_cat_empty_l</span> {<span class="nv">X</span> : <span class="kt">Type</span>} {<span class="nv">Î“</span> : ctx X} : (âˆ… +â–¶ Î“)%ctx = Î“.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">âˆ… +â–¶ Î“ = Î“</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">âˆ… +â–¶ Î“ = Î“</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> Î“; <span class="nb">eauto</span>; <span class="nb">cbn</span>; <span class="nb">f_equal</span>; <span class="nb">apply</span> IHÎ“.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk2"><span class="kn">Lemma</span> <span class="nf">c_cat_empty_r</span> {<span class="nv">X</span> : <span class="kt">Type</span>} {<span class="nv">Î“</span> : ctx X} : (Î“ +â–¶ âˆ…)%ctx = Î“.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Î“ +â–¶ âˆ… = Î“</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Î“ +â–¶ âˆ… = Î“</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk4"><span class="kn">Lemma</span> <span class="nf">c_map_cat</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">Î“</span> <span class="nv">Î”</span> : ctx X)
  : c_map f (Î“ +â–¶ Î”) = (c_map f Î“ +â–¶ c_map f Î”)%ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">c_map f (Î“ +â–¶ Î”) = c_map f Î“ +â–¶ c_map f Î”</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">c_map f (Î“ +â–¶ Î”) = c_map f Î“ +â–¶ c_map f Î”</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> Î”; <span class="nb">eauto</span>; <span class="nb">cbn</span>; <span class="nb">f_equal</span>; <span class="nb">apply</span> IHÎ”.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>A view-based inversion package for variables in mapped contexts.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">map_has</span> {<span class="nv">X</span> <span class="nv">Y</span>} {<span class="nv">f</span> : X -&gt; Y} (<span class="nv">Î“</span> : ctx X) {<span class="nv">x</span>} (<span class="nv">i</span> : Î“ âˆ‹ x) : c_map f Î“ âˆ‹ f x :=
  map_has (Î“ â–¶â‚“ _) top     := top ;
  map_has (Î“ â–¶â‚“ _) (pop i) := pop (map_has Î“ i) .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Arguments</span> map_has {X Y f Î“ x}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">has_map_view</span> {<span class="nv">X</span> <span class="nv">Y</span>} {<span class="nv">f</span> : X -&gt; Y} {<span class="nv">Î“</span>} : <span class="kr">forall</span> {<span class="nv">y</span>}, c_map f Î“ âˆ‹ y -&gt; <span class="kt">Type</span> :=
| HasMapV {x} (i : Î“ âˆ‹ x) : has_map_view (map_has i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk6"><span class="kn">Lemma</span> <span class="nf">view_has_map</span> {<span class="nv">X</span> <span class="nv">Y</span>} {<span class="nv">f</span> : X -&gt; Y} {<span class="nv">Î“</span>} [y] (i : c_map f Î“ âˆ‹ y) : has_map_view i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>Î“</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>c_map f Î“ âˆ‹ y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">has_map_view i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>Î“</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>c_map f Î“ âˆ‹ y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">has_map_view i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk8"><span class="nb">induction</span> Î“; dependent elimination i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>Î“</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>IHÎ“</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : c_map f Î“ âˆ‹ f x, has_map_view i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">has_map_view top</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ctx-v-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>Î“</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>var y (c_map f Î“)</span></span></span><br><span><var>IHÎ“</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : c_map f Î“ âˆ‹ y, has_map_view i</span></span></span><br></div><label class="goal-separator" for="ctx-v-chk9"><hr></label><div class="goal-conclusion">has_map_view (pop v)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chka">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>Î“</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>IHÎ“</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : c_map f Î“ âˆ‹ f x, has_map_view i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">has_map_view top</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (HasMapV top).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chkb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>Î“</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>var y (c_map f Î“)</span></span></span><br><span><var>IHÎ“</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : c_map f Î“ âˆ‹ y, has_map_view i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">has_map_view (pop v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (IHÎ“ v); <span class="bp">exact</span> (HasMapV (pop i)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Additional goodies.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">r_pop</span> {<span class="nv">X</span>} {<span class="nv">Î“</span> : ctx X} {<span class="nv">x</span>} : Î“ âŠ† (Î“ â–¶â‚“ x) :=
  <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">i</span> =&gt; pop i.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Arguments</span> r_pop _ _ _ _/.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">a_append</span> {<span class="nv">X</span>} {<span class="nv">Î“</span> <span class="nv">Î”</span> : ctx X} {<span class="nv">F</span> : Famâ‚ X (ctx X)} {<span class="nv">a</span>}
  : Î“ =[F]&gt; Î” -&gt; F Î” a -&gt; (Î“ â–¶â‚“ a) =[F]&gt; Î” :=
  a_append s z _ top     := z ;
  a_append s z _ (pop i) := s _ i .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;[ u ,â‚“ x ]&quot;</span> := (a_append u x) (<span class="kn">at level</span> <span class="mi">9</span>) : asgn_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chkc">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">a_append_eq</span> {<span class="nv">X</span> <span class="nv">Î“</span> <span class="nv">Î”</span> <span class="nv">F</span> <span class="nv">a</span>}
  : Proper (asgn_eq _ _ ==&gt; eq ==&gt; asgn_eq _ _) (@a_append X Î“ Î” F a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ X (ctx X)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (asgn_eq Î“ Î” ==&gt; eq ==&gt; asgn_eq (Î“ â–¶â‚“ a) Î”)
  a_append</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ X (ctx X)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (asgn_eq Î“ Î” ==&gt; eq ==&gt; asgn_eq (Î“ â–¶â‚“ a) Î”)
  a_append</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chke"><span class="nb">intros</span> ?? Hu ?? Hx ? i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ X (ctx X)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Î“ =[ F ]&gt; Î”</span></span></span><br><span><var>Hu</var><span class="hyp-type"><b>: </b><span>x â‰¡â‚ y</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>F Î” a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x0 = y0</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Î“ â–¶â‚“ a âˆ‹ a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([x,â‚“ x0])%asgn a0 i = ([y,â‚“ y0])%asgn a0 i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chkf">dependent elimination i; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“0, Î”</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ X (ctx X)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Î“0 =[ F ]&gt; Î”</span></span></span><br><span><var>Hu</var><span class="hyp-type"><b>: </b><span>x â‰¡â‚ y</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>F Î” a0</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x0 = y0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x0 = y0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ctx-v-chk10" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“1, Î”</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ X (ctx X)</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Î“1 =[ F ]&gt; Î”</span></span></span><br><span><var>Hu</var><span class="hyp-type"><b>: </b><span>x â‰¡â‚ y</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>F Î” y1</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x0 = y0</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>var a0 Î“1</span></span></span><br></div><label class="goal-separator" for="ctx-v-chk10"><hr></label><div class="goal-conclusion">x a0 v = y a0 v</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk11">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“0, Î”</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ X (ctx X)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Î“0 =[ F ]&gt; Î”</span></span></span><br><span><var>Hu</var><span class="hyp-type"><b>: </b><span>x â‰¡â‚ y</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>F Î” a0</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x0 = y0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x0 = y0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Hx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk12">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“1, Î”</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ X (ctx X)</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Î“1 =[ F ]&gt; Î”</span></span></span><br><span><var>Hu</var><span class="hyp-type"><b>: </b><span>x â‰¡â‚ y</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>F Î” y1</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x0 = y0</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>var a0 Î“1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x a0 v = y a0 v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> Hu.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>These concrete definition of shifts compute better than their <a class="reference external" href="Renaming.html#rshift">generic counterpart</a>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">r_shift1</span> {<span class="nv">X</span>} {<span class="nv">Î“</span> <span class="nv">Î”</span> : ctx X} {<span class="nv">a</span>} (<span class="nv">f</span> : Î“ âŠ† Î”)
  : (Î“ â–¶â‚“ a) âŠ† (Î” â–¶â‚“ a)
  := [ f áµ£âŠ› r_pop ,â‚“ top ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">r_shift2</span> {<span class="nv">X</span>} {<span class="nv">Î“</span> <span class="nv">Î”</span> : ctx X} {<span class="nv">a</span> <span class="nv">b</span>} (<span class="nv">f</span> : Î“ âŠ† Î”)
  : (Î“ â–¶â‚“ a â–¶â‚“ b) âŠ† (Î” â–¶â‚“ a â–¶â‚“ b)
  := [ [ f áµ£âŠ› r_pop áµ£âŠ› r_pop ,â‚“ pop top ] ,â‚“ top ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">r_shift3</span> {<span class="nv">X</span>} {<span class="nv">Î“</span> <span class="nv">Î”</span> : ctx X} {<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>} (<span class="nv">f</span> : Î“ âŠ† Î”)
  : (Î“ â–¶â‚“ a â–¶â‚“ b â–¶â‚“ c) âŠ† (Î” â–¶â‚“ a â–¶â‚“ b â–¶â‚“ c)
  := [ [ [ f áµ£âŠ› r_pop áµ£âŠ› r_pop áµ£âŠ› r_pop ,â‚“ pop (pop top) ] ,â‚“ pop top ] ,â‚“ top ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk13">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">r_shift1_eq</span> {<span class="nv">X</span> <span class="nv">Î“</span> <span class="nv">Î”</span> <span class="nv">a</span>}
  : Proper (asgn_eq _ _ ==&gt; asgn_eq _ _) (@r_shift1 X Î“ Î” a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (asgn_eq Î“ Î” ==&gt; asgn_eq (Î“ â–¶â‚“ a) (Î” â–¶â‚“ a))
  r_shift1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (asgn_eq Î“ Î” ==&gt; asgn_eq (Î“ â–¶â‚“ a) (Î” â–¶â‚“ a))
  r_shift1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ?? Hu; <span class="nb">unfold</span> r_shift1; <span class="bp">now</span> <span class="nb">rewrite</span> Hu.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk15">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">r_shift2_eq</span> {<span class="nv">X</span> <span class="nv">Î“</span> <span class="nv">Î”</span> <span class="nv">a</span> <span class="nv">b</span>}
  : Proper (asgn_eq _ _ ==&gt; asgn_eq _ _) (@r_shift2 X Î“ Î” a b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  (asgn_eq Î“ Î” ==&gt; asgn_eq (Î“ â–¶â‚“ a â–¶â‚“ b) (Î” â–¶â‚“ a â–¶â‚“ b))
  r_shift2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  (asgn_eq Î“ Î” ==&gt; asgn_eq (Î“ â–¶â‚“ a â–¶â‚“ b) (Î” â–¶â‚“ a â–¶â‚“ b))
  r_shift2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ?? Hu; <span class="nb">unfold</span> r_shift2; <span class="bp">now</span> <span class="nb">rewrite</span> Hu.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk17">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">r_shift3_eq</span> {<span class="nv">X</span> <span class="nv">Î“</span> <span class="nv">Î”</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>}
  : Proper (asgn_eq _ _ ==&gt; asgn_eq _ _) (@r_shift3 X Î“ Î” a b c).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  (asgn_eq Î“ Î” ==&gt;
   asgn_eq (Î“ â–¶â‚“ a â–¶â‚“ b â–¶â‚“ c) (Î” â–¶â‚“ a â–¶â‚“ b â–¶â‚“ c))
  r_shift3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk18"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  (asgn_eq Î“ Î” ==&gt;
   asgn_eq (Î“ â–¶â‚“ a â–¶â‚“ b â–¶â‚“ c) (Î” â–¶â‚“ a â–¶â‚“ b â–¶â‚“ c))
  r_shift3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ?? Hu; <span class="nb">unfold</span> r_shift3; <span class="bp">now</span> <span class="nb">rewrite</span> Hu.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk19"><span class="kn">Lemma</span> <span class="nf">r_shift1_id</span> {<span class="nv">X</span> <span class="nv">Î“</span> <span class="nv">a</span>} : @r_shift1 X Î“ Î“ a r_id â‰¡â‚ r_id .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r_shift1 r_id â‰¡â‚ r_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? v; <span class="bp">now</span> <span class="kp">repeat</span> (dependent elimination v; <span class="nb">auto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk1a"><span class="kn">Lemma</span> <span class="nf">r_shift2_id</span> {<span class="nv">X</span> <span class="nv">Î“</span> <span class="nv">a</span> <span class="nv">b</span>} : @r_shift2 X Î“ Î“ a b r_id â‰¡â‚ r_id .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r_shift2 r_id â‰¡â‚ r_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? v; <span class="bp">now</span> <span class="kp">repeat</span> (dependent elimination v; <span class="nb">auto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk1b"><span class="kn">Lemma</span> <span class="nf">r_shift3_id</span> {<span class="nv">X</span> <span class="nv">Î“</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>} : @r_shift3 X Î“ Î“ a b c r_id â‰¡â‚ r_id .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r_shift3 r_id â‰¡â‚ r_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? v; <span class="bp">now</span> <span class="kp">repeat</span> (dependent elimination v; <span class="nb">auto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk1c"><span class="kn">Lemma</span> <span class="nf">r_shift1_comp</span> {<span class="nv">X</span> <span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> <span class="nv">a</span>} (<span class="nv">r1</span> : Î“1 âŠ† Î“2) (<span class="nv">r2</span> : Î“2 âŠ† Î“3)
      : @r_shift1 X Î“1 Î“3 a (r1 áµ£âŠ› r2) â‰¡â‚ r_shift1 r1 áµ£âŠ› r_shift1 r2 .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“1, Î“2, Î“3</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>Î“1 âŠ† Î“2</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>Î“2 âŠ† Î“3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r_shift1 (r1 áµ£âŠ› r2) â‰¡â‚ r_shift1 r1 áµ£âŠ› r_shift1 r2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? v; <span class="bp">now</span> <span class="kp">repeat</span> (dependent elimination v; <span class="nb">auto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk1d"><span class="kn">Lemma</span> <span class="nf">r_shift2_comp</span> {<span class="nv">X</span> <span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> <span class="nv">a</span> <span class="nv">b</span>} (<span class="nv">r1</span> : Î“1 âŠ† Î“2) (<span class="nv">r2</span> : Î“2 âŠ† Î“3)
      : @r_shift2 X Î“1 Î“3 a b (r1 áµ£âŠ› r2) â‰¡â‚ r_shift2 r1 áµ£âŠ› r_shift2 r2 .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“1, Î“2, Î“3</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>Î“1 âŠ† Î“2</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>Î“2 âŠ† Î“3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r_shift2 (r1 áµ£âŠ› r2) â‰¡â‚ r_shift2 r1 áµ£âŠ› r_shift2 r2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? v; <span class="bp">now</span> <span class="kp">repeat</span> (dependent elimination v; <span class="nb">auto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk1e"><span class="kn">Lemma</span> <span class="nf">r_shift3_comp</span> {<span class="nv">X</span> <span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î“3</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>} (<span class="nv">r1</span> : Î“1 âŠ† Î“2) (<span class="nv">r2</span> : Î“2 âŠ† Î“3)
      : @r_shift3 X Î“1 Î“3 a b c (r1 áµ£âŠ› r2) â‰¡â‚ r_shift3 r1 áµ£âŠ› r_shift3 r2 .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Î“1, Î“2, Î“3</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>Î“1 âŠ† Î“2</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>Î“2 âŠ† Î“3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r_shift3 (r1 áµ£âŠ› r2) â‰¡â‚ r_shift3 r1 áµ£âŠ› r_shift3 r2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? v; <span class="bp">now</span> <span class="kp">repeat</span> (dependent elimination v; <span class="nb">auto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>This is the end for now, but we have not yet instanciated the rest of the abstract
context structure. This is a bit more work, it takes place in another file:
<a class="reference external" href="Covering.html">Ctx/Covering.v</a></p>
</div>
</div>
</div></body>
</html>
