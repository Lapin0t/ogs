<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>Free context structure</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-windowed"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+↑</kbd> <kbd>Ctrl+↓</kbd> to navigate, <kbd>Ctrl+🖱️</kbd> to focus. On Mac, use <kbd>⌘</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="free-context-structure">
<h1 class="title">Free context structure</h1>

<p>Here we instanciate our abstract notion of context structure with the most common example:
lists and DeBruijn indices. More pedantically, this is the free context structure over
a given set <tt class="docutils literal">X</tt>.</p>
<div class="section" id="contexts">
<h1>Contexts</h1>
<p>Contexts are simply lists, with the purely aesthetic choice of representing cons as
coming from the right. Note on paper: we write here &quot;Γ ▶ x&quot; instead of &quot;Γ , x&quot;.</p>
<pre class="alectryon-io highlight" id="concretectx"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">ctx</span> (<span class="nv">X</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
| cnil : ctx X
| ccon : ctx X -&gt; X -&gt; ctx X.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;∅ₓ&quot;</span> := (cnil) : ctx_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;Γ ▶ₓ x&quot;</span> := (ccon Γ%ctx x) (<span class="kn">at level</span> <span class="mi">40</span>, <span class="kn">left associativity</span>) : ctx_scope.</span></span></pre><p>We wish to manipulate intrinsically typed terms. We hence need a tightly typed notion of
position in the context: rather than a loose index, <tt class="docutils literal">var x Γ</tt> is a proof of membership
of <tt class="docutils literal">x</tt> to <tt class="docutils literal">Γ</tt>: a well-scoped and well-typed DeBruijn index. See Ex. 5.</p>
<pre class="alectryon-io highlight" id="concretevar"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">var</span> {<span class="nv">X</span>} (<span class="nv">x</span> : X) : ctx X -&gt; <span class="kt">Type</span> :=
| top {Γ} : var x (Γ ▶ₓ x)
| pop {Γ y} : var x Γ -&gt; var x (Γ ▶ₓ y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cvar</span> {<span class="nv">X</span>} <span class="nv">Γ</span> <span class="nv">x</span> := @var X x Γ.</span></span></pre><p>A couple basic functions: length, concatenation and pointwise function application.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">c_length</span> {<span class="nv">X</span>} (<span class="nv">Γ</span> : ctx X) : nat :=
  c_length ∅ₓ       := Datatypes.O ;
  c_length (Γ ▶ₓ _) := Datatypes.S (c_length Γ) .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">ccat</span> {<span class="nv">X</span>} : ctx X -&gt; ctx X -&gt; ctx X :=
  ccat Γ ∅ₓ       := Γ ;
  ccat Γ (Δ ▶ₓ x) := ccat Γ Δ ▶ₓ x .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">c_map</span> {<span class="nv">X</span> <span class="nv">Y</span>} : (X -&gt; Y) -&gt; ctx X -&gt; ctx Y :=
  c_map f ∅ₓ       := cnil ;
  c_map f (Γ ▶ₓ x) := c_map f Γ ▶ₓ f x .</span></span></pre><p>Implementation of the revelant part of the abstract context interface.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">free_context</span> {<span class="nv">X</span>} : <span class="kp">context</span> X (ctx X) :=
  {| c_emp := cnil ; c_cat := ccat ; c_var := cvar |}.</span></span></pre><p>Basic theory.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk0"><span class="kn">Lemma</span> <span class="nf">c_cat_empty_l</span> {<span class="nv">X</span> : <span class="kt">Type</span>} {<span class="nv">Γ</span> : ctx X} : (∅ +▶ Γ)%ctx = Γ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∅ +▶ Γ = Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∅ +▶ Γ = Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> Γ; <span class="nb">eauto</span>; <span class="nb">cbn</span>; <span class="nb">f_equal</span>; <span class="nb">apply</span> IHΓ.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk2"><span class="kn">Lemma</span> <span class="nf">c_cat_empty_r</span> {<span class="nv">X</span> : <span class="kt">Type</span>} {<span class="nv">Γ</span> : ctx X} : (Γ +▶ ∅)%ctx = Γ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Γ +▶ ∅ = Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Γ +▶ ∅ = Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk4"><span class="kn">Lemma</span> <span class="nf">c_map_cat</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">Γ</span> <span class="nv">Δ</span> : ctx X)
  : c_map f (Γ +▶ Δ) = (c_map f Γ +▶ c_map f Δ)%ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">c_map f (Γ +▶ Δ) = c_map f Γ +▶ c_map f Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">c_map f (Γ +▶ Δ) = c_map f Γ +▶ c_map f Δ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> Δ; <span class="nb">eauto</span>; <span class="nb">cbn</span>; <span class="nb">f_equal</span>; <span class="nb">apply</span> IHΔ.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>A view-based inversion package for variables in mapped contexts.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">map_has</span> {<span class="nv">X</span> <span class="nv">Y</span>} {<span class="nv">f</span> : X -&gt; Y} (<span class="nv">Γ</span> : ctx X) {<span class="nv">x</span>} (<span class="nv">i</span> : Γ ∋ x) : c_map f Γ ∋ f x :=
  map_has (Γ ▶ₓ _) top     := top ;
  map_has (Γ ▶ₓ _) (pop i) := pop (map_has Γ i) .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Arguments</span> map_has {X Y f Γ x}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">has_map_view</span> {<span class="nv">X</span> <span class="nv">Y</span>} {<span class="nv">f</span> : X -&gt; Y} {<span class="nv">Γ</span>} : <span class="kr">forall</span> {<span class="nv">y</span>}, c_map f Γ ∋ y -&gt; <span class="kt">Type</span> :=
| HasMapV {x} (i : Γ ∋ x) : has_map_view (map_has i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk6"><span class="kn">Lemma</span> <span class="nf">view_has_map</span> {<span class="nv">X</span> <span class="nv">Y</span>} {<span class="nv">f</span> : X -&gt; Y} {<span class="nv">Γ</span>} [y] (i : c_map f Γ ∋ y) : has_map_view i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>c_map f Γ ∋ y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">has_map_view i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>c_map f Γ ∋ y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">has_map_view i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk8"><span class="nb">induction</span> Γ; dependent elimination i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>IHΓ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : c_map f Γ ∋ f x, has_map_view i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">has_map_view top</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ctx-v-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>var y (c_map f Γ)</span></span></span><br><span><var>IHΓ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : c_map f Γ ∋ y, has_map_view i</span></span></span><br></div><label class="goal-separator" for="ctx-v-chk9"><hr></label><div class="goal-conclusion">has_map_view (pop v)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chka">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>IHΓ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : c_map f Γ ∋ f x, has_map_view i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">has_map_view top</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (HasMapV top).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chkb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>var y (c_map f Γ)</span></span></span><br><span><var>IHΓ</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : c_map f Γ ∋ y, has_map_view i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">has_map_view (pop v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (IHΓ v); <span class="bp">exact</span> (HasMapV (pop i)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Additional goodies.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">r_pop</span> {<span class="nv">X</span>} {<span class="nv">Γ</span> : ctx X} {<span class="nv">x</span>} : Γ ⊆ (Γ ▶ₓ x) :=
  <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">i</span> =&gt; pop i.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Arguments</span> r_pop _ _ _ _/.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">a_append</span> {<span class="nv">X</span>} {<span class="nv">Γ</span> <span class="nv">Δ</span> : ctx X} {<span class="nv">F</span> : Fam₁ X (ctx X)} {<span class="nv">a</span>}
  : Γ =[F]&gt; Δ -&gt; F Δ a -&gt; (Γ ▶ₓ a) =[F]&gt; Δ :=
  a_append s z _ top     := z ;
  a_append s z _ (pop i) := s _ i .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;[ u ,ₓ x ]&quot;</span> := (a_append u x) (<span class="kn">at level</span> <span class="mi">9</span>) : asgn_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chkc">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">a_append_eq</span> {<span class="nv">X</span> <span class="nv">Γ</span> <span class="nv">Δ</span> <span class="nv">F</span> <span class="nv">a</span>}
  : Proper (asgn_eq _ _ ==&gt; eq ==&gt; asgn_eq _ _) (@a_append X Γ Δ F a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ X (ctx X)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (asgn_eq Γ Δ ==&gt; eq ==&gt; asgn_eq (Γ ▶ₓ a) Δ)
  a_append</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ X (ctx X)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (asgn_eq Γ Δ ==&gt; eq ==&gt; asgn_eq (Γ ▶ₓ a) Δ)
  a_append</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chke"><span class="nb">intros</span> ?? Hu ?? Hx ? i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ X (ctx X)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Γ =[ F ]&gt; Δ</span></span></span><br><span><var>Hu</var><span class="hyp-type"><b>: </b><span>x ≡ₐ y</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>F Δ a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x0 = y0</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Γ ▶ₓ a ∋ a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([x,ₓ x0])%asgn a0 i = ([y,ₓ y0])%asgn a0 i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chkf">dependent elimination i; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ0, Δ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ X (ctx X)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Γ0 =[ F ]&gt; Δ</span></span></span><br><span><var>Hu</var><span class="hyp-type"><b>: </b><span>x ≡ₐ y</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>F Δ a0</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x0 = y0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x0 = y0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ctx-v-chk10" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ1, Δ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ X (ctx X)</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Γ1 =[ F ]&gt; Δ</span></span></span><br><span><var>Hu</var><span class="hyp-type"><b>: </b><span>x ≡ₐ y</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>F Δ y1</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x0 = y0</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>var a0 Γ1</span></span></span><br></div><label class="goal-separator" for="ctx-v-chk10"><hr></label><div class="goal-conclusion">x a0 v = y a0 v</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk11">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ0, Δ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ X (ctx X)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Γ0 =[ F ]&gt; Δ</span></span></span><br><span><var>Hu</var><span class="hyp-type"><b>: </b><span>x ≡ₐ y</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>F Δ a0</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x0 = y0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x0 = y0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Hx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk12">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ1, Δ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ X (ctx X)</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Γ1 =[ F ]&gt; Δ</span></span></span><br><span><var>Hu</var><span class="hyp-type"><b>: </b><span>x ≡ₐ y</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>F Δ y1</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x0 = y0</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>var a0 Γ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x a0 v = y a0 v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> Hu.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>These concrete definition of shifts compute better than their <a class="reference external" href="Renaming.html#rshift">generic counterpart</a>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">r_shift1</span> {<span class="nv">X</span>} {<span class="nv">Γ</span> <span class="nv">Δ</span> : ctx X} {<span class="nv">a</span>} (<span class="nv">f</span> : Γ ⊆ Δ)
  : (Γ ▶ₓ a) ⊆ (Δ ▶ₓ a)
  := [ f ᵣ⊛ r_pop ,ₓ top ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">r_shift2</span> {<span class="nv">X</span>} {<span class="nv">Γ</span> <span class="nv">Δ</span> : ctx X} {<span class="nv">a</span> <span class="nv">b</span>} (<span class="nv">f</span> : Γ ⊆ Δ)
  : (Γ ▶ₓ a ▶ₓ b) ⊆ (Δ ▶ₓ a ▶ₓ b)
  := [ [ f ᵣ⊛ r_pop ᵣ⊛ r_pop ,ₓ pop top ] ,ₓ top ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">r_shift3</span> {<span class="nv">X</span>} {<span class="nv">Γ</span> <span class="nv">Δ</span> : ctx X} {<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>} (<span class="nv">f</span> : Γ ⊆ Δ)
  : (Γ ▶ₓ a ▶ₓ b ▶ₓ c) ⊆ (Δ ▶ₓ a ▶ₓ b ▶ₓ c)
  := [ [ [ f ᵣ⊛ r_pop ᵣ⊛ r_pop ᵣ⊛ r_pop ,ₓ pop (pop top) ] ,ₓ pop top ] ,ₓ top ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk13">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">r_shift1_eq</span> {<span class="nv">X</span> <span class="nv">Γ</span> <span class="nv">Δ</span> <span class="nv">a</span>}
  : Proper (asgn_eq _ _ ==&gt; asgn_eq _ _) (@r_shift1 X Γ Δ a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (asgn_eq Γ Δ ==&gt; asgn_eq (Γ ▶ₓ a) (Δ ▶ₓ a))
  r_shift1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (asgn_eq Γ Δ ==&gt; asgn_eq (Γ ▶ₓ a) (Δ ▶ₓ a))
  r_shift1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ?? Hu; <span class="nb">unfold</span> r_shift1; <span class="bp">now</span> <span class="nb">rewrite</span> Hu.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk15">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">r_shift2_eq</span> {<span class="nv">X</span> <span class="nv">Γ</span> <span class="nv">Δ</span> <span class="nv">a</span> <span class="nv">b</span>}
  : Proper (asgn_eq _ _ ==&gt; asgn_eq _ _) (@r_shift2 X Γ Δ a b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  (asgn_eq Γ Δ ==&gt; asgn_eq (Γ ▶ₓ a ▶ₓ b) (Δ ▶ₓ a ▶ₓ b))
  r_shift2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  (asgn_eq Γ Δ ==&gt; asgn_eq (Γ ▶ₓ a ▶ₓ b) (Δ ▶ₓ a ▶ₓ b))
  r_shift2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ?? Hu; <span class="nb">unfold</span> r_shift2; <span class="bp">now</span> <span class="nb">rewrite</span> Hu.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk17">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">r_shift3_eq</span> {<span class="nv">X</span> <span class="nv">Γ</span> <span class="nv">Δ</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>}
  : Proper (asgn_eq _ _ ==&gt; asgn_eq _ _) (@r_shift3 X Γ Δ a b c).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  (asgn_eq Γ Δ ==&gt;
   asgn_eq (Γ ▶ₓ a ▶ₓ b ▶ₓ c) (Δ ▶ₓ a ▶ₓ b ▶ₓ c))
  r_shift3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk18"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  (asgn_eq Γ Δ ==&gt;
   asgn_eq (Γ ▶ₓ a ▶ₓ b ▶ₓ c) (Δ ▶ₓ a ▶ₓ b ▶ₓ c))
  r_shift3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ?? Hu; <span class="nb">unfold</span> r_shift3; <span class="bp">now</span> <span class="nb">rewrite</span> Hu.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk19"><span class="kn">Lemma</span> <span class="nf">r_shift1_id</span> {<span class="nv">X</span> <span class="nv">Γ</span> <span class="nv">a</span>} : @r_shift1 X Γ Γ a r_id ≡ₐ r_id .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r_shift1 r_id ≡ₐ r_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? v; <span class="bp">now</span> <span class="kp">repeat</span> (dependent elimination v; <span class="nb">auto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk1a"><span class="kn">Lemma</span> <span class="nf">r_shift2_id</span> {<span class="nv">X</span> <span class="nv">Γ</span> <span class="nv">a</span> <span class="nv">b</span>} : @r_shift2 X Γ Γ a b r_id ≡ₐ r_id .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r_shift2 r_id ≡ₐ r_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? v; <span class="bp">now</span> <span class="kp">repeat</span> (dependent elimination v; <span class="nb">auto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk1b"><span class="kn">Lemma</span> <span class="nf">r_shift3_id</span> {<span class="nv">X</span> <span class="nv">Γ</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>} : @r_shift3 X Γ Γ a b c r_id ≡ₐ r_id .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r_shift3 r_id ≡ₐ r_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? v; <span class="bp">now</span> <span class="kp">repeat</span> (dependent elimination v; <span class="nb">auto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk1c"><span class="kn">Lemma</span> <span class="nf">r_shift1_comp</span> {<span class="nv">X</span> <span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">Γ3</span> <span class="nv">a</span>} (<span class="nv">r1</span> : Γ1 ⊆ Γ2) (<span class="nv">r2</span> : Γ2 ⊆ Γ3)
      : @r_shift1 X Γ1 Γ3 a (r1 ᵣ⊛ r2) ≡ₐ r_shift1 r1 ᵣ⊛ r_shift1 r2 .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ1, Γ2, Γ3</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>Γ1 ⊆ Γ2</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>Γ2 ⊆ Γ3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r_shift1 (r1 ᵣ⊛ r2) ≡ₐ r_shift1 r1 ᵣ⊛ r_shift1 r2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? v; <span class="bp">now</span> <span class="kp">repeat</span> (dependent elimination v; <span class="nb">auto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk1d"><span class="kn">Lemma</span> <span class="nf">r_shift2_comp</span> {<span class="nv">X</span> <span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">Γ3</span> <span class="nv">a</span> <span class="nv">b</span>} (<span class="nv">r1</span> : Γ1 ⊆ Γ2) (<span class="nv">r2</span> : Γ2 ⊆ Γ3)
      : @r_shift2 X Γ1 Γ3 a b (r1 ᵣ⊛ r2) ≡ₐ r_shift2 r1 ᵣ⊛ r_shift2 r2 .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ1, Γ2, Γ3</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>Γ1 ⊆ Γ2</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>Γ2 ⊆ Γ3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r_shift2 (r1 ᵣ⊛ r2) ≡ₐ r_shift2 r1 ᵣ⊛ r_shift2 r2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? v; <span class="bp">now</span> <span class="kp">repeat</span> (dependent elimination v; <span class="nb">auto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ctx-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="ctx-v-chk1e"><span class="kn">Lemma</span> <span class="nf">r_shift3_comp</span> {<span class="nv">X</span> <span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">Γ3</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>} (<span class="nv">r1</span> : Γ1 ⊆ Γ2) (<span class="nv">r2</span> : Γ2 ⊆ Γ3)
      : @r_shift3 X Γ1 Γ3 a b c (r1 ᵣ⊛ r2) ≡ₐ r_shift3 r1 ᵣ⊛ r_shift3 r2 .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ1, Γ2, Γ3</var><span class="hyp-type"><b>: </b><span>ctx X</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>Γ1 ⊆ Γ2</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>Γ2 ⊆ Γ3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r_shift3 (r1 ᵣ⊛ r2) ≡ₐ r_shift3 r1 ᵣ⊛ r_shift3 r2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? v; <span class="bp">now</span> <span class="kp">repeat</span> (dependent elimination v; <span class="nb">auto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>This is the end for now, but we have not yet instanciated the rest of the abstract
context structure. This is a bit more work, it takes place in another file:
<a class="reference external" href="Covering.html">Ctx/Covering.v</a></p>
</div>
</div>
</div></body>
</html>
