<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>Assignments</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-windowed"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+↑</kbd> <kbd>Ctrl+↓</kbd> to navigate, <kbd>Ctrl+🖱️</kbd> to focus. On Mac, use <kbd>⌘</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="assignments">
<h1 class="title">Assignments</h1>

<p>In this file we define assignments for a given abstract context structure. We also define
several combinators based on them: the internal substitution hom, filled operations,
copairing, etc.</p>
<div class="section" id="definition-of-assignments-def-5">
<h1>Definition of assignments (Def. 5)</h1>
<p>We distinguish assignments, mapping variables in a context to terms, from
substitutions, applying an assignment to a term. Assignments are intrinsically
typed, mapping variables of a context Γ to open terms with variables in Δ.</p>
<pre class="alectryon-io highlight" id="asgn"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">assignment</span> (<span class="nv">F</span> : Fam₁ T C) (<span class="nv">Γ</span> <span class="nv">Δ</span> : C) := <span class="kr">forall</span> <span class="nv">x</span>, Γ ∋ x -&gt; F Δ x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;Γ =[ F ]&gt; Δ&quot;</span> := (assignment F Γ%ctx Δ%ctx).</span></span></pre><p>Pointwise equality of assignments.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">asgn_eq</span> {<span class="nv">F</span> : Fam₁ T C} <span class="nv">Γ</span> <span class="nv">Δ</span> : relation (Γ =[F]&gt; Δ) := <span class="kr">∀</span><span class="nv">ₕ</span> <span class="nv">_</span>, <span class="kr">∀</span><span class="nv">ₕ</span> <span class="nv">_</span>, eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;u ≡ₐ v&quot;</span> := (asgn_eq _ _ u%asgn v%asgn).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chk0">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">asgn_equiv</span> {<span class="nv">F</span> <span class="nv">Γ</span> <span class="nv">Δ</span>} : Equivalence (@asgn_eq F Γ Δ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equivalence (asgn_eq Γ Δ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equivalence (asgn_eq Γ Δ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chk2"><span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflexive (asgn_eq Γ Δ)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="assignment-v-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><label class="goal-separator" for="assignment-v-chk3"><hr></label><div class="goal-conclusion">Symmetric (asgn_eq Γ Δ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="assignment-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><label class="goal-separator" for="assignment-v-chk4"><hr></label><div class="goal-conclusion">Transitive (asgn_eq Γ Δ)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflexive (asgn_eq Γ Δ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">intros</span> u ? i.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Symmetric (asgn_eq Γ Δ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> u h ? ? i; <span class="nb">symmetry</span>; <span class="bp">now</span> <span class="nb">apply</span> (H _ i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Transitive (asgn_eq Γ Δ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> u v w h1 h2 ? i; <span class="nb">transitivity</span> (v _ i); [ <span class="bp">now</span> <span class="nb">apply</span> h1 | <span class="bp">now</span> <span class="nb">apply</span> h2 ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Internal hom functors. The monoidal product for substitution is a bit cumbersome as
it is expressed as a coend, that is, a quotient. Following the formalization by
Dima Szamozvancev, we instead prefer to express everything in terms of its adjoint,
the internal hom.</p>
<p>For example the monoidal multiplication map will not be typed <tt class="docutils literal">X ⊗ X ⇒ X</tt> but
<tt class="docutils literal">X ⇒ ⟦ X , X ⟧</tt>.</p>
<p>It is an end, that is, a subset, which are far more easy to work with as they can
simply be encoded as a record pairing an element and a proof. The proof part is not
written here but encoded later on.</p>
<p>The real one is ⟦-,-⟧₁, but in fact we can define an analogue to this bifunctor
for any functor category <tt class="docutils literal">ctx → C</tt>, which we do here for Fam₀ and Fam₂ (unsorted and
bisorted, scoped families). This will be helpful to define what it means to
substitute other kinds of syntactic objects.</p>
<p>See <a class="reference external" href="Abstract.html">Ctx/Abstract.v</a> for more details on the theory. This is called
the _power <a href="#system-message-1"><span class="problematic" id="problematic-1">object_</span></a> (Def. 6) in the paper.</p>
<pre class="alectryon-io highlight" id="ihom"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">internal_hom₀</span> : Fam₁ T C -&gt; Fam₀ T C -&gt; Fam₀ T C
    := <span class="kr">fun</span> <span class="nv">F</span> <span class="nv">G</span> <span class="nv">Γ</span> =&gt; <span class="kr">forall</span> <span class="nv">Δ</span>, Γ =[F]&gt; Δ -&gt; G Δ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">internal_hom₁</span> : Fam₁ T C -&gt; Fam₁ T C -&gt; Fam₁ T C
    := <span class="kr">fun</span> <span class="nv">F</span> <span class="nv">G</span> <span class="nv">Γ</span> <span class="nv">x</span> =&gt; <span class="kr">forall</span> <span class="nv">Δ</span>, Γ =[F]&gt; Δ -&gt; G Δ x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">internal_hom₂</span> : Fam₁ T C -&gt; Fam₂ T C -&gt; Fam₂ T C
    := <span class="kr">fun</span> <span class="nv">F</span> <span class="nv">G</span> <span class="nv">Γ</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; <span class="kr">forall</span> <span class="nv">Δ</span>, Γ =[F]&gt; Δ -&gt; G Δ x y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;⟦ F , G ⟧₀&quot;</span> := (internal_hom₀ F G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;⟦ F , G ⟧₁&quot;</span> := (internal_hom₁ F G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;⟦ F , G ⟧₂&quot;</span> := (internal_hom₂ F G).</span></span></pre><p>Constructing a sorted family of operations from O with arguments taken from the family F.</p>
<pre class="alectryon-io highlight" id="filledop"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">filled_op</span> (<span class="nv">O</span> : Oper T C) (<span class="nv">F</span> : Fam₁ T C) (<span class="nv">Γ</span> : C) (<span class="nv">t</span> : T) :=
    OFill { fill_op : O t ; fill_args : o_dom fill_op =[F]&gt; Γ }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;S # F&quot;</span> := (filled_op S F).</span></span></pre><p>We can forget the arguments and get back a bare operation.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">forget_args</span> {<span class="nv">O</span> : Oper T C} {<span class="nv">F</span>} : (O # F) ⇒<span class="err">₁</span> ⦉ O ⦊
    := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; fill_op.</span></span></pre><p>The empty assignment.</p>
<pre class="alectryon-io highlight" id="asgnempty"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a_empty</span> {<span class="nv">F</span> <span class="nv">Γ</span>} : ∅ =[F]&gt; Γ
    := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">i</span> =&gt; <span class="kr">match</span> c_view_emp i <span class="kr">with</span> <span class="kr">end</span>.</span></span></pre><p>The copairing of assignments.</p>
<pre class="alectryon-io highlight" id="asgncat"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a_cat</span> {<span class="nv">F</span> <span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">Δ</span>} (<span class="nv">u</span> : Γ1 =[F]&gt; Δ) (<span class="nv">v</span> : Γ2 =[F]&gt; Δ) : (Γ1 +▶ Γ2) =[F]&gt; Δ
    := <span class="kr">fun</span> <span class="nv">t</span> <span class="nv">i</span> =&gt; <span class="kr">match</span> c_view_cat i <span class="kr">with</span>
               | Vcat_l i =&gt; u _ i
               | Vcat_r j =&gt; v _ j
               <span class="kr">end</span>.</span></span></pre><p>A kind relaxed of pointwise mapping.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a_map</span> {<span class="nv">F</span> <span class="nv">G</span> : Fam₁ T C} {<span class="nv">Γ</span> <span class="nv">Δ1</span> <span class="nv">Δ2</span>} (<span class="nv">u</span> : Γ =[F]&gt; Δ1) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span>, F Δ1 x -&gt; G Δ2 x)
    : Γ =[G]&gt; Δ2
    := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">i</span> =&gt; f _ (u _ i) .</span></span></pre><p>Copairing respects pointwise equality.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chk8">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">a_cat_eq</span> {<span class="nv">F</span> <span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">Δ</span>}
    : Proper (asgn_eq _ _ ==&gt; asgn_eq _ _ ==&gt; asgn_eq _ _) (@a_cat F Γ1 Γ2 Δ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>Γ1, Γ2, Δ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  (asgn_eq Γ1 Δ ==&gt;
   asgn_eq Γ2 Δ ==&gt; asgn_eq (Γ1 +▶ Γ2)%ctx Δ) a_cat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>Γ1, Γ2, Δ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  (asgn_eq Γ1 Δ ==&gt;
   asgn_eq Γ2 Δ ==&gt; asgn_eq (Γ1 +▶ Γ2)%ctx Δ) a_cat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chka"><span class="nb">intros</span> ?? Hu ?? Hv ??; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Fam₁ T C</span></span></span><br><span><var>Γ1, Γ2, Δ</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Γ1 =[ F ]&gt; Δ</span></span></span><br><span><var>Hu</var><span class="hyp-type"><b>: </b><span>x ≡ₐ y</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>Γ2 =[ F ]&gt; Δ</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>x0 ≡ₐ y0</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>Γ1 +▶ Γ2 ∋ a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> c_view_cat a0 <span class="kr">with</span>
| Vcat_l i =&gt; x a i
| Vcat_r j =&gt; x0 a j
<span class="kr">end</span> =
<span class="kr">match</span> c_view_cat a0 <span class="kr">with</span>
| Vcat_l i =&gt; y a i
| Vcat_r j =&gt; y0 a j
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (c_view_cat a0); [ <span class="bp">now</span> <span class="nb">apply</span> Hu | <span class="bp">now</span> <span class="nb">apply</span> Hv ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">with_param</span>.</span></span></pre><p>Registering all the notations...</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;Γ =[ F ]&gt; Δ&quot;</span> := (assignment F Γ%ctx Δ%ctx).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Bind Scope</span> asgn_scope <span class="kr">with</span> assignment.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;u ≡ₐ v&quot;</span> := (asgn_eq _ _ u%asgn v%asgn).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;⟦ F , G ⟧₀&quot;</span> := (internal_hom₀ F G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;⟦ F , G ⟧₁&quot;</span> := (internal_hom₁ F G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;⟦ F , G ⟧₂&quot;</span> := (internal_hom₂ F G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;S # F&quot;</span> := (filled_op S F).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;o ⦇ u ⦈&quot;</span> := (OFill o u%asgn).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;!&quot;</span> := (a_empty) : asgn_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;[ u , v ]&quot;</span> := (a_cat u v) : asgn_scope.</span></span></pre></div>
<div class="system-messages section">
<h1>Docutils System Messages</h1>
<div class="system-message" id="system-message-1">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">theories/Ctx/Assignment.v</tt>, line 80); <em><a href="#problematic-1">backlink</a></em></p>
Unknown target name: &quot;object&quot;.</div>
</div>
</div>
</div></body>
</html>
