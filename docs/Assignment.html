<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>Assignments</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-windowed"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+â†‘</kbd> <kbd>Ctrl+â†“</kbd> to navigate, <kbd>Ctrl+ğŸ–±ï¸</kbd> to focus. On Mac, use <kbd>âŒ˜</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="assignments">
<h1 class="title">Assignments</h1>

<p>In this file we define assignments for a given abstract context structure. We also define
several combinators based on them: the internal substitution hom, filled operations,
copairing, etc.</p>
<div class="section" id="definition-of-assignments-def-5">
<h1>Definition of assignments (Def. 5)</h1>
<p>We distinguish assignments, mapping variables in a context to terms, from
substitutions, applying an assignment to a term. Assignments are intrinsically
typed, mapping variables of a context Î“ to open terms with variables in Î”.</p>
<pre class="alectryon-io highlight" id="asgn"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">assignment</span> (<span class="nv">F</span> : Famâ‚ T C) (<span class="nv">Î“</span> <span class="nv">Î”</span> : C) := <span class="kr">forall</span> <span class="nv">x</span>, Î“ âˆ‹ x -&gt; F Î” x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;Î“ =[ F ]&gt; Î”&quot;</span> := (assignment F Î“%ctx Î”%ctx).</span></span></pre><p>Pointwise equality of assignments.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">asgn_eq</span> {<span class="nv">F</span> : Famâ‚ T C} <span class="nv">Î“</span> <span class="nv">Î”</span> : relation (Î“ =[F]&gt; Î”) := <span class="kr">âˆ€</span><span class="nv">â‚•</span> <span class="nv">_</span>, <span class="kr">âˆ€</span><span class="nv">â‚•</span> <span class="nv">_</span>, eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;u â‰¡â‚ v&quot;</span> := (asgn_eq _ _ u%asgn v%asgn).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chk0">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">asgn_equiv</span> {<span class="nv">F</span> <span class="nv">Î“</span> <span class="nv">Î”</span>} : Equivalence (@asgn_eq F Î“ Î”).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ T C</span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equivalence (asgn_eq Î“ Î”)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ T C</span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equivalence (asgn_eq Î“ Î”)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chk2"><span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ T C</span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflexive (asgn_eq Î“ Î”)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="assignment-v-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ T C</span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><label class="goal-separator" for="assignment-v-chk3"><hr></label><div class="goal-conclusion">Symmetric (asgn_eq Î“ Î”)</div></blockquote><input class="alectryon-extra-goal-toggle" id="assignment-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ T C</span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><label class="goal-separator" for="assignment-v-chk4"><hr></label><div class="goal-conclusion">Transitive (asgn_eq Î“ Î”)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ T C</span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflexive (asgn_eq Î“ Î”)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">intros</span> u ? i.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ T C</span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Symmetric (asgn_eq Î“ Î”)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> u h ? ? i; <span class="nb">symmetry</span>; <span class="bp">now</span> <span class="nb">apply</span> (H _ i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ T C</span></span></span><br><span><var>Î“, Î”</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Transitive (asgn_eq Î“ Î”)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> u v w h1 h2 ? i; <span class="nb">transitivity</span> (v _ i); [ <span class="bp">now</span> <span class="nb">apply</span> h1 | <span class="bp">now</span> <span class="nb">apply</span> h2 ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Internal hom functors. The monoidal product for substitution is a bit cumbersome as
it is expressed as a coend, that is, a quotient. Following the formalization by
Dima Szamozvancev, we instead prefer to express everything in terms of its adjoint,
the internal hom.</p>
<p>For example the monoidal multiplication map will not be typed <tt class="docutils literal">X âŠ— X â‡’ X</tt> but
<tt class="docutils literal">X â‡’ âŸ¦ X , X âŸ§</tt>.</p>
<p>It is an end, that is, a subset, which are far more easy to work with as they can
simply be encoded as a record pairing an element and a proof. The proof part is not
written here but encoded later on.</p>
<p>The real one is âŸ¦-,-âŸ§â‚, but in fact we can define an analogue to this bifunctor
for any functor category <tt class="docutils literal">ctx â†’ C</tt>, which we do here for Famâ‚€ and Famâ‚‚ (unsorted and
bisorted, scoped families). This will be helpful to define what it means to
substitute other kinds of syntactic objects.</p>
<p>See <a class="reference external" href="Abstract.html">Ctx/Abstract.v</a> for more details on the theory. This is called
the _power <a href="#system-message-1"><span class="problematic" id="problematic-1">object_</span></a> (Def. 6) in the paper.</p>
<pre class="alectryon-io highlight" id="ihom"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">internal_homâ‚€</span> : Famâ‚ T C -&gt; Famâ‚€ T C -&gt; Famâ‚€ T C
    := <span class="kr">fun</span> <span class="nv">F</span> <span class="nv">G</span> <span class="nv">Î“</span> =&gt; <span class="kr">forall</span> <span class="nv">Î”</span>, Î“ =[F]&gt; Î” -&gt; G Î”.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">internal_homâ‚</span> : Famâ‚ T C -&gt; Famâ‚ T C -&gt; Famâ‚ T C
    := <span class="kr">fun</span> <span class="nv">F</span> <span class="nv">G</span> <span class="nv">Î“</span> <span class="nv">x</span> =&gt; <span class="kr">forall</span> <span class="nv">Î”</span>, Î“ =[F]&gt; Î” -&gt; G Î” x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">internal_homâ‚‚</span> : Famâ‚ T C -&gt; Famâ‚‚ T C -&gt; Famâ‚‚ T C
    := <span class="kr">fun</span> <span class="nv">F</span> <span class="nv">G</span> <span class="nv">Î“</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; <span class="kr">forall</span> <span class="nv">Î”</span>, Î“ =[F]&gt; Î” -&gt; G Î” x y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;âŸ¦ F , G âŸ§â‚€&quot;</span> := (internal_homâ‚€ F G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;âŸ¦ F , G âŸ§â‚&quot;</span> := (internal_homâ‚ F G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;âŸ¦ F , G âŸ§â‚‚&quot;</span> := (internal_homâ‚‚ F G).</span></span></pre><p>Constructing a sorted family of operations from O with arguments taken from the family F.</p>
<pre class="alectryon-io highlight" id="filledop"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">filled_op</span> (<span class="nv">O</span> : Oper T C) (<span class="nv">F</span> : Famâ‚ T C) (<span class="nv">Î“</span> : C) (<span class="nv">t</span> : T) :=
    OFill { fill_op : O t ; fill_args : o_dom fill_op =[F]&gt; Î“ }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;S # F&quot;</span> := (filled_op S F).</span></span></pre><p>We can forget the arguments and get back a bare operation.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">forget_args</span> {<span class="nv">O</span> : Oper T C} {<span class="nv">F</span>} : (O # F) â‡’<span class="err">â‚</span> â¦‰ O â¦Š
    := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; fill_op.</span></span></pre><p>The empty assignment.</p>
<pre class="alectryon-io highlight" id="asgnempty"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a_empty</span> {<span class="nv">F</span> <span class="nv">Î“</span>} : âˆ… =[F]&gt; Î“
    := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">i</span> =&gt; <span class="kr">match</span> c_view_emp i <span class="kr">with</span> <span class="kr">end</span>.</span></span></pre><p>The copairing of assignments.</p>
<pre class="alectryon-io highlight" id="asgncat"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a_cat</span> {<span class="nv">F</span> <span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î”</span>} (<span class="nv">u</span> : Î“1 =[F]&gt; Î”) (<span class="nv">v</span> : Î“2 =[F]&gt; Î”) : (Î“1 +â–¶ Î“2) =[F]&gt; Î”
    := <span class="kr">fun</span> <span class="nv">t</span> <span class="nv">i</span> =&gt; <span class="kr">match</span> c_view_cat i <span class="kr">with</span>
               | Vcat_l i =&gt; u _ i
               | Vcat_r j =&gt; v _ j
               <span class="kr">end</span>.</span></span></pre><p>A kind relaxed of pointwise mapping.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a_map</span> {<span class="nv">F</span> <span class="nv">G</span> : Famâ‚ T C} {<span class="nv">Î“</span> <span class="nv">Î”1</span> <span class="nv">Î”2</span>} (<span class="nv">u</span> : Î“ =[F]&gt; Î”1) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span>, F Î”1 x -&gt; G Î”2 x)
    : Î“ =[G]&gt; Î”2
    := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">i</span> =&gt; f _ (u _ i) .</span></span></pre><p>Copairing respects pointwise equality.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chk8">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">a_cat_eq</span> {<span class="nv">F</span> <span class="nv">Î“1</span> <span class="nv">Î“2</span> <span class="nv">Î”</span>}
    : Proper (asgn_eq _ _ ==&gt; asgn_eq _ _ ==&gt; asgn_eq _ _) (@a_cat F Î“1 Î“2 Î”).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ T C</span></span></span><br><span><var>Î“1, Î“2, Î”</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  (asgn_eq Î“1 Î” ==&gt;
   asgn_eq Î“2 Î” ==&gt; asgn_eq (Î“1 +â–¶ Î“2)%ctx Î”) a_cat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ T C</span></span></span><br><span><var>Î“1, Î“2, Î”</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper
  (asgn_eq Î“1 Î” ==&gt;
   asgn_eq Î“2 Î” ==&gt; asgn_eq (Î“1 +â–¶ Î“2)%ctx Î”) a_cat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="assignment-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="assignment-v-chka"><span class="nb">intros</span> ?? Hu ?? Hv ??; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>CC</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> T C</span></span></span><br><span><var>CL</var><span class="hyp-type"><b>: </b><span>context_laws T C</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Famâ‚ T C</span></span></span><br><span><var>Î“1, Î“2, Î”</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Î“1 =[ F ]&gt; Î”</span></span></span><br><span><var>Hu</var><span class="hyp-type"><b>: </b><span>x â‰¡â‚ y</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>Î“2 =[ F ]&gt; Î”</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>x0 â‰¡â‚ y0</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>Î“1 +â–¶ Î“2 âˆ‹ a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> c_view_cat a0 <span class="kr">with</span>
| Vcat_l i =&gt; x a i
| Vcat_r j =&gt; x0 a j
<span class="kr">end</span> =
<span class="kr">match</span> c_view_cat a0 <span class="kr">with</span>
| Vcat_l i =&gt; y a i
| Vcat_r j =&gt; y0 a j
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (c_view_cat a0); [ <span class="bp">now</span> <span class="nb">apply</span> Hu | <span class="bp">now</span> <span class="nb">apply</span> Hv ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">with_param</span>.</span></span></pre><p>Registering all the notations...</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;Î“ =[ F ]&gt; Î”&quot;</span> := (assignment F Î“%ctx Î”%ctx).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Bind Scope</span> asgn_scope <span class="kr">with</span> assignment.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;u â‰¡â‚ v&quot;</span> := (asgn_eq _ _ u%asgn v%asgn).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;âŸ¦ F , G âŸ§â‚€&quot;</span> := (internal_homâ‚€ F G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;âŸ¦ F , G âŸ§â‚&quot;</span> := (internal_homâ‚ F G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;âŸ¦ F , G âŸ§â‚‚&quot;</span> := (internal_homâ‚‚ F G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;S # F&quot;</span> := (filled_op S F).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;o â¦‡ u â¦ˆ&quot;</span> := (OFill o u%asgn).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;!&quot;</span> := (a_empty) : asgn_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;[ u , v ]&quot;</span> := (a_cat u v) : asgn_scope.</span></span></pre></div>
<div class="system-messages section">
<h1>Docutils System Messages</h1>
<div class="system-message" id="system-message-1">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">theories/Ctx/Assignment.v</tt>, line 80); <em><a href="#problematic-1">backlink</a></em></p>
Unknown target name: &quot;object&quot;.</div>
</div>
</div>
</div></body>
</html>
